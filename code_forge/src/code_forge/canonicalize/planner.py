from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Iterable


def _utc_now() -> str:
    return datetime.now(timezone.utc).isoformat()


def _safe_relative(path_value: str) -> Path:
    path = Path(path_value)
    if path.is_absolute():
        path = Path(*path.parts[1:])
    cleaned = []
    for part in path.parts:
        if part in {"", ".", ".."}:
            continue
        cleaned.append(part)
    return Path(*cleaned) if cleaned else Path("unknown")


def _canonical_target(source_path: str, language: str, category: str) -> str:
    rel = _safe_relative(source_path)
    language = (language or "text").lower().strip() or "text"
    category = (category or "source").lower().strip() or "source"

    if category == "test":
        return str(Path("canonical") / "tests" / language / rel)
    if category == "config":
        return str(Path("canonical") / "config" / rel)
    if category == "doc":
        return str(Path("canonical") / "docs" / rel)
    if category == "script":
        return str(Path("canonical") / "scripts" / language / rel)
    return str(Path("canonical") / "src" / language / rel)


def _module_from_py_path(path_value: str) -> str:
    path = _safe_relative(path_value)
    if path.suffix != ".py":
        return ""
    without_suffix = path.with_suffix("")
    parts = [p for p in without_suffix.parts if p not in {"src", "canonical"}]
    return ".".join(parts)


def _shim_for_mapping(source_path: str, target_path: str) -> str:
    source_mod = _module_from_py_path(source_path)
    target_mod = _module_from_py_path(target_path)
    if not source_mod or not target_mod:
        return ""
    return (
        '"""Compatibility shim generated by Code Forge canonicalization planner."""\n\n'
        f"from {target_mod} import *  # noqa: F401,F403\n"
    )


def build_canonical_migration_plan(
    *,
    triage_path: Path,
    output_dir: Path,
    include_labels: Iterable[str] = ("extract", "refactor", "delete_candidate"),
    max_entries: int = 500,
    generate_shims: bool = True,
) -> dict[str, Any]:
    triage_path = Path(triage_path).resolve()
    output_dir = Path(output_dir).resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    if not triage_path.exists():
        raise FileNotFoundError(f"triage file not found: {triage_path}")

    triage_payload = json.loads(triage_path.read_text(encoding="utf-8"))
    entries = triage_payload.get("entries", [])
    labels = {str(label) for label in include_labels}

    selected = [entry for entry in entries if isinstance(entry, dict) and str(entry.get("label")) in labels]
    selected = selected[: max(1, int(max_entries))]

    migration_entries: list[dict[str, Any]] = []
    shims_written = 0
    for entry in selected:
        source_path = str(entry.get("file_path") or "")
        metrics = entry.get("metrics") or {}
        language = str(metrics.get("language") or "text")
        category = str(metrics.get("category") or "source")
        label = str(entry.get("label") or "quarantine")

        target_path = _canonical_target(source_path=source_path, language=language, category=category)
        strategy = "extract_to_canonical"
        if label == "refactor":
            strategy = "refactor_then_extract"
        elif label == "delete_candidate":
            strategy = "extract_unique_then_delete"

        item = {
            "source_path": source_path,
            "target_path": target_path,
            "label": label,
            "strategy": strategy,
            "reasons": entry.get("reasons", []),
            "metrics": metrics,
        }
        migration_entries.append(item)

        if generate_shims and source_path.endswith(".py") and source_path != target_path:
            shim = _shim_for_mapping(source_path, target_path)
            if shim:
                shim_path = output_dir / "shims" / _safe_relative(source_path)
                shim_path.parent.mkdir(parents=True, exist_ok=True)
                shim_path.write_text(shim, encoding="utf-8")
                shims_written += 1

    migration_map = {
        "generated_at": _utc_now(),
        "source_triage": str(triage_path),
        "selected_count": len(migration_entries),
        "labels": sorted(labels),
        "entries": migration_entries,
        "shims_generated": shims_written,
    }

    migration_json = output_dir / "migration_map.json"
    migration_json.write_text(json.dumps(migration_map, indent=2) + "\n", encoding="utf-8")

    plan_lines = [
        "# Canonical Migration Plan",
        "",
        f"Generated: {_utc_now()}",
        f"Source triage: `{triage_path}`",
        f"Selected entries: {len(migration_entries)}",
        f"Compatibility shims generated: {shims_written}",
        "",
        "## Strategy Counts",
        "",
    ]
    strategy_counts: dict[str, int] = {}
    for item in migration_entries:
        strategy = item["strategy"]
        strategy_counts[strategy] = strategy_counts.get(strategy, 0) + 1
    for strategy, count in sorted(strategy_counts.items()):
        plan_lines.append(f"- `{strategy}`: {count}")

    plan_lines.append("")
    plan_lines.append("## Mappings")
    plan_lines.append("")
    for item in migration_entries[:200]:
        plan_lines.append(
            f"- `{item['source_path']}` -> `{item['target_path']}` | label=`{item['label']}` | strategy=`{item['strategy']}`"
        )

    plan_md = output_dir / "canonicalization_plan.md"
    plan_md.write_text("\n".join(plan_lines) + "\n", encoding="utf-8")

    summary = {
        "generated_at": _utc_now(),
        "migration_map": str(migration_json),
        "plan_md": str(plan_md),
        "selected_count": len(migration_entries),
        "shims_generated": shims_written,
    }
    (output_dir / "canonicalization_summary.json").write_text(json.dumps(summary, indent=2) + "\n", encoding="utf-8")
    return summary
