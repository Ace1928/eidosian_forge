import re
import logging; log = logging.getLogger(__name__)
from warnings import warn
from passlib.utils import safe_crypt, test_crypt, to_unicode
from passlib.utils.binary import h64, h64big
from passlib.utils.compat import byte_elem_value, u, uascii_to_str, unicode, suppress_cause
from passlib.crypto.des import des_encrypt_int_block
import passlib.utils.handlers as uh
class des_crypt(uh.TruncateMixin, uh.HasManyBackends, uh.HasSalt, uh.GenericHandler):
    """This class implements the des-crypt password hash, and follows the :ref:`password-hash-api`.

    It supports a fixed-length salt.

    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:

    :type salt: str
    :param salt:
        Optional salt string.
        If not specified, one will be autogenerated (this is recommended).
        If specified, it must be 2 characters, drawn from the regexp range ``[./0-9A-Za-z]``.

    :param bool truncate_error:
        By default, des_crypt will silently truncate passwords larger than 8 bytes.
        Setting ``truncate_error=True`` will cause :meth:`~passlib.ifc.PasswordHash.hash`
        to raise a :exc:`~passlib.exc.PasswordTruncateError` instead.

        .. versionadded:: 1.7

    :type relaxed: bool
    :param relaxed:
        By default, providing an invalid value for one of the other
        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,
        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`
        will be issued instead. Correctable errors include
        ``salt`` strings that are too long.

        .. versionadded:: 1.6
    """
    name = 'des_crypt'
    setting_kwds = ('salt', 'truncate_error')
    checksum_chars = uh.HASH64_CHARS
    checksum_size = 11
    min_salt_size = max_salt_size = 2
    salt_chars = uh.HASH64_CHARS
    truncate_size = 8
    _hash_regex = re.compile(u('\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{11})?\n        $'), re.X | re.I)

    @classmethod
    def from_string(cls, hash):
        hash = to_unicode(hash, 'ascii', 'hash')
        salt, chk = (hash[:2], hash[2:])
        return cls(salt=salt, checksum=chk or None)

    def to_string(self):
        hash = u('%s%s') % (self.salt, self.checksum)
        return uascii_to_str(hash)

    def _calc_checksum(self, secret):
        if self.use_defaults:
            self._check_truncate_policy(secret)
        return self._calc_checksum_backend(secret)
    backends = ('os_crypt', 'builtin')

    @classmethod
    def _load_backend_os_crypt(cls):
        if test_crypt('test', 'abgOeLfPimXQo'):
            cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)
            return True
        else:
            return False

    def _calc_checksum_os_crypt(self, secret):
        hash = safe_crypt(secret, self.salt)
        if hash is None:
            return self._calc_checksum_builtin(secret)
        if not hash.startswith(self.salt) or len(hash) != 13:
            raise uh.exc.CryptBackendError(self, self.salt, hash)
        return hash[2:]

    @classmethod
    def _load_backend_builtin(cls):
        cls._set_calc_checksum_backend(cls._calc_checksum_builtin)
        return True

    def _calc_checksum_builtin(self, secret):
        return _raw_des_crypt(secret, self.salt.encode('ascii')).decode('ascii')