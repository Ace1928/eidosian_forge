from rdflib import BNode
from rdflib import Literal, URIRef
from rdflib import RDF as ns_rdf
from rdflib.term import XSDToPython
from . import IncorrectBlankNodeUsage, IncorrectLiteral, err_no_blank_node
from .utils import has_one_of_attributes, return_XML
import re
class ProcessProperty:
    """Generate the value for C{@property} taking into account datatype, etc.
    Note: this class is created only if the C{@property} is indeed present, no need to check.
    
    @ivar node: DOM element node
    @ivar graph: the (RDF) graph to add the properies to
    @ivar subject: the RDFLib URIRef serving as a subject for the generated triples
    @ivar state: the current state to be used for the CURIE-s
    @type state: L{state.ExecutionContext}
    @ivar typed_resource: Typically the bnode generated by a @typeof
    """

    def __init__(self, node, graph, subject, state, typed_resource=None):
        """
        @param node: DOM element node
        @param graph: the (RDF) graph to add the properies to
        @param subject: the RDFLib URIRef serving as a subject for the generated triples
        @param state: the current state to be used for the CURIE-s
        @param state: L{state.ExecutionContext}
        @param typed_resource: Typically the bnode generated by a @typeof; in RDFa 1.1, that becomes the object for C{@property}
        """
        self.node = node
        self.graph = graph
        self.subject = subject
        self.state = state
        self.typed_resource = typed_resource

    def generate(self):
        """
        Common entry point for the RDFa 1.0 and RDFa 1.1 versions; bifurcates based on the RDFa version, as retrieved from the state object.
        """
        if self.state.rdfa_version >= '1.1':
            self.generate_1_1()
        else:
            self.generate_1_0()

    def generate_1_1(self):
        """Generate the property object, 1.1 version"""
        irirefs = ('resource', 'href', 'src')
        noiri = ('content', 'datatype', 'rel', 'rev')
        notypediri = ('content', 'datatype', 'rel', 'rev', 'about', 'about_pruned')
        if has_one_of_attributes(self.node, irirefs) and (not has_one_of_attributes(self.node, noiri)):
            obj = self.state.getResource(irirefs)
        elif self.node.hasAttribute('typeof') and (not has_one_of_attributes(self.node, notypediri)) and (self.typed_resource != None):
            obj = self.typed_resource
        else:
            datatype = ''
            dtset = False
            if self.node.hasAttribute('datatype'):
                dtset = True
                dt = self.node.getAttribute('datatype')
                if dt != '':
                    datatype = self.state.getURI('datatype')
            if self.state.lang != None and self.state.supress_lang == False:
                lang = self.state.lang
            else:
                lang = ''
            if self.node.hasAttribute('content'):
                val = self.node.getAttribute('content')
                if dtset == False:
                    obj = Literal(val, lang=lang)
                else:
                    obj = self._create_Literal(val, datatype=datatype, lang=lang)
            elif dtset:
                if datatype == XMLLiteral:
                    litval = self._get_XML_literal(self.node)
                    obj = Literal(litval, datatype=XMLLiteral)
                elif datatype == HTMLLiteral:
                    obj = Literal(self._get_HTML_literal(self.node), datatype=HTMLLiteral)
                else:
                    obj = self._create_Literal(self._get_literal(self.node), datatype=datatype, lang=lang)
            else:
                obj = self._create_Literal(self._get_literal(self.node), lang=lang)
        if obj != None:
            for prop in self.state.getURI('property'):
                if not isinstance(prop, BNode):
                    if self.node.hasAttribute('inlist'):
                        self.state.add_to_list_mapping(prop, obj)
                    else:
                        self.graph.add((self.subject, prop, obj))
                else:
                    self.state.options.add_warning(err_no_blank_node % 'property', warning_type=IncorrectBlankNodeUsage, node=self.node.nodeName)

    def generate_1_0(self):
        """Generate the property object, 1.0 version"""
        datatype = ''
        dtset = False
        if self.node.hasAttribute('datatype'):
            dtset = True
            dt = self.node.getAttribute('datatype')
            if dt != '':
                datatype = self.state.getURI('datatype')
        if self.state.lang != None:
            lang = self.state.lang
        else:
            lang = ''
        if self.node.hasAttribute('content'):
            val = self.node.getAttribute('content')
            if dtset == False:
                obj = Literal(val, lang=lang)
            else:
                obj = self._create_Literal(val, datatype=datatype, lang=lang)
        elif dtset:
            if datatype == XMLLiteral:
                litval = self._get_XML_literal(self.node)
                obj = Literal(litval, datatype=XMLLiteral)
            elif datatype == HTMLLiteral:
                obj = Literal(self._get_HTML_literal(self.node), datatype=HTMLLiteral)
            else:
                obj = self._create_Literal(self._get_literal(self.node), datatype=datatype, lang=lang)
        elif True in [n.nodeType == self.node.ELEMENT_NODE for n in self.node.childNodes]:
            obj = self._create_Literal(self._get_XML_literal(self.node), datatype=XMLLiteral)
        else:
            obj = self._create_Literal(self._get_literal(self.node), lang=lang)
        for prop in self.state.getURI('property'):
            if not isinstance(prop, BNode):
                self.graph.add((self.subject, prop, obj))
            else:
                self.state.options.add_warning(err_no_blank_node % 'property', warning_type=IncorrectBlankNodeUsage, node=self.node.nodeName)

    def _putBackEntities(self, data):
        """Put 'back' entities for the '&','<', and '>' characters, to produce a proper XML string.
        Used by the XML Literal extraction.
        @param data: string to be converted
        @return: string with entities
        @rtype: string
        """
        return data.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    def _get_literal(self, Pnode):
        """
        Get (recursively) the full text from a DOM Node.
    
        @param Pnode: DOM Node
        @return: string
        """
        rc = ''
        for node in Pnode.childNodes:
            if node.nodeType == node.TEXT_NODE:
                rc = rc + node.data
            elif node.nodeType == node.ELEMENT_NODE:
                rc = rc + self._get_literal(node)
        if self.state.options.space_preserve:
            return rc
        else:
            return re.sub('(\\r| |\\n|\\t)+', ' ', rc).strip()

    def _get_XML_literal(self, Pnode):
        """
        Get (recursively) the XML Literal content of a DOM Node. 
    
        @param Pnode: DOM Node
        @return: string
        """
        rc = ''
        for node in Pnode.childNodes:
            if node.nodeType == node.TEXT_NODE:
                rc = rc + self._putBackEntities(node.data)
            elif node.nodeType == node.ELEMENT_NODE:
                rc = rc + return_XML(self.state, node, base=False)
        return rc

    def _get_HTML_literal(self, Pnode):
        """
        Get (recursively) the XML Literal content of a DOM Node. 
    
        @param Pnode: DOM Node
        @return: string
        """
        rc = ''
        for node in Pnode.childNodes:
            if node.nodeType == node.TEXT_NODE:
                rc = rc + self._putBackEntities(node.data)
            elif node.nodeType == node.ELEMENT_NODE:
                rc = rc + return_XML(self.state, node, base=False, xmlns=False)
        return rc

    def _create_Literal(self, val, datatype='', lang=''):
        """
        Create a literal, taking into account the datatype and language.
        @return: Literal
        """
        if datatype == None or datatype == '':
            return Literal(val, lang=lang)
        else:
            convFunc = XSDToPython.get(datatype, None)
            if convFunc:
                try:
                    _pv = convFunc(val)
                except:
                    self.state.options.add_warning('Incompatible value (%s) and datatype (%s) in Literal definition.' % (val, datatype), warning_type=IncorrectLiteral, node=self.node.nodeName)
            return Literal(val, datatype=datatype)