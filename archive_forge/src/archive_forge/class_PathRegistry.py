from __future__ import annotations
from functools import reduce
from itertools import chain
import logging
import operator
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import base as orm_base
from ._typing import insp_is_mapper_property
from .. import exc
from .. import util
from ..sql import visitors
from ..sql.cache_key import HasCacheKey
class PathRegistry(HasCacheKey):
    """Represent query load paths and registry functions.

    Basically represents structures like:

    (<User mapper>, "orders", <Order mapper>, "items", <Item mapper>)

    These structures are generated by things like
    query options (joinedload(), subqueryload(), etc.) and are
    used to compose keys stored in the query._attributes dictionary
    for various options.

    They are then re-composed at query compile/result row time as
    the query is formed and as rows are fetched, where they again
    serve to compose keys to look up options in the context.attributes
    dictionary, which is copied from query._attributes.

    The path structure has a limited amount of caching, where each
    "root" ultimately pulls from a fixed registry associated with
    the first mapper, that also contains elements for each of its
    property keys.  However paths longer than two elements, which
    are the exception rather than the rule, are generated on an
    as-needed basis.

    """
    __slots__ = ()
    is_token = False
    is_root = False
    has_entity = False
    is_property = False
    is_entity = False
    is_unnatural: bool
    path: _PathRepresentation
    natural_path: _PathRepresentation
    parent: Optional[PathRegistry]
    root: RootRegistry
    _cache_key_traversal: _CacheKeyTraversalType = [('path', visitors.ExtendedInternalTraversal.dp_has_cache_key_list)]

    def __eq__(self, other: Any) -> bool:
        try:
            return other is not None and self.path == other._path_for_compare
        except AttributeError:
            util.warn('Comparison of PathRegistry to %r is not supported' % type(other))
            return False

    def __ne__(self, other: Any) -> bool:
        try:
            return other is None or self.path != other._path_for_compare
        except AttributeError:
            util.warn('Comparison of PathRegistry to %r is not supported' % type(other))
            return True

    @property
    def _path_for_compare(self) -> Optional[_PathRepresentation]:
        return self.path

    def odd_element(self, index: int) -> _InternalEntityType[Any]:
        return self.path[index]

    def set(self, attributes: Dict[Any, Any], key: Any, value: Any) -> None:
        log.debug("set '%s' on path '%s' to '%s'", key, self, value)
        attributes[key, self.natural_path] = value

    def setdefault(self, attributes: Dict[Any, Any], key: Any, value: Any) -> None:
        log.debug("setdefault '%s' on path '%s' to '%s'", key, self, value)
        attributes.setdefault((key, self.natural_path), value)

    def get(self, attributes: Dict[Any, Any], key: Any, value: Optional[Any]=None) -> Any:
        key = (key, self.natural_path)
        if key in attributes:
            return attributes[key]
        else:
            return value

    def __len__(self) -> int:
        return len(self.path)

    def __hash__(self) -> int:
        return id(self)

    @overload
    def __getitem__(self, entity: _StrPathToken) -> TokenRegistry:
        ...

    @overload
    def __getitem__(self, entity: int) -> _PathElementType:
        ...

    @overload
    def __getitem__(self, entity: slice) -> _PathRepresentation:
        ...

    @overload
    def __getitem__(self, entity: _InternalEntityType[Any]) -> AbstractEntityRegistry:
        ...

    @overload
    def __getitem__(self, entity: MapperProperty[Any]) -> PropRegistry:
        ...

    def __getitem__(self, entity: Union[_StrPathToken, int, slice, _InternalEntityType[Any], MapperProperty[Any]]) -> Union[TokenRegistry, _PathElementType, _PathRepresentation, PropRegistry, AbstractEntityRegistry]:
        raise NotImplementedError()

    @property
    def length(self) -> int:
        return len(self.path)

    def pairs(self) -> Iterator[Tuple[_InternalEntityType[Any], Union[str, MapperProperty[Any]]]]:
        odd_path = cast(_OddPathRepresentation, self.path)
        even_path = cast(_EvenPathRepresentation, odd_path)
        for i in range(0, len(odd_path), 2):
            yield (odd_path[i], even_path[i + 1])

    def contains_mapper(self, mapper: Mapper[Any]) -> bool:
        _m_path = cast(_OddPathRepresentation, self.path)
        for path_mapper in [_m_path[i] for i in range(0, len(_m_path), 2)]:
            if path_mapper.mapper.isa(mapper):
                return True
        else:
            return False

    def contains(self, attributes: Dict[Any, Any], key: Any) -> bool:
        return (key, self.path) in attributes

    def __reduce__(self) -> Any:
        return (_unreduce_path, (self.serialize(),))

    @classmethod
    def _serialize_path(cls, path: _PathRepresentation) -> _SerializedPath:
        _m_path = cast(_OddPathRepresentation, path)
        _p_path = cast(_EvenPathRepresentation, path)
        return list(zip(tuple((m.class_ if m.is_mapper or m.is_aliased_class else str(m) for m in [_m_path[i] for i in range(0, len(_m_path), 2)])), tuple((p.key if insp_is_mapper_property(p) else str(p) for p in [_p_path[i] for i in range(1, len(_p_path), 2)])) + (None,)))

    @classmethod
    def _deserialize_path(cls, path: _SerializedPath) -> _PathRepresentation:

        def _deserialize_mapper_token(mcls: Any) -> Any:
            return orm_base._inspect_mapped_class(mcls, configure=True) if mcls not in PathToken._intern else PathToken._intern[mcls]

        def _deserialize_key_token(mcls: Any, key: Any) -> Any:
            if key is None:
                return None
            elif key in PathToken._intern:
                return PathToken._intern[key]
            else:
                mp = orm_base._inspect_mapped_class(mcls, configure=True)
                assert mp is not None
                return mp.attrs[key]
        p = tuple(chain(*[(_deserialize_mapper_token(mcls), _deserialize_key_token(mcls, key)) for mcls, key in path]))
        if p and p[-1] is None:
            p = p[0:-1]
        return p

    def serialize(self) -> _SerializedPath:
        path = self.path
        return self._serialize_path(path)

    @classmethod
    def deserialize(cls, path: _SerializedPath) -> PathRegistry:
        assert path is not None
        p = cls._deserialize_path(path)
        return cls.coerce(p)

    @overload
    @classmethod
    def per_mapper(cls, mapper: Mapper[Any]) -> CachingEntityRegistry:
        ...

    @overload
    @classmethod
    def per_mapper(cls, mapper: AliasedInsp[Any]) -> SlotsEntityRegistry:
        ...

    @classmethod
    def per_mapper(cls, mapper: _InternalEntityType[Any]) -> AbstractEntityRegistry:
        if mapper.is_mapper:
            return CachingEntityRegistry(cls.root, mapper)
        else:
            return SlotsEntityRegistry(cls.root, mapper)

    @classmethod
    def coerce(cls, raw: _PathRepresentation) -> PathRegistry:

        def _red(prev: PathRegistry, next_: _PathElementType) -> PathRegistry:
            return prev[next_]
        return reduce(_red, raw, cls.root)

    def __add__(self, other: PathRegistry) -> PathRegistry:

        def _red(prev: PathRegistry, next_: _PathElementType) -> PathRegistry:
            return prev[next_]
        return reduce(_red, other.path, self)

    def __str__(self) -> str:
        return f'ORM Path[{' -> '.join((str(elem) for elem in self.path))}]'

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}({self.path!r})'