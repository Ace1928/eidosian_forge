import atexit
import functools
import locale
import logging
import multiprocessing
import os
import traceback
import pathlib
import Pyro4.core
import argparse
from enum import IntEnum
import shutil
import socket
import struct
import collections
import subprocess
import sys
import tempfile
import threading
import time
from contextlib import contextmanager
import uuid
import psutil
import Pyro4
from random import Random
from minerl.env import comms
import minerl.utils.process_watcher
@Pyro4.expose
@Pyro4.behavior(instance_mode='single')
class InstanceManager:
    """The Minecraft instance manager library. The instance manager can be used to allocate and safely terminate 
    existing Malmo instances for training agents. 
    
    Note: This object never needs to be explicitly invoked by the user of the MineRL library as the creation of
    one of the several MineRL environments will automatically query the InstanceManager to create a new instance.

    Note: In future versions of MineRL the instance manager will become its own daemon process which provides
    instance allocation capability using remote procedure calls.
    """
    MINECRAFT_DIR = os.path.join(os.path.dirname(__file__), '..', 'MCP-Reborn')
    SCHEMAS_DIR = os.path.join(os.path.dirname(__file__), '..', 'Malmo', 'Schemas')
    STATUS_DIR = os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), 'performance')
    MAXINSTANCES = None
    KEEP_ALIVE_PYRO_FREQUENCY = 5
    REMOTE = False
    DEFAULT_IP = 'localhost'
    _instance_pool = []
    _malmo_base_port = 9000
    ninstances = 0
    X11_DIR = '/tmp/.X11-unix'
    headless = False
    managed = True
    _seed_type = SeedType.NONE
    _seed_generator = None

    @classmethod
    def _init_seeding(cls, seed_type=int(SeedType.NONE), seeds=None):
        """Sets the seeding type of the Instance manager object.
        
        Args:
            seed_type (SeedType, optional): The seed type of the instancemanger.. Defaults to SeedType.NONE.
            seed (long, optional): The initial seed of the instance manager. Defaults to None.
        
        Raises:
            TypeError: If the SeedType specified does not fall within the SeedType.
        """
        seed_type = int(seed_type)
        if seed_type == SeedType.NONE:
            assert seeds is None, 'Seed type set to NONE, therefore seed cannot be set.'
        elif seed_type == SeedType.CONSTANT:
            assert seeds is not None, 'Seed set to constant seed, so seed must be specified.'
            cls._seed_generator = [int(x) for x in seeds.split(',') if x]
        elif seed_type == SeedType.GENERATED:
            assert seeds is not None, 'Seed set to generated seed, so initial seed must be specified.'
            cls._seed_generator = Random(int(seeds))
        elif seed_type == SeedType.SPECIFIED:
            cls._seed_generator = [[str(x) for x in s.split(',') if x] for s in seeds.split('-') if s]
        else:
            raise TypeError('Seed type {} not supported'.format(seed_type))
        cls._seed_type = seed_type

    @classmethod
    def _get_next_seed(cls, i=None):
        """Gets the next seed for an instance.
        
        Raises:
            TypeError: If the seed type cannot generate seeds.
        
        Returns:
            long: The seed generated by the seed type generator for seeds.  
        """
        if cls._seed_type == SeedType.CONSTANT:
            return cls._seed_generator
        elif cls._seed_type == SeedType.GENERATED:
            return [cls._seed_generator.randint(-MAXRAND, MAXRAND)]
        elif cls._seed_type == SeedType.SPECIFIED:
            try:
                if i is None:
                    i = 0
                    logger.warning('Trying to use specified seed type without specifying index id.')
                return cls._seed_generator[i]
            except IndexError:
                raise TypeError('Seed type {} ran out of seeds.'.format(cls._seed_type))
        else:
            raise TypeError('Seed type {} does not support getting next seed'.format(cls._seed_type))

    @classmethod
    def get_instance(cls, pid, instance_id=None):
        """
        Gets an instance from the instance manager. This method is a context manager
        and therefore when the context is entered the method yields a InstanceManager.Instance
        object which contains the allocated port and host for the given instance that was created.

        Yields:
            The allocated InstanceManager.Instance object.
        
        Raises:
            RuntimeError: No available instances or the maximum number of allocated instances reached.
            RuntimeError: No available instances and automatic allocation of instances is off.
        """
        if not instance_id:
            for inst in cls._instance_pool:
                if not inst.locked:
                    inst._acquire_lock(pid)
                    if hasattr(cls, '_pyroDaemon'):
                        cls._pyroDaemon.register(inst)
                    return inst
        if cls.managed:
            if cls.MAXINSTANCES is None or cls.ninstances < cls.MAXINSTANCES:
                instance_id = cls.ninstances if instance_id is None else instance_id
                cls.ninstances += 1
                if hasattr(cls, '_pyroDaemon'):
                    status_dir = os.path.join(cls.STATUS_DIR, 'mc_{}'.format(cls.ninstances))
                    if not os.path.exists(status_dir):
                        os.makedirs(status_dir)
                else:
                    status_dir = None
                inst = MinecraftInstance(cls._get_valid_port(), status_dir=status_dir, instance_id=instance_id)
                cls._instance_pool.append(inst)
                inst._acquire_lock(pid)
                if hasattr(cls, '_pyroDaemon'):
                    cls._pyroDaemon.register(inst)
                return inst
            else:
                raise RuntimeError('No available instances and max instances reached! :O :O')
        else:
            raise RuntimeError('No available instances and managed flag is off')

    @classmethod
    def shutdown(cls):
        for inst in cls._instance_pool[:]:
            inst.release_lock()
            inst.kill()

    @classmethod
    @contextmanager
    def allocate_pool(cls, num):
        for _ in range(num):
            inst = MinecraftInstance(cls._get_valid_port())
            cls._instance_pool.append(inst)
        yield None
        cls.shutdown()

    @classmethod
    def add_existing_instance(cls, port):
        assert cls._is_port_taken(port), 'No Malmo mod utilizing the port specified.'
        instance = MinecraftInstance(port=port, existing=True, status_dir=None)
        cls._instance_pool.append(instance)
        cls.ninstances += 1
        return instance

    @classmethod
    def add_keep_alive(cls, _pid, _callback):
        logger.debug('Recieved keep-alive callback from client {}. Starting thread.'.format(_pid))

        def check_client_connected(client_pid, keep_alive_proxy):
            logger.debug('Client keep-alive connection monitor started for {}.'.format(client_pid))
            while True:
                time.sleep(InstanceManager.KEEP_ALIVE_PYRO_FREQUENCY)
                try:
                    keep_alive_proxy.call()
                except:
                    bad_insts = [inst for inst in cls._instance_pool if inst.owner == client_pid]
                    for inst in bad_insts:
                        inst.close()
        keep_alive_thread = threading.Thread(target=check_client_connected, args=(_pid, _callback))
        keep_alive_thread.setDaemon(True)
        keep_alive_thread.start()

    @staticmethod
    def _is_port_taken(port, address='0.0.0.0'):
        if psutil.MACOS or psutil.AIX:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                s.bind((address, port))
                taken = False
            except socket.error as e:
                if e.errno in [98, 10048, 48]:
                    taken = True
                else:
                    raise e
            s.close()
            return taken
        else:
            ports = [x.laddr.port for x in psutil.net_connections()]
            return port in ports

    @staticmethod
    def _is_display_port_taken(port, x11_path):
        return False

    @classmethod
    def _port_in_instance_pool(cls, port):
        return port in [instance.port for instance in cls._instance_pool]

    @classmethod
    def configure_malmo_base_port(cls, malmo_base_port):
        """Configure the lowest or base port for Malmo"""
        cls._malmo_base_port = malmo_base_port

    @classmethod
    def _get_valid_port(cls):
        malmo_base_port = cls._malmo_base_port
        port = cls.ninstances % 5000 + malmo_base_port
        port += 17 * os.getpid() % 3989
        while cls._is_port_taken(port) or cls._is_display_port_taken(port - malmo_base_port, cls.X11_DIR) or cls._port_in_instance_pool(port):
            port += 1
        return port

    @classmethod
    def is_remote(cls):
        return cls.REMOTE