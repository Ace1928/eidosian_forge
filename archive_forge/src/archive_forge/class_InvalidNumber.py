import collections
import enum
import functools
import itertools
import logging
import operator
import sys
from pyomo.common.collections import Sequence, ComponentMap, ComponentSet
from pyomo.common.deprecation import deprecation_warning
from pyomo.common.errors import DeveloperError, InvalidValueError
from pyomo.common.numeric_types import (
from pyomo.core.pyomoobject import PyomoObject
from pyomo.core.base import (
from pyomo.core.base.component import ActiveComponent
from pyomo.core.base.expression import _ExpressionData
from pyomo.core.expr.numvalue import is_fixed, value
import pyomo.core.expr as EXPR
import pyomo.core.kernel as kernel
class InvalidNumber(PyomoObject):

    def __init__(self, value, cause=''):
        self.value = value
        if cause.__class__ is list:
            self.causes = list(cause)
        else:
            self.causes = [cause]

    @staticmethod
    def parse_args(*args):
        causes = []
        real_args = []
        for arg in args:
            if arg.__class__ is InvalidNumber:
                causes.extend(arg.causes)
                real_args.append(arg.value)
            else:
                real_args.append(arg)
        return (real_args, causes)

    def _cmp(self, op, other):
        args, causes = InvalidNumber.parse_args(self, other)
        try:
            return op(*args)
        except TypeError:
            return False

    def _op(self, op, *args):
        args, causes = InvalidNumber.parse_args(*args)
        try:
            return InvalidNumber(op(*args), causes)
        except (TypeError, ArithmeticError):
            return InvalidNumber(self.value, causes)

    def __eq__(self, other):
        return self._cmp(operator.eq, other)

    def __lt__(self, other):
        return self._cmp(operator.lt, other)

    def __gt__(self, other):
        return self._cmp(operator.gt, other)

    def __le__(self, other):
        return self._cmp(operator.le, other)

    def __ge__(self, other):
        return self._cmp(operator.ge, other)

    def _error(self, msg):
        causes = list(filter(None, self.causes))
        if causes:
            msg += '\nThe InvalidNumber was generated by:\n\t'
            msg += '\n\t'.join(causes)
        raise InvalidValueError(msg)

    def __str__(self):
        return f'InvalidNumber({self.value!r})'

    def __repr__(self):
        self._error(f'Cannot emit {str(self)} in compiled representation')

    def __format__(self, format_spec):
        self._error(f'Cannot emit {str(self)} in compiled representation')

    def __float__(self):
        self._error(f'Cannot convert {str(self)} to float')

    def __neg__(self):
        return self._op(operator.neg, self)

    def __abs__(self):
        return self._op(operator.abs, self)

    def __add__(self, other):
        return self._op(operator.add, self, other)

    def __sub__(self, other):
        return self._op(operator.sub, self, other)

    def __mul__(self, other):
        return self._op(operator.mul, self, other)

    def __truediv__(self, other):
        return self._op(operator.truediv, self, other)

    def __pow__(self, other):
        return self._op(operator.pow, self, other)

    def __radd__(self, other):
        return self._op(operator.add, other, self)

    def __rsub__(self, other):
        return self._op(operator.sub, other, self)

    def __rmul__(self, other):
        return self._op(operator.mul, other, self)

    def __rtruediv__(self, other):
        return self._op(operator.truediv, other, self)

    def __rpow__(self, other):
        return self._op(operator.pow, other, self)