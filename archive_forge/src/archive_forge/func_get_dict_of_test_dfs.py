import math
import string
from datetime import datetime, timedelta
from functools import lru_cache
from itertools import cycle
import numpy as np
import pandas as pd
from .utils import find_package_file
def get_dict_of_test_dfs(N=100, M=100, polars=False):
    NM_values = np.reshape(np.linspace(start=0.0, stop=1.0, num=N * M), (N, M))
    test_dfs = {'empty': pd.DataFrame(dtype=float), 'no_rows': pd.DataFrame(dtype=float, columns=['a']), 'no_columns': pd.DataFrame(dtype=float, index=['a']), 'no_rows_one_column': pd.DataFrame([1.0], index=['a'], columns=['a']).iloc[:0], 'no_columns_one_row': pd.DataFrame([1.0], index=['a'], columns=['a']).iloc[:, :0], 'bool': pd.DataFrame([[True, True, False, False], [True, False, True, False]], columns=list('abcd')), 'nullable_boolean': pd.DataFrame([[True, True, False, None], [True, False, None, False], [None, False, True, False]], columns=list('abcd'), dtype='bool' if PANDAS_VERSION_MAJOR == 0 else 'boolean'), 'int': pd.DataFrame([[-1, 2, -3, 4, -5], [6, -7, 8, -9, 10]], columns=list('abcde')), 'nullable_int': pd.DataFrame([[-1, 2, -3], [4, -5, 6], [None, 7, None]], columns=list('abc'), dtype='Int64'), 'float': pd.DataFrame({'int': [0.0, 1], 'inf': [np.inf, -np.inf], 'nan': [np.NaN, -np.NaN], 'math': [math.pi, math.e]}), 'str': pd.DataFrame({'text_column': ['some', 'text'], 'very_long_text_column': ['a ' + 'very ' * 12 + 'long text'] * 2}), 'time': pd.DataFrame({'datetime': [datetime(2000, 1, 1), datetime(2001, 1, 1), pd.NaT], 'timestamp': [pd.NaT, datetime(2000, 1, 1, 18, 55, 33), datetime(2001, 1, 1, 18, 55, 55, 456654, tzinfo=None if pytz is None else pytz.timezone('US/Eastern'))], 'timedelta': [timedelta(days=2), timedelta(seconds=50), pd.NaT - datetime(2000, 1, 1)]}), 'date_range': pd.DataFrame({'timestamps': pd.date_range('now', periods=5, freq='s')}), 'ordered_categories': pd.DataFrame({'int': np.arange(4)}, index=pd.CategoricalIndex(['first', 'second', 'third', 'fourth'], categories=['first', 'second', 'third', 'fourth'], ordered=True, name='categorical_index')), 'ordered_categories_in_multiindex': pd.DataFrame({'int': np.arange(4), 'integer_index': np.arange(4)}, index=pd.CategoricalIndex(['first', 'second', 'third', 'fourth'], categories=['first', 'second', 'third', 'fourth'], ordered=True, name='categorical_index')).set_index('integer_index', append=True), 'object': pd.DataFrame({'dict': [{'a': 1}, {'b': 2, 'c': 3}], 'list': [['a'], [1, 2]]}), 'multiindex': pd.DataFrame(np.arange(16).reshape((4, 4)), columns=pd.MultiIndex.from_product((['A', 'B'], [1, 2])), index=pd.MultiIndex.from_product((['C', 'D'], [3, 4]))), 'countries': get_countries(), 'capital': get_countries().set_index(['region', 'country'])[['capital']], 'complex_index': get_df_complex_index(), 'int_float_str': pd.DataFrame({'int': range(N), 'float': np.linspace(5.0, 0.0, N), 'str': [letter for letter, _ in zip(cycle(string.ascii_lowercase), range(N))]}), 'wide': pd.DataFrame(NM_values, index=['row_{}'.format(i) for i in range(N)], columns=['column_{}'.format(j) for j in range(M)]), 'long_column_names': pd.DataFrame({'short name': [0] * 5, 'very ' * 5 + 'long name': [0] * 5, 'very ' * 10 + 'long name': [1] * 5, 'very ' * 20 + 'long name': [2] * 5, 'nospacein' + 'very' * 50 + 'longname': [3] * 5, 'nospacein' + 'very' * 100 + 'longname': [3] * 5}), 'sorted_index': pd.DataFrame({'i': [0, 1, 2], 'x': [0.0, 1.0, 2.0], 'y': [0.0, 0.1, 0.2]}).set_index(['i']), 'reverse_sorted_index': pd.DataFrame({'i': [2, 1, 0], 'x': [0.0, 1.0, 2.0], 'y': [0.0, 0.1, 0.2]}).set_index(['i']), 'sorted_multiindex': pd.DataFrame({'i': [0, 1, 2], 'j': [3, 4, 5], 'x': [0.0, 1.0, 2.0], 'y': [0.0, 0.1, 0.2]}).set_index(['i', 'j']), 'unsorted_index': pd.DataFrame({'i': [0, 2, 1], 'x': [0.0, 1.0, 2.0], 'y': [0.0, 0.1, 0.2]}).set_index(['i']), 'duplicated_columns': pd.DataFrame(np.arange(4, 8).reshape((2, 2)), columns=pd.Index(['A', 'A']), index=pd.MultiIndex.from_arrays(np.arange(4).reshape((2, 2)), names=['A', 'A'])), 'named_column_index': pd.DataFrame({'a': [1]}).rename_axis('columns', axis=1), 'big_integers': pd.DataFrame({'bigint': [1234567890123456789, 2345678901234567890, 3456789012345678901], 'expected': ['1234567890123456789', '2345678901234567890', '3456789012345678901']})}
    if polars:
        import polars as pl
        import pyarrow as pa
        polars_dfs = {}
        for key in test_dfs:
            try:
                polars_dfs[key] = pl.from_pandas(test_dfs[key])
            except (pa.ArrowInvalid, ValueError):
                pass
        return polars_dfs
    return test_dfs