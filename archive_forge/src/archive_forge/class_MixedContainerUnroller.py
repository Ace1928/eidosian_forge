from collections import defaultdict, namedtuple
from contextlib import contextmanager
from copy import deepcopy, copy
import warnings
from numba.core.compiler_machinery import (FunctionPass, AnalysisPass,
from numba.core import (errors, types, ir, bytecode, postproc, rewrites, config,
from numba.misc.special import literal_unroll
from numba.core.analysis import (dead_branch_prune, rewrite_semantic_constants,
from numba.core.ir_utils import (guard, resolve_func_from_module, simplify_CFG,
from numba.core.ssa import reconstruct_ssa
from numba.core import interpreter
@register_pass(mutates_CFG=True, analysis_only=False)
class MixedContainerUnroller(FunctionPass):
    _name = 'mixed_container_unroller'
    _DEBUG = False
    _accepted_types = (types.BaseTuple, types.LiteralList)

    def __init__(self):
        FunctionPass.__init__(self)

    def analyse_tuple(self, tup):
        """
        Returns a map of type->list(indexes) for a typed tuple
        """
        d = defaultdict(list)
        for i, ty in enumerate(tup):
            d[ty].append(i)
        return d

    def add_offset_to_labels_w_ignore(self, blocks, offset, ignore=None):
        """add an offset to all block labels and jump/branch targets
        don't add an offset to anything in the ignore list
        """
        if ignore is None:
            ignore = set()
        new_blocks = {}
        for l, b in blocks.items():
            term = None
            if b.body:
                term = b.body[-1]
            if isinstance(term, ir.Jump):
                if term.target not in ignore:
                    b.body[-1] = ir.Jump(term.target + offset, term.loc)
            if isinstance(term, ir.Branch):
                if term.truebr not in ignore:
                    new_true = term.truebr + offset
                else:
                    new_true = term.truebr
                if term.falsebr not in ignore:
                    new_false = term.falsebr + offset
                else:
                    new_false = term.falsebr
                b.body[-1] = ir.Branch(term.cond, new_true, new_false, term.loc)
            new_blocks[l + offset] = b
        return new_blocks

    def inject_loop_body(self, switch_ir, loop_ir, caller_max_label, dont_replace, switch_data):
        """
        Injects the "loop body" held in `loop_ir` into `switch_ir` where ever
        there is a statement of the form `SENTINEL.<int> = RHS`. It also:
        * Finds and then deliberately does not relabel non-local jumps so as to
          make the switch table suitable for injection into the IR from which
          the loop body was derived.
        * Looks for `typed_getitem` and wires them up to loop body version
          specific variables or, if possible, directly writes in their constant
          value at their use site.

        Args:
        - switch_ir, the switch table with SENTINELS as generated by
          self.gen_switch
        - loop_ir, the IR of the loop blocks (derived from the original func_ir)
        - caller_max_label, the maximum label in the func_ir caller
        - dont_replace, variables that should not be renamed (to handle
          references to variables that are incoming at the loop head/escaping at
          the loop exit.
        - switch_data, the switch table data used to generated the switch_ir,
          can be generated by self.analyse_tuple.

        Returns:
        - A type specific switch table with each case containing a versioned
          loop body suitable for injection as a replacement for the loop_ir.
        """
        switch_ir.blocks = self.add_offset_to_labels_w_ignore(switch_ir.blocks, caller_max_label + 1)
        sentinel_exits = set()
        sentinel_blocks = []
        for lbl, blk in switch_ir.blocks.items():
            for i, stmt in enumerate(blk.body):
                if isinstance(stmt, ir.Assign):
                    if 'SENTINEL' in stmt.target.name:
                        sentinel_blocks.append(lbl)
                        sentinel_exits.add(blk.body[-1].target)
                        break
        assert len(sentinel_exits) == 1
        switch_ir.blocks.pop(sentinel_exits.pop())
        ignore_set = set()
        local_lbl = [x for x in loop_ir.blocks.keys()]
        for lbl, blk in loop_ir.blocks.items():
            for i, stmt in enumerate(blk.body):
                if isinstance(stmt, ir.Jump):
                    if stmt.target not in local_lbl:
                        ignore_set.add(stmt.target)
                if isinstance(stmt, ir.Branch):
                    if stmt.truebr not in local_lbl:
                        ignore_set.add(stmt.truebr)
                    if stmt.falsebr not in local_lbl:
                        ignore_set.add(stmt.falsebr)
        assert len(sentinel_blocks) == len(switch_data)
        for lbl, branch_ty in zip(sentinel_blocks, switch_data.keys()):
            loop_blocks = deepcopy(loop_ir.blocks)
            max_label = max(switch_ir.blocks.keys())
            loop_blocks = self.add_offset_to_labels_w_ignore(loop_blocks, max_label + 1, ignore_set)
            loop_start_lbl = min(loop_blocks.keys())
            for blk in loop_blocks.values():
                new_body = []
                for stmt in blk.body:
                    if isinstance(stmt, ir.Assign):
                        if isinstance(stmt.value, ir.Expr) and stmt.value.op == 'typed_getitem':
                            if isinstance(branch_ty, types.Literal):
                                scope = switch_ir.blocks[lbl].scope
                                new_const_name = scope.redefine('branch_const', stmt.loc).name
                                new_const_var = ir.Var(blk.scope, new_const_name, stmt.loc)
                                new_const_val = ir.Const(branch_ty.literal_value, stmt.loc)
                                const_assign = ir.Assign(new_const_val, new_const_var, stmt.loc)
                                new_assign = ir.Assign(new_const_var, stmt.target, stmt.loc)
                                new_body.append(const_assign)
                                new_body.append(new_assign)
                                dont_replace.append(new_const_name)
                            else:
                                orig = stmt.value
                                new_typed_getitem = ir.Expr.typed_getitem(value=orig.value, dtype=branch_ty, index=orig.index, loc=orig.loc)
                                new_assign = ir.Assign(new_typed_getitem, stmt.target, stmt.loc)
                                new_body.append(new_assign)
                        else:
                            new_body.append(stmt)
                    else:
                        new_body.append(stmt)
                blk.body = new_body
            var_table = get_name_var_table(loop_blocks)
            drop_keys = []
            for k, v in var_table.items():
                if v.name in dont_replace:
                    drop_keys.append(k)
            for k in drop_keys:
                var_table.pop(k)
            new_var_dict = {}
            for name, var in var_table.items():
                scope = switch_ir.blocks[lbl].scope
                try:
                    scope.get_exact(name)
                except errors.NotDefinedError:
                    scope.define(name, var.loc)
                new_var_dict[name] = scope.redefine(name, var.loc).name
            replace_var_names(loop_blocks, new_var_dict)
            switch_ir.blocks[lbl] = deepcopy(loop_blocks[loop_start_lbl])
            remaining_keys = [y for y in loop_blocks.keys()]
            remaining_keys.remove(loop_start_lbl)
            for k in remaining_keys:
                switch_ir.blocks[k] = deepcopy(loop_blocks[k])
        if self._DEBUG:
            print('-' * 80 + 'EXIT STUFFER')
            switch_ir.dump()
            print('-' * 80)
        return switch_ir

    def gen_switch(self, data, index):
        """
        Generates a function with a switch table like
        def foo():
            if PLACEHOLDER_INDEX in (<integers>):
                SENTINEL = None
            elif PLACEHOLDER_INDEX in (<integers>):
                SENTINEL = None
            ...
            else:
                raise RuntimeError

        The data is a map of (type : indexes) for example:
        (int64, int64, float64)
        might give:
        {int64: [0, 1], float64: [2]}

        The index is the index variable for the driving range loop over the
        mixed tuple.
        """
        elif_tplt = '\n\telif PLACEHOLDER_INDEX in (%s,):\n\t\tSENTINEL = None'
        b = 'def foo():\n\tif PLACEHOLDER_INDEX in (%s,):\n\t\tSENTINEL = None\n%s\n\telse:\n\t\traise RuntimeError("Unreachable")\n\tpy310_defeat1 = 1\n\tpy310_defeat2 = 2\n\tpy310_defeat3 = 3\n\tpy310_defeat4 = 4\n\t'
        keys = [k for k in data.keys()]
        elifs = []
        for i in range(1, len(keys)):
            elifs.append(elif_tplt % ','.join(map(str, data[keys[i]])))
        src = b % (','.join(map(str, data[keys[0]])), ''.join(elifs))
        wstr = src
        l = {}
        exec(wstr, {}, l)
        bfunc = l['foo']
        branches = compile_to_numba_ir(bfunc, {})
        for lbl, blk in branches.blocks.items():
            for stmt in blk.body:
                if isinstance(stmt, ir.Assign):
                    if isinstance(stmt.value, ir.Global):
                        if stmt.value.name == 'PLACEHOLDER_INDEX':
                            stmt.value = index
        return branches

    def apply_transform(self, state):
        func_ir = state.func_ir
        cfg = compute_cfg_from_blocks(func_ir.blocks)
        loops = cfg.loops()
        unroll_info = namedtuple('unroll_info', ['loop', 'call', 'arg', 'getitem'])

        def get_call_args(init_arg, want):
            some_call = get_definition(func_ir, init_arg)
            if not isinstance(some_call, ir.Expr):
                raise GuardException
            if not some_call.op == 'call':
                raise GuardException
            the_global = get_definition(func_ir, some_call.func)
            if not isinstance(the_global, ir.Global):
                raise GuardException
            if the_global.value is not want:
                raise GuardException
            return some_call

        def find_unroll_loops(loops):
            """This finds loops which are compliant with the form:
            for i in range(len(literal_unroll(<something>>)))"""
            unroll_loops = {}
            for header_lbl, loop in loops.items():
                iternexts = [_ for _ in func_ir.blocks[loop.header].find_exprs('iternext')]
                if len(iternexts) != 1:
                    continue
                for iternext in iternexts:
                    phi = guard(get_definition, func_ir, iternext.value)
                    if phi is None:
                        continue
                    range_call = guard(get_call_args, phi.value, range)
                    if range_call is None:
                        continue
                    range_arg = range_call.args[0]
                    len_call = guard(get_call_args, range_arg, len)
                    if len_call is None:
                        continue
                    len_arg = len_call.args[0]
                    literal_unroll_call = guard(get_definition, func_ir, len_arg)
                    if literal_unroll_call is None:
                        continue
                    if not isinstance(literal_unroll_call, ir.Expr):
                        continue
                    if literal_unroll_call.op != 'call':
                        continue
                    literal_func = getattr(literal_unroll_call, 'func', None)
                    if not literal_func:
                        continue
                    call_func = guard(get_definition, func_ir, literal_unroll_call.func)
                    if call_func is None:
                        continue
                    call_func_value = call_func.value
                    if call_func_value is literal_unroll:
                        assert len(literal_unroll_call.args) == 1
                        unroll_loops[loop] = literal_unroll_call
            return unroll_loops

        def ensure_no_nested_unroll(unroll_loops):
            for test_loop in unroll_loops:
                for ref_loop in unroll_loops:
                    if test_loop == ref_loop:
                        continue
                    if test_loop.header in ref_loop.body:
                        msg = 'Nesting of literal_unroll is unsupported'
                        loc = func_ir.blocks[test_loop.header].loc
                        raise errors.UnsupportedError(msg, loc)

        def collect_literal_unroll_info(literal_unroll_loops):
            """Finds the loops induced by `literal_unroll`, returns a list of
            unroll_info namedtuples for use in the transform pass.
            """
            literal_unroll_info = []
            for loop, literal_unroll_call in literal_unroll_loops.items():
                arg = literal_unroll_call.args[0]
                typemap = state.typemap
                resolved_arg = guard(get_definition, func_ir, arg, lhs_only=True)
                ty = typemap[resolved_arg.name]
                assert isinstance(ty, self._accepted_types)
                tuple_getitem = None
                for lbli in loop.body:
                    blk = func_ir.blocks[lbli]
                    for stmt in blk.body:
                        if isinstance(stmt, ir.Assign):
                            if isinstance(stmt.value, ir.Expr) and stmt.value.op == 'getitem':
                                if stmt.value.value != arg:
                                    dfn = guard(get_definition, func_ir, stmt.value.value)
                                    if dfn is None:
                                        continue
                                    try:
                                        args = getattr(dfn, 'args', False)
                                    except KeyError:
                                        continue
                                    if not args:
                                        continue
                                    if not args[0] == arg:
                                        continue
                                target_ty = state.typemap[arg.name]
                                if not isinstance(target_ty, self._accepted_types):
                                    continue
                                tuple_getitem = stmt
                                break
                    if tuple_getitem:
                        break
                else:
                    continue
                ui = unroll_info(loop, literal_unroll_call, arg, tuple_getitem)
                literal_unroll_info.append(ui)
            return literal_unroll_info
        literal_unroll_loops = find_unroll_loops(loops)
        ensure_no_nested_unroll(literal_unroll_loops)
        literal_unroll_info = collect_literal_unroll_info(literal_unroll_loops)
        if not literal_unroll_info:
            return False
        info = literal_unroll_info[0]
        self.unroll_loop(state, info)
        func_ir.blocks = simplify_CFG(func_ir.blocks)
        post_proc = postproc.PostProcessor(func_ir)
        post_proc.run()
        if self._DEBUG:
            print('-' * 80 + 'END OF PASS, SIMPLIFY DONE')
            func_ir.dump()
        func_ir._definitions = build_definitions(func_ir.blocks)
        return True

    def unroll_loop(self, state, loop_info):
        func_ir = state.func_ir
        getitem_target = loop_info.arg
        target_ty = state.typemap[getitem_target.name]
        assert isinstance(target_ty, self._accepted_types)
        tuple_getitem = []
        for lbl in loop_info.loop.body:
            blk = func_ir.blocks[lbl]
            for stmt in blk.body:
                if isinstance(stmt, ir.Assign):
                    if isinstance(stmt.value, ir.Expr) and stmt.value.op == 'getitem':
                        if stmt.value.value != getitem_target:
                            dfn = func_ir.get_definition(stmt.value.value)
                            try:
                                args = getattr(dfn, 'args', False)
                            except KeyError:
                                continue
                            if not args:
                                continue
                            if not args[0] == getitem_target:
                                continue
                        target_ty = state.typemap[getitem_target.name]
                        if not isinstance(target_ty, self._accepted_types):
                            continue
                        tuple_getitem.append(stmt)
        if not tuple_getitem:
            msg = "Loop unrolling analysis has failed, there's no getitem in loop body that conforms to literal_unroll requirements."
            LOC = func_ir.blocks[loop_info.loop.header].loc
            raise errors.CompilerError(msg, LOC)
        switch_data = self.analyse_tuple(target_ty)
        index = func_ir._definitions[tuple_getitem[0].value.index.name][0]
        branches = self.gen_switch(switch_data, index)
        for item in tuple_getitem:
            old = item.value
            new = ir.Expr.typed_getitem(old.value, types.void, old.index, old.loc)
            item.value = new
        this_loop = loop_info.loop
        this_loop_body = this_loop.body - set([this_loop.header])
        loop_blocks = {x: func_ir.blocks[x] for x in this_loop_body}
        new_ir = func_ir.derive(loop_blocks)
        usedefs = compute_use_defs(func_ir.blocks)
        idx = this_loop.header
        keep = set()
        keep |= usedefs.usemap[idx] | usedefs.defmap[idx]
        keep |= func_ir.variable_lifetime.livemap[idx]
        dont_replace = [x for x in keep]
        unrolled_body = self.inject_loop_body(branches, new_ir, max(func_ir.blocks.keys()) + 1, dont_replace, switch_data)
        blks = state.func_ir.blocks
        the_scope = next(iter(blks.values())).scope
        orig_lbl = tuple(this_loop_body)
        replace, *delete = orig_lbl
        unroll, header_block = (unrolled_body, this_loop.header)
        unroll_lbl = [x for x in sorted(unroll.blocks.keys())]
        blks[replace] = transfer_scope(unroll.blocks[unroll_lbl[0]], the_scope)
        [blks.pop(d) for d in delete]
        for k in unroll_lbl[1:]:
            blks[k] = transfer_scope(unroll.blocks[k], the_scope)
        blks[header_block].body[-1].truebr = replace

    def run_pass(self, state):
        mutated = False
        func_ir = state.func_ir
        func_ir.blocks = simplify_CFG(func_ir.blocks)
        if self._DEBUG:
            print('-' * 80 + 'PASS ENTRY')
            func_ir.dump()
            print('-' * 80)
        while True:
            stat = self.apply_transform(state)
            mutated |= stat
            if not stat:
                break
        state.typemap = {}
        state.calltypes = None
        return mutated