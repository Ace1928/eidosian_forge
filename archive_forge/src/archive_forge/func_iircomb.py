from math import pi
import math
import cupy
from cupyx.scipy.signal._iir_filter_conversions import (
from cupyx.scipy.signal._iir_filter_conversions import (
def iircomb(w0, Q, ftype='notch', fs=2.0, *, pass_zero=False):
    """
    Design IIR notching or peaking digital comb filter.

    A notching comb filter consists of regularly-spaced band-stop filters with
    a narrow bandwidth (high quality factor). Each rejects a narrow frequency
    band and leaves the rest of the spectrum little changed.

    A peaking comb filter consists of regularly-spaced band-pass filters with
    a narrow bandwidth (high quality factor). Each rejects components outside
    a narrow frequency band.

    Parameters
    ----------
    w0 : float
        The fundamental frequency of the comb filter (the spacing between its
        peaks). This must evenly divide the sampling frequency. If `fs` is
        specified, this is in the same units as `fs`. By default, it is
        a normalized scalar that must satisfy  ``0 < w0 < 1``, with
        ``w0 = 1`` corresponding to half of the sampling frequency.
    Q : float
        Quality factor. Dimensionless parameter that characterizes
        notch filter -3 dB bandwidth ``bw`` relative to its center
        frequency, ``Q = w0/bw``.
    ftype : {'notch', 'peak'}
        The type of comb filter generated by the function. If 'notch', then
        the Q factor applies to the notches. If 'peak', then the Q factor
        applies to the peaks.  Default is 'notch'.
    fs : float, optional
        The sampling frequency of the signal. Default is 2.0.
    pass_zero : bool, optional
        If False (default), the notches (nulls) of the filter are centered on
        frequencies [0, w0, 2*w0, ...], and the peaks are centered on the
        midpoints [w0/2, 3*w0/2, 5*w0/2, ...].  If True, the peaks are centered
        on [0, w0, 2*w0, ...] (passing zero frequency) and vice versa.

    Returns
    -------
    b, a : ndarray, ndarray
        Numerator (``b``) and denominator (``a``) polynomials
        of the IIR filter.

    Raises
    ------
    ValueError
        If `w0` is less than or equal to 0 or greater than or equal to
        ``fs/2``, if `fs` is not divisible by `w0`, if `ftype`
        is not 'notch' or 'peak'

    See Also
    --------
    scipy.signal.iircomb
    iirnotch
    iirpeak

    Notes
    -----
    The TF implementation of the
    comb filter is numerically stable even at higher orders due to the
    use of a single repeated pole, which won't suffer from precision loss.

    References
    ----------
    Sophocles J. Orfanidis, "Introduction To Signal Processing",
         Prentice-Hall, 1996, ch. 11, "Digital Filter Design"
    """
    w0 = float(w0)
    Q = float(Q)
    fs = float(fs)
    ftype = ftype.lower()
    if not 0 < w0 < fs / 2:
        raise ValueError('w0 must be between 0 and {} (nyquist), but given {}.'.format(fs / 2, w0))
    if ftype not in ('notch', 'peak'):
        raise ValueError('ftype must be either notch or peak.')
    N = round(fs / w0)
    if abs(w0 - fs / N) / fs > 1e-14:
        raise ValueError('fs must be divisible by w0.')
    w0 = 2 * pi * w0 / fs
    w_delta = w0 / Q
    if ftype == 'notch':
        G0, G = (1, 0)
    elif ftype == 'peak':
        G0, G = (0, 1)
    GB = 1 / math.sqrt(2)
    beta = math.sqrt((GB ** 2 - G0 ** 2) / (G ** 2 - GB ** 2)) * math.tan(N * w_delta / 4)
    ax = (1 - beta) / (1 + beta)
    bx = (G0 + G * beta) / (1 + beta)
    cx = (G0 - G * beta) / (1 + beta)
    negative_coef = ftype == 'peak' and pass_zero or (ftype == 'notch' and (not pass_zero))
    b = cupy.zeros(N + 1)
    b[0] = bx
    if negative_coef:
        b[-1] = -cx
    else:
        b[-1] = +cx
    a = cupy.zeros(N + 1)
    a[0] = 1
    if negative_coef:
        a[-1] = -ax
    else:
        a[-1] = +ax
    return (b, a)