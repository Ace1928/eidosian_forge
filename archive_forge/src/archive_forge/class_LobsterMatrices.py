from __future__ import annotations
import collections
import fnmatch
import os
import re
import warnings
from collections import defaultdict
from typing import TYPE_CHECKING, Any
import numpy as np
from monty.io import zopen
from monty.json import MSONable
from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.bandstructure import LobsterBandStructureSymmLine
from pymatgen.electronic_structure.core import Orbital, Spin
from pymatgen.electronic_structure.dos import Dos, LobsterCompleteDos
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.io.vasp.outputs import Vasprun, VolumetricData
from pymatgen.util.due import Doi, due
class LobsterMatrices:
    """
    Class to read Matrices file generated by LOBSTER (e.g. hamiltonMatrices.lobster).

    Attributes:
        for filename == "hamiltonMatrices.lobster"
        onsite_energies (list[np.arrays]): List real part of onsite energies from the matrices each k-point.
        average_onsite_energies (dict): dict with average onsite elements energies for all k-points with keys as
                                        basis used in the LOBSTER computation (uses only real part of matrix).
        hamilton_matrices (dict[np.arrays]) : dict with the complex hamilton matrix
                                        at each k-point with k-point and spin as keys

        for filename == "coefficientMatrices.lobster"

        onsite_coefficients (list[np.arrays]): List real part of onsite coefficients from the matrices each k-point.
        average_onsite_coefficient (dict): dict with average onsite elements coefficients for all k-points with keys as
                                        basis used in the LOBSTER computation (uses only real part of matrix).
        coefficient_matrices (dict[np.arrays]) : dict with the coefficients matrix
                                        at each k-point with k-point and spin as keys

        for filename == "transferMatrices.lobster"

        onsite_transfer (list[np.arrays]): List real part of onsite transfer coefficients from the matrices at each
                                        k-point.
        average_onsite_transfer (dict): dict with average onsite elements transfer coefficients for all k-points with
                                        keys as basis used in the LOBSTER computation (uses only real part of matrix).
        transfer_matrices (dict[np.arrays]) : dict with the coefficients matrix at
                                        each k-point with k-point and spin as keys

        for filename == "overlapMatrices.lobster"

        onsite_overlaps (list[np.arrays]): List real part of onsite overlaps from the matrices each k-point.
        average_onsite_overlaps (dict): dict with average onsite elements overlaps for all k-points with keys as
                                        basis used in the LOBSTER computation (uses only real part of matrix).
        overlap_matrices (dict[np.arrays]) : dict with the overlap matrix at
                                        each k-point with k-point as keys
    """

    def __init__(self, e_fermi=None, filename: str='hamiltonMatrices.lobster'):
        """
        Args:
            filename: filename for the hamiltonMatrices file, typically "hamiltonMatrices.lobster".
            e_fermi: fermi level in eV for the structure only
            relevant if input file contains hamilton matrices data
        """
        self._filename = filename
        with zopen(self._filename, mode='rt') as file:
            file_data = file.readlines()
        if len(file_data) == 0:
            raise OSError('Please check provided input file, it seems to be empty')
        pattern_coeff_hamil_trans = '(\\d+)\\s+kpoint\\s+(\\d+)'
        pattern_overlap = 'kpoint\\s+(\\d+)'
        if 'hamilton' in self._filename:
            if e_fermi is None:
                raise ValueError('Please provide the fermi energy in eV ')
            self.onsite_energies, self.average_onsite_energies, self.hamilton_matrices = self._parse_matrix(file_data=file_data, pattern=pattern_coeff_hamil_trans, e_fermi=e_fermi)
        elif 'coefficient' in self._filename:
            self.onsite_coefficients, self.average_onsite_coefficient, self.coefficient_matrices = self._parse_matrix(file_data=file_data, pattern=pattern_coeff_hamil_trans, e_fermi=0)
        elif 'transfer' in self._filename:
            self.onsite_transfer, self.average_onsite_transfer, self.transfer_matrices = self._parse_matrix(file_data=file_data, pattern=pattern_coeff_hamil_trans, e_fermi=0)
        elif 'overlap' in self._filename:
            self.onsite_overlaps, self.average_onsite_overlaps, self.overlap_matrices = self._parse_matrix(file_data=file_data, pattern=pattern_overlap, e_fermi=0)

    @staticmethod
    def _parse_matrix(file_data, pattern, e_fermi):
        complex_matrices = {}
        matrix_diagonal_values = []
        start_inxs_real = []
        end_inxs_real = []
        start_inxs_imag = []
        end_inxs_imag = []
        for idx, line in enumerate(file_data):
            line = line.strip()
            if 'Real parts' in line:
                start_inxs_real += [idx + 1]
                if idx == 1:
                    pass
                else:
                    end_inxs_imag += [idx - 1]
                matches = re.search(pattern, file_data[idx - 1])
                if matches and len(matches.groups()) == 2:
                    k_point = matches.group(2)
                    complex_matrices[k_point] = {}
            if 'Imag parts' in line:
                end_inxs_real += [idx - 1]
                start_inxs_imag += [idx + 1]
            if idx == len(file_data) - 1:
                end_inxs_imag += [len(file_data)]
        matrix_real = []
        matrix_imag = []
        for start_inx_real, end_inx_real, start_inx_imag, end_inx_imag in zip(start_inxs_real, end_inxs_real, start_inxs_imag, end_inxs_imag):
            matrix_real = file_data[start_inx_real:end_inx_real]
            matrix_imag = file_data[start_inx_imag:end_inx_imag]
            matrix_array_real = np.array([line.split()[1:] for line in matrix_real[1:]], dtype=float)
            matrix_array_imag = np.array([line.split()[1:] for line in matrix_imag[1:]], dtype=float)
            comp_matrix = matrix_array_real + 1j * matrix_array_imag
            matches = re.search(pattern, file_data[start_inx_real - 2])
            if matches and len(matches.groups()) == 2:
                spin = Spin.up if matches.group(1) == '1' else Spin.down
                k_point = matches.group(2)
                complex_matrices[k_point].update({spin: comp_matrix})
            elif matches and len(matches.groups()) == 1:
                k_point = matches.group(1)
                complex_matrices.update({k_point: comp_matrix})
            matrix_diagonal_values += [comp_matrix.real.diagonal() - e_fermi]
        elements_basis_functions = [line.split()[:1][0] for line in matrix_real if line.split()[:1][0] != 'basisfunction']
        average_matrix_diagonal_values = np.array(matrix_diagonal_values, dtype=float).mean(axis=0)
        average_average_matrix_diag_dict = dict(zip(elements_basis_functions, average_matrix_diagonal_values))
        return (matrix_diagonal_values, average_average_matrix_diag_dict, complex_matrices)