from __future__ import absolute_import, print_function
import os
import re
import sys
import io
from . import Errors
from .StringEncoding import EncodedString
from .Scanning import PyrexScanner, FileSourceDescriptor
from .Errors import PyrexError, CompileError, error, warning
from .Symtab import ModuleScope
from .. import Utils
from . import Options
from .Options import CompilationOptions, default_options
from .CmdLine import parse_command_line
from .Lexicon import (unicode_start_ch_any, unicode_continuation_ch_any,
def run_pipeline(source, options, full_module_name=None, context=None):
    from . import Pipeline
    if sys.version_info[0] == 2:
        source = Utils.decode_filename(source)
        if full_module_name:
            full_module_name = Utils.decode_filename(full_module_name)
    source_ext = os.path.splitext(source)[1]
    options.configure_language_defaults(source_ext[1:])
    if context is None:
        context = Context.from_options(options)
    cwd = os.getcwd()
    abs_path = os.path.abspath(source)
    full_module_name = full_module_name or context.extract_module_name(source, options)
    full_module_name = EncodedString(full_module_name)
    Utils.raise_error_if_module_name_forbidden(full_module_name)
    if options.relative_path_in_code_position_comments:
        rel_path = full_module_name.replace('.', os.sep) + source_ext
        if not abs_path.endswith(rel_path):
            rel_path = source
    else:
        rel_path = abs_path
    source_desc = FileSourceDescriptor(abs_path, rel_path)
    source = CompilationSource(source_desc, full_module_name, cwd)
    result = create_default_resultobj(source, options)
    if options.annotate is None:
        html_filename = os.path.splitext(result.c_file)[0] + '.html'
        if os.path.exists(html_filename):
            with io.open(html_filename, 'r', encoding='UTF-8') as html_file:
                if u'<!-- Generated by Cython' in html_file.read(100):
                    options.annotate = True
    if source_ext.lower() == '.py' or not source_ext:
        pipeline = Pipeline.create_py_pipeline(context, options, result)
    else:
        pipeline = Pipeline.create_pyx_pipeline(context, options, result)
    context.setup_errors(options, result)
    if '.' in full_module_name and '.' in os.path.splitext(os.path.basename(abs_path))[0]:
        warning((source_desc, 1, 0), "Dotted filenames ('%s') are deprecated. Please use the normal Python package directory layout." % os.path.basename(abs_path), level=1)
    err, enddata = Pipeline.run_pipeline(pipeline, source)
    context.teardown_errors(err, options, result)
    if err is None and options.depfile:
        from ..Build.Dependencies import create_dependency_tree
        dependencies = create_dependency_tree(context).all_dependencies(result.main_source_file)
        Utils.write_depfile(result.c_file, result.main_source_file, dependencies)
    return result