from collections import OrderedDict
from textwrap import dedent
import operator
from . import ExprNodes
from . import Nodes
from . import PyrexTypes
from . import Builtin
from . import Naming
from .Errors import error, warning
from .Code import UtilityCode, TempitaUtilityCode, PyxCodeWriter
from .Visitor import VisitorTransform
from .StringEncoding import EncodedString
from .TreeFragment import TreeFragment
from .ParseTreeTransforms import NormalizeTree, SkipDeclarations
from .Options import copy_inherited_directives
def generate_init_code(code, init, node, fields, kw_only):
    """
    Notes on CPython generated "__init__":
    * Implemented in `_init_fn`.
    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as
      the default argument for fields that need constructing with a factory
      function is copied from the CPython implementation. (`None` isn't
      suitable because it could also be a value for the user to pass.)
      There's no real reason why it needs importing from the dataclasses module
      though - it could equally be a value generated by Cython when the module loads.
    * seen_default and the associated error message are copied directly from Python
    * Call to user-defined __post_init__ function (if it exists) is copied from
      CPython.

    Cython behaviour deviates a little here (to be decided if this is right...)
    Because the class variable from the assignment does not exist Cython fields will
    return None (or whatever their type default is) if not initialized while Python
    dataclasses will fall back to looking up the class variable.
    """
    if not init or node.scope.lookup_here('__init__'):
        return
    selfname = '__dataclass_self__' if 'self' in fields else 'self'
    args = [selfname]
    if kw_only:
        args.append('*')
    function_start_point = code.insertion_point()
    code = code.insertion_point()
    dataclass_module = make_dataclasses_module_callnode(node.pos)
    has_default_factory = ExprNodes.AttributeNode(node.pos, obj=dataclass_module, attribute=EncodedString('_HAS_DEFAULT_FACTORY'))
    default_factory_placeholder = code.new_placeholder(fields, has_default_factory)
    seen_default = False
    for name, field in fields.items():
        entry = node.scope.lookup(name)
        if entry.annotation:
            annotation = u': %s' % entry.annotation.string.value
        else:
            annotation = u''
        assignment = u''
        if field.default is not MISSING or field.default_factory is not MISSING:
            seen_default = True
            if field.default_factory is not MISSING:
                ph_name = default_factory_placeholder
            else:
                ph_name = code.new_placeholder(fields, field.default)
            assignment = u' = %s' % ph_name
        elif seen_default and (not kw_only) and field.init.value:
            error(entry.pos, "non-default argument '%s' follows default argument in dataclass __init__" % name)
            code.reset()
            return
        if field.init.value:
            args.append(u'%s%s%s' % (name, annotation, assignment))
        if field.is_initvar:
            continue
        elif field.default_factory is MISSING:
            if field.init.value:
                code.add_code_line(u'    %s.%s = %s' % (selfname, name, name))
            elif assignment:
                code.add_code_line(u'    %s.%s%s' % (selfname, name, assignment))
        else:
            ph_name = code.new_placeholder(fields, field.default_factory)
            if field.init.value:
                code.add_code_line(u'    %s.%s = %s() if %s is %s else %s' % (selfname, name, ph_name, name, default_factory_placeholder, name))
            else:
                code.add_code_line(u'    %s.%s = %s()' % (selfname, name, ph_name))
    if node.scope.lookup('__post_init__'):
        post_init_vars = ', '.join((name for name, field in fields.items() if field.is_initvar))
        code.add_code_line('    %s.__post_init__(%s)' % (selfname, post_init_vars))
    if code.empty():
        code.add_code_line('    pass')
    args = u', '.join(args)
    function_start_point.add_code_line(u'def __init__(%s):' % args)