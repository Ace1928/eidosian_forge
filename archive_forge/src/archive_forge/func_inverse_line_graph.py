from collections import defaultdict
from functools import partial
from itertools import combinations
import networkx as nx
from networkx.utils import arbitrary_element
from networkx.utils.decorators import not_implemented_for
@not_implemented_for('directed')
@not_implemented_for('multigraph')
@nx._dispatch
def inverse_line_graph(G):
    """Returns the inverse line graph of graph G.

    If H is a graph, and G is the line graph of H, such that G = L(H).
    Then H is the inverse line graph of G.

    Not all graphs are line graphs and these do not have an inverse line graph.
    In these cases this function raises a NetworkXError.

    Parameters
    ----------
    G : graph
        A NetworkX Graph

    Returns
    -------
    H : graph
        The inverse line graph of G.

    Raises
    ------
    NetworkXNotImplemented
        If G is directed or a multigraph

    NetworkXError
        If G is not a line graph

    Notes
    -----
    This is an implementation of the Roussopoulos algorithm[1]_.

    If G consists of multiple components, then the algorithm doesn't work.
    You should invert every component separately:

    >>> K5 = nx.complete_graph(5)
    >>> P4 = nx.Graph([("a", "b"), ("b", "c"), ("c", "d")])
    >>> G = nx.union(K5, P4)
    >>> root_graphs = []
    >>> for comp in nx.connected_components(G):
    ...     root_graphs.append(nx.inverse_line_graph(G.subgraph(comp)))
    >>> len(root_graphs)
    2

    References
    ----------
    .. [1] Roussopoulos, N.D. , "A max {m, n} algorithm for determining the graph H from
       its line graph G", Information Processing Letters 2, (1973), 108--112, ISSN 0020-0190,
       `DOI link <https://doi.org/10.1016/0020-0190(73)90029-X>`_

    """
    if G.number_of_nodes() == 0:
        return nx.empty_graph(1)
    elif G.number_of_nodes() == 1:
        v = arbitrary_element(G)
        a = (v, 0)
        b = (v, 1)
        H = nx.Graph([(a, b)])
        return H
    elif G.number_of_nodes() > 1 and G.number_of_edges() == 0:
        msg = "inverse_line_graph() doesn't work on an edgeless graph. Please use this function on each component separately."
        raise nx.NetworkXError(msg)
    if nx.number_of_selfloops(G) != 0:
        msg = 'A line graph as generated by NetworkX has no selfloops, so G has no inverse line graph. Please remove the selfloops from G and try again.'
        raise nx.NetworkXError(msg)
    starting_cell = _select_starting_cell(G)
    P = _find_partition(G, starting_cell)
    P_count = {u: 0 for u in G.nodes}
    for p in P:
        for u in p:
            P_count[u] += 1
    if max(P_count.values()) > 2:
        msg = 'G is not a line graph (vertex found in more than two partition cells)'
        raise nx.NetworkXError(msg)
    W = tuple(((u,) for u in P_count if P_count[u] == 1))
    H = nx.Graph()
    H.add_nodes_from(P)
    H.add_nodes_from(W)
    for a, b in combinations(H.nodes, 2):
        if any((a_bit in b for a_bit in a)):
            H.add_edge(a, b)
    return H