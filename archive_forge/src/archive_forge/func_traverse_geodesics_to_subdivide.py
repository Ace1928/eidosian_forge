from .moves import one_four_move, two_three_move
from .tracing import GeodesicPiece, GeodesicPieceTracker
from .exceptions import GeodesicStartingPiecesCrossSameFaceError
from . import debug
from ..snap.t3mlite import Mcomplex, Tetrahedron
from typing import Sequence, Dict
def traverse_geodesics_to_subdivide(mcomplex: Mcomplex, all_pieces: Sequence[Sequence[GeodesicPiece]]) -> Sequence[Tetrahedron]:
    """
    The function expects a triangulation and a list of list of geodesic pieces
    where each list was generated by calling trace_geodesic on the same
    triangulation. That is, the pieces of each list form a simple closed curve in
    the manifold that is geodesic except for one point. See trace_geodesic for
    further details on the input. Note that the function corrupts its input
    data.

    The function returns a list of tetrahedra that form a triangulation that is
    isometric to the given triangulation and such that the above simple closed
    curves all embed into the 1-skeleton. The triangulation will have ideal and
    finite vertices (that will be assigned light-like and (unnormalized)
    time-like vectors, respectively by tet.R13_vertices).

    An edge E of the new triangulation is part of one of the above simple
    closed curves if there is a pair of a tetrahedron tet and an edge e in that
    tetrahedron representing E and there is a GeodesicPiece in
    tet.geodesic_pieces with endpoints being the endpoints of e.
    """
    for tet in mcomplex.Tetrahedra:
        tet.geodesic_pieces = []
    for pieces in all_pieces:
        for piece in pieces:
            piece.tet.geodesic_pieces.append(piece)
    trackers = [GeodesicPieceTracker(pieces[0]) for pieces in all_pieces]
    for tracker in trackers:
        debug.check_consistency_segments(debug.flatten_link_list(tracker.geodesic_piece))
    for tracker in trackers:
        last_piece: GeodesicPiece = _traverse_geodesic_to_subdivide(tracker.geodesic_piece, mcomplex.verified)
    return _find_and_index_all_tetrahedra(last_piece.tet)