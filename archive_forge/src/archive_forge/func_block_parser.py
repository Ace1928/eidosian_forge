import atexit
import errno
import os
import pathlib
import re
import sys
import tempfile
import ast
import warnings
import shutil
from io import StringIO
from docutils.parsers.rst import directives
from docutils.parsers.rst import Directive
from sphinx.util import logging
from traitlets.config import Config
from IPython import InteractiveShell
from IPython.core.profiledir import ProfileDir
def block_parser(part, rgxin, rgxout, fmtin, fmtout):
    """
    part is a string of ipython text, comprised of at most one
    input, one output, comments, and blank lines.  The block parser
    parses the text into a list of::

      blocks = [ (TOKEN0, data0), (TOKEN1, data1), ...]

    where TOKEN is one of [COMMENT | INPUT | OUTPUT ] and
    data is, depending on the type of token::

      COMMENT : the comment string

      INPUT: the (DECORATOR, INPUT_LINE, REST) where
         DECORATOR: the input decorator (or None)
         INPUT_LINE: the input as string (possibly multi-line)
         REST : any stdout generated by the input line (not OUTPUT)

      OUTPUT: the output string, possibly multi-line

    """
    block = []
    lines = part.split('\n')
    N = len(lines)
    i = 0
    decorator = None
    while 1:
        if i == N:
            break
        line = lines[i]
        i += 1
        line_stripped = line.strip()
        if line_stripped.startswith('#'):
            block.append((COMMENT, line))
            continue
        if any((line_stripped.startswith('@' + pseudo_decorator) for pseudo_decorator in PSEUDO_DECORATORS)):
            if decorator:
                raise RuntimeError('Applying multiple pseudo-decorators on one line is not supported')
            else:
                decorator = line_stripped
                continue
        matchin = rgxin.match(line)
        if matchin:
            lineno, inputline = (int(matchin.group(1)), matchin.group(2))
            continuation = '   %s:' % ''.join(['.'] * (len(str(lineno)) + 2))
            Nc = len(continuation)
            rest = []
            while i < N:
                nextline = lines[i]
                matchout = rgxout.match(nextline)
                if matchout or nextline.startswith('#'):
                    break
                elif nextline.startswith(continuation):
                    nextline = nextline[Nc:]
                    if nextline and nextline[0] == ' ':
                        nextline = nextline[1:]
                    inputline += '\n' + nextline
                else:
                    rest.append(nextline)
                i += 1
            block.append((INPUT, (decorator, inputline, '\n'.join(rest))))
            continue
        matchout = rgxout.match(line)
        if matchout:
            lineno, output = (int(matchout.group(1)), matchout.group(2))
            if i < N - 1:
                output = '\n'.join([output] + lines[i:])
            block.append((OUTPUT, output))
            break
    return block