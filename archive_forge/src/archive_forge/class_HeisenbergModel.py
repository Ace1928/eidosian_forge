from __future__ import annotations
import copy
import logging
from ast import literal_eval
from typing import TYPE_CHECKING
import numpy as np
import pandas as pd
from monty.json import MSONable, jsanitize
from monty.serialization import dumpfn
from pymatgen.analysis.graphs import StructureGraph
from pymatgen.analysis.local_env import MinimumDistanceNN
from pymatgen.analysis.magnetism import CollinearMagneticStructureAnalyzer, Ordering
from pymatgen.core.structure import Structure
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
class HeisenbergModel(MSONable):
    """
    Store a Heisenberg model fit to low-energy magnetic orderings.
    Intended to be generated by HeisenbergMapper.get_heisenberg_model().
    """

    def __init__(self, formula=None, structures=None, energies=None, cutoff=None, tol=None, sgraphs=None, unique_site_ids=None, wyckoff_ids=None, nn_interactions=None, dists=None, ex_mat=None, ex_params=None, javg=None, igraph=None):
        """
        Args:
            formula (str): Reduced formula of compound.
            structures (list): Structure objects with magmoms.
            energies (list): Energies of each relaxed magnetic structure.
            cutoff (float): Cutoff in Angstrom for nearest neighbor search.
            tol (float): Tolerance (in Angstrom) on nearest neighbor distances being equal.
            sgraphs (list): StructureGraph objects.
            unique_site_ids (dict): Maps each site to its unique numerical
                identifier.
            wyckoff_ids (dict): Maps unique numerical identifier to wyckoff
                position.
            nn_interactions (dict): {i: j} pairs of NN interactions
                between unique sites.
            dists (dict): NN, NNN, and NNNN interaction distances
            ex_mat (DataFrame): Invertible Heisenberg Hamiltonian for each
                graph.
            ex_params (dict): Exchange parameter values (meV/atom).
            javg (float): <J> exchange param (meV/atom).
            igraph (StructureGraph): Exchange interaction graph.
        """
        self.formula = formula
        self.structures = structures
        self.energies = energies
        self.cutoff = cutoff
        self.tol = tol
        self.sgraphs = sgraphs
        self.unique_site_ids = unique_site_ids
        self.wyckoff_ids = wyckoff_ids
        self.nn_interactions = nn_interactions
        self.dists = dists
        self.ex_mat = ex_mat
        self.ex_params = ex_params
        self.javg = javg
        self.igraph = igraph

    def as_dict(self):
        """Because some dicts have tuple keys, some sanitization is required for json compatibility."""
        dct = {}
        dct['@module'] = type(self).__module__
        dct['@class'] = type(self).__name__
        dct['@version'] = __version__
        dct['formula'] = self.formula
        dct['structures'] = [s.as_dict() for s in self.structures]
        dct['energies'] = self.energies
        dct['cutoff'] = self.cutoff
        dct['tol'] = self.tol
        dct['sgraphs'] = [sgraph.as_dict() for sgraph in self.sgraphs]
        dct['dists'] = self.dists
        dct['ex_params'] = self.ex_params
        dct['javg'] = self.javg
        dct['igraph'] = self.igraph.as_dict()
        dct['ex_mat'] = jsanitize(self.ex_mat)
        dct['nn_interactions'] = jsanitize(self.nn_interactions)
        dct['unique_site_ids'] = jsanitize(self.unique_site_ids)
        dct['wyckoff_ids'] = jsanitize(self.wyckoff_ids)
        return dct

    @classmethod
    def from_dict(cls, dct: dict) -> Self:
        """Create a HeisenbergModel from a dict."""
        usids = {}
        wids = {}
        nnis = {}
        for k, v in dct['nn_interactions'].items():
            nn_dict = {}
            for k1, v1 in v.items():
                key = literal_eval(k1)
                nn_dict[key] = v1
            nnis[k] = nn_dict
        for k, v in dct['unique_site_ids'].items():
            key = literal_eval(k)
            if isinstance(key, int):
                usids[key,] = v
            elif isinstance(key, tuple):
                usids[key] = v
        for k, v in dct['wyckoff_ids'].items():
            key = literal_eval(k)
            wids[key] = v
        structures = []
        sgraphs = []
        for v in dct['structures']:
            structures.append(Structure.from_dict(v))
        for v in dct['sgraphs']:
            sgraphs.append(StructureGraph.from_dict(v))
        igraph = StructureGraph.from_dict(dct['igraph'])
        try:
            ex_mat = literal_eval(dct['ex_mat'])
            ex_mat = pd.DataFrame.from_dict(ex_mat)
        except SyntaxError:
            ex_mat = pd.DataFrame(columns=['E', 'E0'])
        return HeisenbergModel(formula=dct['formula'], structures=structures, energies=dct['energies'], cutoff=dct['cutoff'], tol=dct['tol'], sgraphs=sgraphs, unique_site_ids=usids, wyckoff_ids=wids, nn_interactions=nnis, dists=dct['dists'], ex_mat=ex_mat, ex_params=dct['ex_params'], javg=dct['javg'], igraph=igraph)

    def _get_j_exc(self, i, j, dist):
        """
        Convenience method for looking up exchange parameter between two sites.

        Args:
            i (int): index of ith site
            j (int): index of jth site
            dist (float): distance (Angstrom) between sites +- tol

        Returns:
            j_exc (float): Exchange parameter in meV
        """
        for k in self.unique_site_ids:
            if i in k:
                i_index = self.unique_site_ids[k]
            if j in k:
                j_index = self.unique_site_ids[k]
        order = ''
        if abs(dist - self.dists['nn']) <= self.tol:
            order = '-nn'
        elif abs(dist - self.dists['nnn']) <= self.tol:
            order = '-nnn'
        elif abs(dist - self.dists['nnnn']) <= self.tol:
            order = '-nnnn'
        j_ij = f'{i_index}-{j_index}{order}'
        j_ji = f'{j_index}-{i_index}{order}'
        if j_ij in self.ex_params:
            j_exc = self.ex_params[j_ij]
        elif j_ji in self.ex_params:
            j_exc = self.ex_params[j_ji]
        else:
            j_exc = 0
        if '<J>' in self.ex_params and order == '-nn':
            j_exc = self.ex_params['<J>']
        return j_exc