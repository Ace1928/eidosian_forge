import re
from .fastjsonschema_exceptions import JsonSchemaValueException
def validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata(data, custom_formats={}, name_prefix=None):
    if not isinstance(data, dict):
        raise JsonSchemaValueException('' + (name_prefix or 'data') + ' must be object', value=data, name='' + (name_prefix or 'data') + '', definition={'$schema': 'http://json-schema.org/draft-07/schema', '$id': 'https://packaging.python.org/en/latest/specifications/declaring-project-metadata/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', "with meaning similar to the one defined in `core metadata's Description", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'authors' of the project.", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'maintainers' of the project.", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as "Required", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_len = len(data)
        if not all((prop in data for prop in ['name'])):
            raise JsonSchemaValueException('' + (name_prefix or 'data') + " must contain ['name'] properties", value=data, name='' + (name_prefix or 'data') + '', definition={'$schema': 'http://json-schema.org/draft-07/schema', '$id': 'https://packaging.python.org/en/latest/specifications/declaring-project-metadata/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', "with meaning similar to the one defined in `core metadata's Description", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'authors' of the project.", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'maintainers' of the project.", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as "Required", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='required')
        data_keys = set(data.keys())
        if 'name' in data_keys:
            data_keys.remove('name')
            data__name = data['name']
            if not isinstance(data__name, str):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.name must be string', value=data__name, name='' + (name_prefix or 'data') + '.name', definition={'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, rule='type')
            if isinstance(data__name, str):
                if not custom_formats['pep508-identifier'](data__name):
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.name must be pep508-identifier', value=data__name, name='' + (name_prefix or 'data') + '.name', definition={'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, rule='format')
        if 'version' in data_keys:
            data_keys.remove('version')
            data__version = data['version']
            if not isinstance(data__version, str):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.version must be string', value=data__version, name='' + (name_prefix or 'data') + '.version', definition={'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, rule='type')
            if isinstance(data__version, str):
                if not custom_formats['pep440'](data__version):
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.version must be pep440', value=data__version, name='' + (name_prefix or 'data') + '.version', definition={'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, rule='format')
        if 'description' in data_keys:
            data_keys.remove('description')
            data__description = data['description']
            if not isinstance(data__description, str):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.description must be string', value=data__description, name='' + (name_prefix or 'data') + '.description', definition={'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, rule='type')
        if 'readme' in data_keys:
            data_keys.remove('readme')
            data__readme = data['readme']
            data__readme_one_of_count9 = 0
            if data__readme_one_of_count9 < 2:
                try:
                    if not isinstance(data__readme, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme must be string', value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, rule='type')
                    data__readme_one_of_count9 += 1
                except JsonSchemaValueException:
                    pass
            if data__readme_one_of_count9 < 2:
                try:
                    if not isinstance(data__readme, dict):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme must be object', value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}, rule='type')
                    data__readme_any_of_count10 = 0
                    if not data__readme_any_of_count10:
                        try:
                            data__readme_is_dict = isinstance(data__readme, dict)
                            if data__readme_is_dict:
                                data__readme_len = len(data__readme)
                                if not all((prop in data__readme for prop in ['file'])):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + ".readme must contain ['file'] properties", value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, rule='required')
                                data__readme_keys = set(data__readme.keys())
                                if 'file' in data__readme_keys:
                                    data__readme_keys.remove('file')
                                    data__readme__file = data__readme['file']
                                    if not isinstance(data__readme__file, str):
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme.file must be string', value=data__readme__file, name='' + (name_prefix or 'data') + '.readme.file', definition={'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}, rule='type')
                            data__readme_any_of_count10 += 1
                        except JsonSchemaValueException:
                            pass
                    if not data__readme_any_of_count10:
                        try:
                            data__readme_is_dict = isinstance(data__readme, dict)
                            if data__readme_is_dict:
                                data__readme_len = len(data__readme)
                                if not all((prop in data__readme for prop in ['text'])):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + ".readme must contain ['text'] properties", value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}, rule='required')
                                data__readme_keys = set(data__readme.keys())
                                if 'text' in data__readme_keys:
                                    data__readme_keys.remove('text')
                                    data__readme__text = data__readme['text']
                                    if not isinstance(data__readme__text, str):
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme.text must be string', value=data__readme__text, name='' + (name_prefix or 'data') + '.readme.text', definition={'type': 'string', 'description': 'Full text describing the project.'}, rule='type')
                            data__readme_any_of_count10 += 1
                        except JsonSchemaValueException:
                            pass
                    if not data__readme_any_of_count10:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme cannot be validated by any definition', value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, rule='anyOf')
                    data__readme_is_dict = isinstance(data__readme, dict)
                    if data__readme_is_dict:
                        data__readme_len = len(data__readme)
                        if not all((prop in data__readme for prop in ['content-type'])):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + ".readme must contain ['content-type'] properties", value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}, rule='required')
                        data__readme_keys = set(data__readme.keys())
                        if 'content-type' in data__readme_keys:
                            data__readme_keys.remove('content-type')
                            data__readme__contenttype = data__readme['content-type']
                            if not isinstance(data__readme__contenttype, str):
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme.content-type must be string', value=data__readme__contenttype, name='' + (name_prefix or 'data') + '.readme.content-type', definition={'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}, rule='type')
                    data__readme_one_of_count9 += 1
                except JsonSchemaValueException:
                    pass
            if data__readme_one_of_count9 != 1:
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.readme must be valid exactly by one definition' + (' (' + str(data__readme_one_of_count9) + ' matches found)'), value=data__readme, name='' + (name_prefix or 'data') + '.readme', definition={'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', "with meaning similar to the one defined in `core metadata's Description", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, rule='oneOf')
        if 'requires-python' in data_keys:
            data_keys.remove('requires-python')
            data__requirespython = data['requires-python']
            if not isinstance(data__requirespython, str):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.requires-python must be string', value=data__requirespython, name='' + (name_prefix or 'data') + '.requires-python', definition={'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, rule='type')
            if isinstance(data__requirespython, str):
                if not custom_formats['pep508-versionspec'](data__requirespython):
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.requires-python must be pep508-versionspec', value=data__requirespython, name='' + (name_prefix or 'data') + '.requires-python', definition={'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, rule='format')
        if 'license' in data_keys:
            data_keys.remove('license')
            data__license = data['license']
            data__license_one_of_count11 = 0
            if data__license_one_of_count11 < 2:
                try:
                    data__license_is_dict = isinstance(data__license, dict)
                    if data__license_is_dict:
                        data__license_len = len(data__license)
                        if not all((prop in data__license for prop in ['file'])):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + ".license must contain ['file'] properties", value=data__license, name='' + (name_prefix or 'data') + '.license', definition={'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, rule='required')
                        data__license_keys = set(data__license.keys())
                        if 'file' in data__license_keys:
                            data__license_keys.remove('file')
                            data__license__file = data__license['file']
                            if not isinstance(data__license__file, str):
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.license.file must be string', value=data__license__file, name='' + (name_prefix or 'data') + '.license.file', definition={'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}, rule='type')
                    data__license_one_of_count11 += 1
                except JsonSchemaValueException:
                    pass
            if data__license_one_of_count11 < 2:
                try:
                    data__license_is_dict = isinstance(data__license, dict)
                    if data__license_is_dict:
                        data__license_len = len(data__license)
                        if not all((prop in data__license for prop in ['text'])):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + ".license must contain ['text'] properties", value=data__license, name='' + (name_prefix or 'data') + '.license', definition={'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}, rule='required')
                        data__license_keys = set(data__license.keys())
                        if 'text' in data__license_keys:
                            data__license_keys.remove('text')
                            data__license__text = data__license['text']
                            if not isinstance(data__license__text, str):
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.license.text must be string', value=data__license__text, name='' + (name_prefix or 'data') + '.license.text', definition={'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}, rule='type')
                    data__license_one_of_count11 += 1
                except JsonSchemaValueException:
                    pass
            if data__license_one_of_count11 != 1:
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.license must be valid exactly by one definition' + (' (' + str(data__license_one_of_count11) + ' matches found)'), value=data__license, name='' + (name_prefix or 'data') + '.license', definition={'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, rule='oneOf')
        if 'authors' in data_keys:
            data_keys.remove('authors')
            data__authors = data['authors']
            if not isinstance(data__authors, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.authors must be array', value=data__authors, name='' + (name_prefix or 'data') + '.authors', definition={'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'authors' of the project.", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, rule='type')
            data__authors_is_list = isinstance(data__authors, (list, tuple))
            if data__authors_is_list:
                data__authors_len = len(data__authors)
                for data__authors_x, data__authors_item in enumerate(data__authors):
                    validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_author(data__authors_item, custom_formats, (name_prefix or 'data') + '.authors[{data__authors_x}]'.format(**locals()))
        if 'maintainers' in data_keys:
            data_keys.remove('maintainers')
            data__maintainers = data['maintainers']
            if not isinstance(data__maintainers, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.maintainers must be array', value=data__maintainers, name='' + (name_prefix or 'data') + '.maintainers', definition={'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'maintainers' of the project.", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, rule='type')
            data__maintainers_is_list = isinstance(data__maintainers, (list, tuple))
            if data__maintainers_is_list:
                data__maintainers_len = len(data__maintainers)
                for data__maintainers_x, data__maintainers_item in enumerate(data__maintainers):
                    validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_author(data__maintainers_item, custom_formats, (name_prefix or 'data') + '.maintainers[{data__maintainers_x}]'.format(**locals()))
        if 'keywords' in data_keys:
            data_keys.remove('keywords')
            data__keywords = data['keywords']
            if not isinstance(data__keywords, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.keywords must be array', value=data__keywords, name='' + (name_prefix or 'data') + '.keywords', definition={'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, rule='type')
            data__keywords_is_list = isinstance(data__keywords, (list, tuple))
            if data__keywords_is_list:
                data__keywords_len = len(data__keywords)
                for data__keywords_x, data__keywords_item in enumerate(data__keywords):
                    if not isinstance(data__keywords_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.keywords[{data__keywords_x}]'.format(**locals()) + ' must be string', value=data__keywords_item, name='' + (name_prefix or 'data') + '.keywords[{data__keywords_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'classifiers' in data_keys:
            data_keys.remove('classifiers')
            data__classifiers = data['classifiers']
            if not isinstance(data__classifiers, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.classifiers must be array', value=data__classifiers, name='' + (name_prefix or 'data') + '.classifiers', definition={'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, rule='type')
            data__classifiers_is_list = isinstance(data__classifiers, (list, tuple))
            if data__classifiers_is_list:
                data__classifiers_len = len(data__classifiers)
                for data__classifiers_x, data__classifiers_item in enumerate(data__classifiers):
                    if not isinstance(data__classifiers_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.classifiers[{data__classifiers_x}]'.format(**locals()) + ' must be string', value=data__classifiers_item, name='' + (name_prefix or 'data') + '.classifiers[{data__classifiers_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, rule='type')
                    if isinstance(data__classifiers_item, str):
                        if not custom_formats['trove-classifier'](data__classifiers_item):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.classifiers[{data__classifiers_x}]'.format(**locals()) + ' must be trove-classifier', value=data__classifiers_item, name='' + (name_prefix or 'data') + '.classifiers[{data__classifiers_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, rule='format')
        if 'urls' in data_keys:
            data_keys.remove('urls')
            data__urls = data['urls']
            if not isinstance(data__urls, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.urls must be object', value=data__urls, name='' + (name_prefix or 'data') + '.urls', definition={'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, rule='type')
            data__urls_is_dict = isinstance(data__urls, dict)
            if data__urls_is_dict:
                data__urls_keys = set(data__urls.keys())
                for data__urls_key, data__urls_val in data__urls.items():
                    if REGEX_PATTERNS['^.+$'].search(data__urls_key):
                        if data__urls_key in data__urls_keys:
                            data__urls_keys.remove(data__urls_key)
                        if not isinstance(data__urls_val, str):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.urls.{data__urls_key}'.format(**locals()) + ' must be string', value=data__urls_val, name='' + (name_prefix or 'data') + '.urls.{data__urls_key}'.format(**locals()) + '', definition={'type': 'string', 'format': 'url'}, rule='type')
                        if isinstance(data__urls_val, str):
                            if not custom_formats['url'](data__urls_val):
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.urls.{data__urls_key}'.format(**locals()) + ' must be url', value=data__urls_val, name='' + (name_prefix or 'data') + '.urls.{data__urls_key}'.format(**locals()) + '', definition={'type': 'string', 'format': 'url'}, rule='format')
                if data__urls_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.urls must not contain ' + str(data__urls_keys) + ' properties', value=data__urls, name='' + (name_prefix or 'data') + '.urls', definition={'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, rule='additionalProperties')
        if 'scripts' in data_keys:
            data_keys.remove('scripts')
            data__scripts = data['scripts']
            validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group(data__scripts, custom_formats, (name_prefix or 'data') + '.scripts')
        if 'gui-scripts' in data_keys:
            data_keys.remove('gui-scripts')
            data__guiscripts = data['gui-scripts']
            validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group(data__guiscripts, custom_formats, (name_prefix or 'data') + '.gui-scripts')
        if 'entry-points' in data_keys:
            data_keys.remove('entry-points')
            data__entrypoints = data['entry-points']
            data__entrypoints_is_dict = isinstance(data__entrypoints, dict)
            if data__entrypoints_is_dict:
                data__entrypoints_keys = set(data__entrypoints.keys())
                for data__entrypoints_key, data__entrypoints_val in data__entrypoints.items():
                    if REGEX_PATTERNS['^.+$'].search(data__entrypoints_key):
                        if data__entrypoints_key in data__entrypoints_keys:
                            data__entrypoints_keys.remove(data__entrypoints_key)
                        validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_entry_point_group(data__entrypoints_val, custom_formats, (name_prefix or 'data') + '.entry-points.{data__entrypoints_key}'.format(**locals()))
                if data__entrypoints_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.entry-points must not contain ' + str(data__entrypoints_keys) + ' properties', value=data__entrypoints, name='' + (name_prefix or 'data') + '.entry-points', definition={'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, rule='additionalProperties')
                data__entrypoints_len = len(data__entrypoints)
                if data__entrypoints_len != 0:
                    data__entrypoints_property_names = True
                    for data__entrypoints_key in data__entrypoints:
                        try:
                            if isinstance(data__entrypoints_key, str):
                                if not custom_formats['python-entrypoint-group'](data__entrypoints_key):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.entry-points must be python-entrypoint-group', value=data__entrypoints_key, name='' + (name_prefix or 'data') + '.entry-points', definition={'format': 'python-entrypoint-group'}, rule='format')
                        except JsonSchemaValueException:
                            data__entrypoints_property_names = False
                    if not data__entrypoints_property_names:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.entry-points must be named by propertyName definition', value=data__entrypoints, name='' + (name_prefix or 'data') + '.entry-points', definition={'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, rule='propertyNames')
        if 'dependencies' in data_keys:
            data_keys.remove('dependencies')
            data__dependencies = data['dependencies']
            if not isinstance(data__dependencies, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dependencies must be array', value=data__dependencies, name='' + (name_prefix or 'data') + '.dependencies', definition={'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, rule='type')
            data__dependencies_is_list = isinstance(data__dependencies, (list, tuple))
            if data__dependencies_is_list:
                data__dependencies_len = len(data__dependencies)
                for data__dependencies_x, data__dependencies_item in enumerate(data__dependencies):
                    validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_dependency(data__dependencies_item, custom_formats, (name_prefix or 'data') + '.dependencies[{data__dependencies_x}]'.format(**locals()))
        if 'optional-dependencies' in data_keys:
            data_keys.remove('optional-dependencies')
            data__optionaldependencies = data['optional-dependencies']
            if not isinstance(data__optionaldependencies, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.optional-dependencies must be object', value=data__optionaldependencies, name='' + (name_prefix or 'data') + '.optional-dependencies', definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='type')
            data__optionaldependencies_is_dict = isinstance(data__optionaldependencies, dict)
            if data__optionaldependencies_is_dict:
                data__optionaldependencies_keys = set(data__optionaldependencies.keys())
                for data__optionaldependencies_key, data__optionaldependencies_val in data__optionaldependencies.items():
                    if REGEX_PATTERNS['^.+$'].search(data__optionaldependencies_key):
                        if data__optionaldependencies_key in data__optionaldependencies_keys:
                            data__optionaldependencies_keys.remove(data__optionaldependencies_key)
                        if not isinstance(data__optionaldependencies_val, (list, tuple)):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.optional-dependencies.{data__optionaldependencies_key}'.format(**locals()) + ' must be array', value=data__optionaldependencies_val, name='' + (name_prefix or 'data') + '.optional-dependencies.{data__optionaldependencies_key}'.format(**locals()) + '', definition={'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, rule='type')
                        data__optionaldependencies_val_is_list = isinstance(data__optionaldependencies_val, (list, tuple))
                        if data__optionaldependencies_val_is_list:
                            data__optionaldependencies_val_len = len(data__optionaldependencies_val)
                            for data__optionaldependencies_val_x, data__optionaldependencies_val_item in enumerate(data__optionaldependencies_val):
                                validate_https___packaging_python_org_en_latest_specifications_declaring_project_metadata___definitions_dependency(data__optionaldependencies_val_item, custom_formats, (name_prefix or 'data') + '.optional-dependencies.{data__optionaldependencies_key}[{data__optionaldependencies_val_x}]'.format(**locals()))
                if data__optionaldependencies_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.optional-dependencies must not contain ' + str(data__optionaldependencies_keys) + ' properties', value=data__optionaldependencies, name='' + (name_prefix or 'data') + '.optional-dependencies', definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='additionalProperties')
                data__optionaldependencies_len = len(data__optionaldependencies)
                if data__optionaldependencies_len != 0:
                    data__optionaldependencies_property_names = True
                    for data__optionaldependencies_key in data__optionaldependencies:
                        try:
                            if isinstance(data__optionaldependencies_key, str):
                                if not custom_formats['pep508-identifier'](data__optionaldependencies_key):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.optional-dependencies must be pep508-identifier', value=data__optionaldependencies_key, name='' + (name_prefix or 'data') + '.optional-dependencies', definition={'format': 'pep508-identifier'}, rule='format')
                        except JsonSchemaValueException:
                            data__optionaldependencies_property_names = False
                    if not data__optionaldependencies_property_names:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.optional-dependencies must be named by propertyName definition', value=data__optionaldependencies, name='' + (name_prefix or 'data') + '.optional-dependencies', definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='propertyNames')
        if 'dynamic' in data_keys:
            data_keys.remove('dynamic')
            data__dynamic = data['dynamic']
            if not isinstance(data__dynamic, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic must be array', value=data__dynamic, name='' + (name_prefix or 'data') + '.dynamic', definition={'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}, rule='type')
            data__dynamic_is_list = isinstance(data__dynamic, (list, tuple))
            if data__dynamic_is_list:
                data__dynamic_len = len(data__dynamic)
                for data__dynamic_x, data__dynamic_item in enumerate(data__dynamic):
                    if data__dynamic_item not in ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic[{data__dynamic_x}]'.format(**locals()) + " must be one of ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']", value=data__dynamic_item, name='' + (name_prefix or 'data') + '.dynamic[{data__dynamic_x}]'.format(**locals()) + '', definition={'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}, rule='enum')
        if data_keys:
            raise JsonSchemaValueException('' + (name_prefix or 'data') + ' must not contain ' + str(data_keys) + ' properties', value=data, name='' + (name_prefix or 'data') + '', definition={'$schema': 'http://json-schema.org/draft-07/schema', '$id': 'https://packaging.python.org/en/latest/specifications/declaring-project-metadata/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', "with meaning similar to the one defined in `core metadata's Description", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'authors' of the project.", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': ["The people or organizations considered to be the 'maintainers' of the project.", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as "Required", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='additionalProperties')
    try:
        try:
            data_is_dict = isinstance(data, dict)
            if data_is_dict:
                data_len = len(data)
                if not all((prop in data for prop in ['dynamic'])):
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + " must contain ['dynamic'] properties", value=data, name='' + (name_prefix or 'data') + '', definition={'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, rule='required')
                data_keys = set(data.keys())
                if 'dynamic' in data_keys:
                    data_keys.remove('dynamic')
                    data__dynamic = data['dynamic']
                    data__dynamic_is_list = isinstance(data__dynamic, (list, tuple))
                    if data__dynamic_is_list:
                        data__dynamic_contains = False
                        for data__dynamic_key in data__dynamic:
                            try:
                                if data__dynamic_key != 'version':
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic must be same as const definition: version', value=data__dynamic_key, name='' + (name_prefix or 'data') + '.dynamic', definition={'const': 'version'}, rule='const')
                                data__dynamic_contains = True
                                break
                            except JsonSchemaValueException:
                                pass
                        if not data__dynamic_contains:
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic must contain one of contains definition', value=data__dynamic, name='' + (name_prefix or 'data') + '.dynamic', definition={'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}, rule='contains')
        except JsonSchemaValueException:
            pass
        else:
            raise JsonSchemaValueException('' + (name_prefix or 'data') + ' must NOT match a disallowed definition', value=data, name='' + (name_prefix or 'data') + '', definition={'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as "Required", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, rule='not')
    except JsonSchemaValueException:
        pass
    else:
        data_is_dict = isinstance(data, dict)
        if data_is_dict:
            data_len = len(data)
            if not all((prop in data for prop in ['version'])):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + " must contain ['version'] properties", value=data, name='' + (name_prefix or 'data') + '', definition={'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, rule='required')
    return data