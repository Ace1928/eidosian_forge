import logging
import math
import pyomo.common.unittest as unittest
from pyomo.common.log import LoggingIntercept
from pyomo.core.expr.numvalue import is_fixed
from pyomo.core.expr.compare import assertExpressionsStructurallyEqual
from pyomo.core.expr import (
from pyomo.core.expr.numeric_expr import (
from pyomo.environ import ConcreteModel, Param, Var, ExternalFunction
class TestExpressionDuplicateAPI(unittest.TestCase):

    def test_negation(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = NegationExpression((m.x,))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2,))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2,))
        e = NPV_NegationExpression((m.p,))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.x,))
        self.assertIsNot(f, e)
        self.assertIs(type(f), NegationExpression)

    def test_pow(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = PowExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2, 3))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2, 3))
        e = NPV_PowExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), PowExpression)

    def test_min(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = MinExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2, 3, 4))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2, 3, 4))
        e = NPV_MinExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), MinExpression)

    def test_max(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = MaxExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2, 3, 4))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2, 3, 4))
        e = NPV_MaxExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), MaxExpression)

    def test_prod(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = ProductExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((m.p, 3))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (m.p, 3))
        e = NPV_ProductExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), ProductExpression)

    def test_monomial(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = MonomialTermExpression((2, m.x))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, e.args)
        f = e.create_node_with_local_data((m.p, 3))
        self.assertIsNot(f, e)
        self.assertIs(type(f), NPV_ProductExpression)
        self.assertEqual(f.args, (m.p, 3))
        f = e.create_node_with_local_data((m.x, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), ProductExpression)
        self.assertEqual(f.args, (m.x, m.x))

    def test_division(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = DivisionExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2, 3))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2, 3))
        e = NPV_DivisionExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), DivisionExpression)

    def test_sum(self):
        m = ConcreteModel()
        m.x = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = SumExpression((m.x, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIsNot(f._args_, e._args_)
        self.assertIsNot(f.args, e.args)
        f = e.create_node_with_local_data(e._args_)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f._args_, e._args_)
        self.assertIsNot(f.args, e.args)
        f = e.create_node_with_local_data((m.x, 2, 3))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, [m.x, 2, 3])
        e = NPV_SumExpression((m.p, 2))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p, m.x))
        self.assertIsNot(f, e)
        self.assertIs(type(f), LinearExpression)
        assertExpressionsStructurallyEqual(self, f.args, [m.p, MonomialTermExpression((1, m.x))])
        f = e.create_node_with_local_data((m.p, m.x ** 2))
        self.assertIsNot(f, e)
        self.assertIs(type(f), SumExpression)
        assertExpressionsStructurallyEqual(self, f.args, [m.p, PowExpression((m.x, 2))])

    def test_linear(self):
        m = ConcreteModel()
        m.x = Var(range(3), initialize=range(3))
        m.y = Var(initialize=5)
        with mutable_expression() as e:
            for i in range(3):
                e += i * m.x[i]
            e += 5
            e += m.y
            e -= 3

    def test_expr_if(self):
        m = ConcreteModel()
        m.x = Var(range(3), initialize=range(3))
        m.y = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = Expr_if(IF=m.y >= 5, THEN=m.x[0] + 5, ELSE=m.x[1] ** 2)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        f = e.create_node_with_local_data((2, 3, 4))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (2, 3, 4))
        e = NPV_Expr_ifExpression((m.p <= 5, 2, m.p))
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        f = e.create_node_with_local_data((m.p <= 5, m.x, m.p))
        self.assertIsNot(f, e)
        self.assertIs(type(f), Expr_ifExpression)

    def test_unary_fcn(self):
        m = ConcreteModel()
        m.x = Var(range(3), initialize=range(3))
        m.y = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = sin(2 * m.y)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        f = e.create_node_with_local_data((m.x[1],))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (m.x[1],))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        e = sin(2 * m.p)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        f = e.create_node_with_local_data((m.x[1],))
        self.assertIsNot(f, e)
        self.assertIs(type(f), UnaryFunctionExpression)
        self.assertEqual(f.args, (m.x[1],))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)

    def test_abs(self):
        m = ConcreteModel()
        m.x = Var(range(3), initialize=range(3))
        m.y = Var(initialize=5)
        m.p = Param(initialize=3, mutable=True)
        e = abs(2 * m.y)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        f = e.create_node_with_local_data((m.x[1],))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (m.x[1],))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        e = abs(2 * m.p)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)
        f = e.create_node_with_local_data((m.x[1],))
        self.assertIsNot(f, e)
        self.assertIs(type(f), AbsExpression)
        self.assertEqual(f.args, (m.x[1],))
        self.assertIs(e._fcn, f._fcn)
        self.assertIs(e._name, f._name)

    def test_external(self):
        m = ConcreteModel()
        m.x = Var(initialize=16)
        m.p = Param(initialize=32, mutable=True)
        fcn = MockExternalFunction()
        e = ExternalFunctionExpression((2 * m.x,), fcn)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(f.args, e.args)
        self.assertIs(e._fcn, f._fcn)
        f = e.create_node_with_local_data((m.x,))
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertEqual(f.args, (m.x,))
        self.assertIs(e._fcn, f._fcn)
        e = NPV_ExternalFunctionExpression((2 * m.p,), fcn)
        f = e.create_node_with_local_data(e.args)
        self.assertIsNot(f, e)
        self.assertIs(type(f), type(e))
        self.assertIs(e._fcn, f._fcn)
        f = e.create_node_with_local_data((m.x,))
        self.assertIsNot(f, e)
        self.assertIs(type(f), ExternalFunctionExpression)
        self.assertEqual(f.args, (m.x,))
        self.assertIs(e._fcn, f._fcn)