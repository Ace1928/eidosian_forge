import atexit
import inspect
import os
import pprint
import re
import subprocess
import textwrap
class _Cache:
    """An abstract class handles caching functionality, provides two
    levels of caching, in-memory by share instances attributes among
    each other and by store attributes into files.

    **Note**:
        any attributes that start with ``_`` or ``conf_`` will be ignored.

    Parameters
    ----------
    cache_path : str or None
        The path of cache file, if None then cache in file will disabled.

    *factors :
        The caching factors that need to utilize next to `conf_cache_factors`.

    Attributes
    ----------
    cache_private : set
        Hold the attributes that need be skipped from "in-memory cache".

    cache_infile : bool
        Utilized during initializing this class, to determine if the cache was able
        to loaded from the specified cache path in 'cache_path'.
    """
    _cache_ignore = re.compile('^(_|conf_)')

    def __init__(self, cache_path=None, *factors):
        self.cache_me = {}
        self.cache_private = set()
        self.cache_infile = False
        self._cache_path = None
        if self.conf_nocache:
            self.dist_log('cache is disabled by `Config`')
            return
        self._cache_hash = self.cache_hash(*factors, *self.conf_cache_factors)
        self._cache_path = cache_path
        if cache_path:
            if os.path.exists(cache_path):
                self.dist_log('load cache from file ->', cache_path)
                cache_mod = self.dist_load_module('cache', cache_path)
                if not cache_mod:
                    self.dist_log('unable to load the cache file as a module', stderr=True)
                elif not hasattr(cache_mod, 'hash') or not hasattr(cache_mod, 'data'):
                    self.dist_log('invalid cache file', stderr=True)
                elif self._cache_hash == cache_mod.hash:
                    self.dist_log('hit the file cache')
                    for attr, val in cache_mod.data.items():
                        setattr(self, attr, val)
                    self.cache_infile = True
                else:
                    self.dist_log('miss the file cache')
        if not self.cache_infile:
            other_cache = _share_cache.get(self._cache_hash)
            if other_cache:
                self.dist_log('hit the memory cache')
                for attr, val in other_cache.__dict__.items():
                    if attr in other_cache.cache_private or re.match(self._cache_ignore, attr):
                        continue
                    setattr(self, attr, val)
        _share_cache[self._cache_hash] = self
        atexit.register(self.cache_flush)

    def __del__(self):
        for h, o in _share_cache.items():
            if o == self:
                _share_cache.pop(h)
                break

    def cache_flush(self):
        """
        Force update the cache.
        """
        if not self._cache_path:
            return
        self.dist_log('write cache to path ->', self._cache_path)
        cdict = self.__dict__.copy()
        for attr in self.__dict__.keys():
            if re.match(self._cache_ignore, attr):
                cdict.pop(attr)
        d = os.path.dirname(self._cache_path)
        if not os.path.exists(d):
            os.makedirs(d)
        repr_dict = pprint.pformat(cdict, compact=True)
        with open(self._cache_path, 'w') as f:
            f.write(textwrap.dedent("            # AUTOGENERATED DON'T EDIT\n            # Please make changes to the code generator             (distutils/ccompiler_opt.py)\n            hash = {}\n            data = \\\n            ").format(self._cache_hash))
            f.write(repr_dict)

    def cache_hash(self, *factors):
        chash = 0
        for f in factors:
            for char in str(f):
                chash = ord(char) + (chash << 6) + (chash << 16) - chash
                chash &= 4294967295
        return chash

    @staticmethod
    def me(cb):
        """
        A static method that can be treated as a decorator to
        dynamically cache certain methods.
        """

        def cache_wrap_me(self, *args, **kwargs):
            cache_key = str((cb.__name__, *args, *kwargs.keys(), *kwargs.values()))
            if cache_key in self.cache_me:
                return self.cache_me[cache_key]
            ccb = cb(self, *args, **kwargs)
            self.cache_me[cache_key] = ccb
            return ccb
        return cache_wrap_me