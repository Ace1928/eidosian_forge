import sys
import ctypes
from pyglet.util import debug_print
class COMObject:
    """A COMObject for implementing C callbacks in Python.
    Specify the interface types it supports in `_interfaces_`, and any methods to be implemented
    by those interfaces as standard python methods. If the names match, they will be run as
    callbacks with all arguments supplied as the types specified in the corresponding interface,
    and `self` available as usual.
    Remember to call `super().__init__()`.

    COMObjects can be passed to ctypes functions directly as long as the corresponding argtype is
    an `Interface` pointer, or a `pInterface` subclass.

    IUnknown's methods will be autogenerated in case IUnknown is implemented.
    """

    def __init_subclass__(cls, /, **kwargs):
        super().__init_subclass__(**kwargs)
        implemented_leaf_interfaces = cls.__dict__.get('_interfaces_', ())
        if not implemented_leaf_interfaces:
            raise TypeError('At least one interface must be defined to use a COMObject')
        for interface_type in implemented_leaf_interfaces:
            for other in implemented_leaf_interfaces:
                if interface_type is other:
                    continue
                if issubclass(interface_type, other):
                    raise TypeError('Only specify the leaf interfaces')
        _ptr_size = ctypes.sizeof(ctypes.c_void_p)
        _vtbl_pointers = []
        implemented_methods = {}
        _interface_to_vtbl_offset = {}
        for i, interface_type in enumerate(implemented_leaf_interfaces):
            bases = interface_type.get_interface_inheritance()
            for base in bases:
                if base not in _interface_to_vtbl_offset:
                    _interface_to_vtbl_offset[base] = i * _ptr_size
        if IUnknown in _interface_to_vtbl_offset:

            def QueryInterface(self, iid_ptr, res_ptr):
                ctypes.cast(res_ptr, ctypes.POINTER(ctypes.c_void_p))[0] = 0
                return E_NOINTERFACE

            def AddRef(self):
                self._vrefcount += 1
                return self._vrefcount

            def Release(self):
                if self._vrefcount <= 0:
                    assert _debug_com(f'COMObject {self}: Release while refcount was {self._vrefcount}')
                self._vrefcount -= 1
                return self._vrefcount
            cls.QueryInterface = QueryInterface
            cls.AddRef = AddRef
            cls.Release = Release
        for i, interface_type in enumerate(implemented_leaf_interfaces):
            wrappers = []
            for method_name, method_type in interface_type._vtbl_struct_type._fields_:
                if method_name in implemented_methods:
                    func, implementing_vtbl_idx = implemented_methods[method_name]
                    mth = _adjust_impl(interface_type.__name__, method_name, func, (implementing_vtbl_idx - i) * _ptr_size)
                else:
                    if (found_method := getattr(cls, method_name, None)) is None:
                        mth = _missing_impl(interface_type.__name__, method_name)
                    else:
                        mth = _found_impl(interface_type.__name__, method_name, found_method, (len(implemented_leaf_interfaces) - i) * _ptr_size)
                    implemented_methods[method_name] = (mth, i)
                wrappers.append(method_type(mth))
            vtbl = interface_type._vtbl_struct_type(*wrappers)
            _vtbl_pointers.append(ctypes.pointer(vtbl))
        fields = []
        for i, itf in enumerate(implemented_leaf_interfaces):
            fields.append((f'vtbl_ptr_{i}', ctypes.POINTER(itf._vtbl_struct_type)))
        fields.append(('self_', ctypes.py_object))
        cls._interface_to_vtbl_offset = _interface_to_vtbl_offset
        cls._vtbl_pointers = _vtbl_pointers
        cls._struct_type = _StructMeta(f'{cls.__name__}_Struct', (ctypes.Structure,), {'_fields_': fields})

    def __init__(self):
        self._vrefcount = 1
        self._struct = self._struct_type(*self._vtbl_pointers, ctypes.py_object(self))

    def as_interface(self, interface_type):
        if (offset := self._interface_to_vtbl_offset.get(interface_type, None)) is None:
            raise TypeError(f'Does not implement {interface_type}')
        return ctypes.byref(self._struct, offset)