from __future__ import annotations
import os
import re
import warnings
from string import Template
from typing import TYPE_CHECKING
import numpy as np
from monty.io import zopen
from monty.json import MSONable
from pymatgen.analysis.excitation import ExcitationSpectrum
from pymatgen.core.structure import Molecule, Structure
from pymatgen.core.units import Energy, FloatWithUnit
@classmethod
def from_molecule(cls, mol, theory, charge=None, spin_multiplicity=None, basis_set='6-31g', basis_set_option='cartesian', title=None, operation='optimize', theory_directives=None, alternate_directives=None) -> Self:
    """
        Very flexible arguments to support many types of potential setups.
        Users should use more friendly static methods unless they need the
        flexibility.

        Args:
            mol: Input molecule
            charge: Charge of the molecule. If None, charge on molecule is
                used. Defaults to None. This allows the input file to be set a
                charge independently from the molecule itself.
            spin_multiplicity: Spin multiplicity of molecule. Defaults to None,
                which means that the spin multiplicity is set to 1 if the
                molecule has no unpaired electrons and to 2 if there are
                unpaired electrons.
            basis_set: The basis set to be used as string or a dict. E.g.,
                {"C": "6-311++G**", "H": "6-31++G**"} or "6-31G". If string,
                same basis set is used for all elements.
            basis_set_option: cartesian (default) | spherical,
            title: Title for the task. Defaults to None, which means a title
                based on the theory and operation of the task is
                autogenerated.
            theory: The theory used for the task. Defaults to "dft".
            operation: The operation for the task. Defaults to "optimize".
            theory_directives: A dict of theory directives. For example,
                if you are running dft calculations, you may specify the
                exchange correlation functional using {"xc": "b3lyp"}.
            alternate_directives: A dict of alternate directives. For
                example, to perform cosmo calculations with DFT, you'd supply
                {'cosmo': "cosmo"}.
        """
    formula = re.sub('\\s', '', mol.formula)
    title = title if title is not None else f'{formula} {theory} {operation}'
    charge = charge if charge is not None else mol.charge
    n_electrons = -charge + mol.charge + mol.nelectrons
    if spin_multiplicity is not None:
        if (n_electrons + spin_multiplicity) % 2 != 1:
            raise ValueError(f'charge={charge!r} and spin_multiplicity={spin_multiplicity!r} is not possible for this molecule')
    elif charge == mol.charge:
        spin_multiplicity = mol.spin_multiplicity
    else:
        spin_multiplicity = 1 if n_electrons % 2 == 0 else 2
    elements = set(mol.composition.get_el_amt_dict())
    if isinstance(basis_set, str):
        basis_set = dict.fromkeys(elements, basis_set)
    return cls(charge, spin_multiplicity, basis_set, basis_set_option=basis_set_option, title=title, theory=theory, operation=operation, theory_directives=theory_directives, alternate_directives=alternate_directives)