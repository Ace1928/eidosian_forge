import base64
import collections
import datetime
import enum
import struct
import typing
from spnego._asn1 import (
from spnego._text import to_text
class KdcReqBody:
    """The KRB_AS_REQ message.

    The KRB_AS_REQ message is used when the client wishes to retrieve a the initial ticket for a service. The
    KRB_TGS_REQ message is identical except for the tag and msg-type is used when retrieving additional tickets for a
    service.

    The ASN.1 definition for the KDC-REQ structure is defined in `RFC 4120 5.4.1`_::

        KDC-REQ-BODY    ::= SEQUENCE {
            kdc-options             [0] KDCOptions,
            cname                   [1] PrincipalName OPTIONAL
                                        -- Used only in AS-REQ --,
            realm                   [2] Realm
                                        -- Server's realm
                                        -- Also client's in AS-REQ --,
            sname                   [3] PrincipalName OPTIONAL,
            from                    [4] KerberosTime OPTIONAL,
            till                    [5] KerberosTime,
            rtime                   [6] KerberosTime OPTIONAL,
            nonce                   [7] UInt32,
            etype                   [8] SEQUENCE OF Int32 -- EncryptionType
                                        -- in preference order --,
            addresses               [9] HostAddresses OPTIONAL,
            enc-authorization-data  [10] EncryptedData OPTIONAL
                                        -- AuthorizationData --,
            additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL
                                        -- NOTE: not empty
        }

    Args:
        kdc_options: Flags desired by the client and other behaviour desired.
        cname: The client name.
        realm: The realm part of the server's principal.
        sname: The service name.
        postdated_from: When the requested ticket is to be posted from.
        postdated_till: The expiration date requested by the client.
        rtime: The requested renew-till time.
        nonce: Random number generated by the client.
        etype: The desired encryption algorithm to be used in priority order.
        addresses: Addresses from which the requested ticket is to be valid.
        enc_authorization_data: Encrypted authorization data.
        additional_tickets: Additional tickets to be optionally included in a request.

    Attributes:
        kdc_options (int): See args.
        cname (Optional[PrincipalName]): See args.
        realm (bytes): See args.
        sname (PrincipalName): See args.
        postdated_from (Optional[datetime.datetime]): See args.
        postdated_till (datetime.datetime): See args.
        rtime (Optional[datetime.datetime]): See args.
        nonce (int): See args.
        etype (List[KerberosEncryptionType]): See args.
        addresses (Optional[List[HostAddress]]): See args.
        enc_authorization_data (Optional[EncryptedData]): See args.
        additional_tickets (Optional[Ticket]): See args.

    .. _RFC 4120 5.4.1:
        https://www.rfc-editor.org/rfc/rfc4120#section-5.4.1
    """
    PARSE_MAP = [('kdc-options', 'kdc_options', (ParseType.flags, KerberosKDCOptions)), ('cname', 'cname', ParseType.principal_name), ('realm', 'realm', ParseType.text), ('sname', 'sname', ParseType.principal_name), ('from', 'postdated_from', ParseType.datetime), ('till', 'postdated_till', ParseType.datetime), ('rtime', 'rtime', ParseType.datetime), ('nonce', 'nonce', ParseType.default), ('etype', 'etype', ParseType.enum), ('addresses', 'addresses', ParseType.host_address), ('enc-authorization-data', 'enc_authorization_data', ParseType.token), ('additional-tickets', 'additional_tickets', ParseType.token)]

    def __init__(self, kdc_options: int, cname: typing.Optional[PrincipalName], realm: bytes, sname: PrincipalName, postdated_from: typing.Optional[datetime.datetime], postdated_till: datetime.datetime, rtime: typing.Optional[datetime.datetime], nonce: int, etype: typing.List[KerberosEncryptionType], addresses: typing.Optional[typing.List[HostAddress]], enc_authorization_data: typing.Optional[EncryptedData], additional_tickets: typing.Optional[typing.List[Ticket]]) -> None:
        self.kdc_options = kdc_options
        self.cname = cname
        self.realm = realm
        self.sname = sname
        self.postdated_from = postdated_from
        self.postdated_till = postdated_till
        self.rtime = rtime
        self.nonce = nonce
        self.etype = etype
        self.addresses = addresses
        self.enc_authorization_data = enc_authorization_data
        self.additional_tickets = additional_tickets

    @staticmethod
    def unpack(value: typing.Union[ASN1Value, bytes]) -> 'KdcReqBody':
        sequence = unpack_asn1_tagged_sequence(value)

        def unpack_kdc_options(value: typing.Union[ASN1Value, bytes]) -> int:
            b_data = unpack_asn1_bit_string(value)
            return struct.unpack('>I', b_data)[0]

        def unpack_etype(value: typing.Union[ASN1Value, bytes]) -> typing.List[KerberosEncryptionType]:
            return [KerberosEncryptionType(unpack_asn1_integer(e)) for e in unpack_asn1_sequence(value)]

        def unpack_addresses(value: typing.Union[ASN1Value, bytes]) -> typing.List[HostAddress]:
            return [unpack_hostname(h) for h in unpack_asn1_sequence(value)]

        def unpack_ticket(value: typing.Union[ASN1Value, bytes]) -> typing.List[Ticket]:
            return [Ticket.unpack(t) for t in unpack_asn1_sequence(value)]
        kdc_options = get_sequence_value(sequence, 0, 'KDC-REQ-BODY', 'kdc-options', unpack_kdc_options)
        cname = get_sequence_value(sequence, 1, 'KDC-REQ-BODY', 'cname', unpack_principal_name)
        realm = get_sequence_value(sequence, 2, 'KDC-REQ-BODY', 'realm', unpack_asn1_general_string)
        sname = get_sequence_value(sequence, 3, 'KDC-REQ-BODY', 'sname', unpack_principal_name)
        postdated_from = get_sequence_value(sequence, 4, 'KDC-REQ-BODY', 'from', unpack_asn1_generalized_time)
        postdated_till = get_sequence_value(sequence, 5, 'KDC-REQ-BODY', 'till', unpack_asn1_generalized_time)
        rtime = get_sequence_value(sequence, 6, 'KDC-REQ-BODY', 'rtime', unpack_asn1_generalized_time)
        nonce = get_sequence_value(sequence, 7, 'KDC-REQ-BODY', 'nonce', unpack_asn1_integer)
        etype = get_sequence_value(sequence, 8, 'KDC-REQ-BODY', 'etype', unpack_etype)
        addresses = get_sequence_value(sequence, 9, 'KDC-REQ-BODY', 'addresses', unpack_addresses)
        enc_auth_data = get_sequence_value(sequence, 10, 'KDC-REQ-BODY', 'enc-authorization-data', EncryptedData.unpack)
        additional_tickets = get_sequence_value(sequence, 11, 'KDC-REQ-BODY', 'additional-tickets', unpack_ticket)
        return KdcReqBody(kdc_options, cname, realm, sname, postdated_from, postdated_till, rtime, nonce, etype, addresses, enc_auth_data, additional_tickets)