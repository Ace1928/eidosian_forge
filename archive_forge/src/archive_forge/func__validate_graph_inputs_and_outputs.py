import collections
import copy
import itertools
import warnings
from tensorflow.python.eager import context
from tensorflow.python.framework import dtypes
from tensorflow.python.framework import ops
from tensorflow.python.framework import tensor as tensor_lib
from tensorflow.python.keras import backend
from tensorflow.python.keras.engine import base_layer
from tensorflow.python.keras.engine import base_layer_utils
from tensorflow.python.keras.engine import input_layer as input_layer_module
from tensorflow.python.keras.engine import input_spec
from tensorflow.python.keras.engine import node as node_module
from tensorflow.python.keras.engine import training as training_lib
from tensorflow.python.keras.engine import training_utils
from tensorflow.python.keras.saving.saved_model import network_serialization
from tensorflow.python.keras.utils import generic_utils
from tensorflow.python.keras.utils import tf_inspect
from tensorflow.python.keras.utils import tf_utils
from tensorflow.python.ops import array_ops
from tensorflow.python.ops import math_ops
from tensorflow.python.platform import tf_logging as logging
from tensorflow.python.trackable import base as trackable
from tensorflow.python.util import nest
from tensorflow.tools.docs import doc_controls
def _validate_graph_inputs_and_outputs(self):
    """Validates the inputs and outputs of a Graph Network."""
    if len({id(i) for i in self.inputs}) != len(self.inputs):
        raise ValueError('The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ' + str(self.inputs))
    for x in self.inputs:
        if not hasattr(x, '_keras_history'):
            cls_name = self.__class__.__name__
            raise ValueError('Input tensors to a ' + cls_name + ' ' + 'must come from `tf.keras.Input`. Received: ' + str(x) + ' (missing previous layer metadata).')
        layer = x._keras_history.layer
        if len(layer._inbound_nodes) > 1 or (layer._inbound_nodes and (not layer._inbound_nodes[0].is_input)):
            cls_name = self.__class__.__name__
            logging.warning(cls_name + ' model inputs must come from `tf.keras.Input` (thus holding past layer metadata), they cannot be the output of a previous non-Input layer. Here, a tensor specified as input to "' + self.name + '" was not an Input tensor, it was generated by layer ' + layer.name + '.\nNote that input tensors are instantiated via `tensor = tf.keras.Input(shape)`.\nThe tensor that caused the issue was: ' + str(x.name))
    input_batch_sizes = [training_utils.get_static_batch_size(x._keras_history.layer) for x in self.inputs]
    consistent_batch_size = None
    for batch_size in input_batch_sizes:
        if batch_size is not None:
            if consistent_batch_size is not None and batch_size != consistent_batch_size:
                raise ValueError('The specified batch sizes of the Input Layers are incompatible. Found batch sizes: {}'.format(input_batch_sizes))
            consistent_batch_size = batch_size
    for x in self.outputs:
        if not hasattr(x, '_keras_history'):
            cls_name = self.__class__.__name__
            raise ValueError('Output tensors of a ' + cls_name + ' model must be the output of a TensorFlow `Layer` (thus holding past layer metadata). Found: ' + str(x))