import re
from .fastjsonschema_exceptions import JsonSchemaValueException
def validate_https___setuptools_pypa_io_en_latest_references_keywords_html(data, custom_formats={}, name_prefix=None):
    if not isinstance(data, dict):
        raise JsonSchemaValueException('' + (name_prefix or 'data') + ' must be object', value=data, name='' + (name_prefix or 'data') + '', definition={'$schema': 'http://json-schema.org/draft-07/schema', '$id': 'https://setuptools.pypa.io/en/latest/references/keywords.html', 'title': '``tool.setuptools`` table', '$$description': ['Please notice for the time being the ``setuptools`` project does not specify', 'a way of configuring builds via ``pyproject.toml``.', 'Therefore this schema should be taken just as a *"thought experiment"* on how', 'this *might be done*, by following the principles established in', '`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_', 'that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`', 'but intentionally excludes ``dependency_links`` and ``setup_requires``.', 'NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with', 'entry-point based scripts (defined in :pep:`621`).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'description': 'Whether the project can be safely installed and run from a zip file.', 'type': 'boolean'}, 'script-files': {'description': 'Legacy way of defining scripts (entry-points are preferred).', 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': "'find:' directive", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['**DEPRECATED**: dict-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', "Please notice this don't work with wheels. See `data files support", '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., "dotted" form with module), e.g.::\n\n', '    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['PROVISIONAL: List of glob patterns for all license files being distributed.', '(might become standard with PEP 639).', "By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.'], 'oneOf': [{'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, 'readme': {'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'attr-directive': {'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': "'find:' directive", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}, rule='type')
    data_is_dict = isinstance(data, dict)
    if data_is_dict:
        data_keys = set(data.keys())
        if 'platforms' in data_keys:
            data_keys.remove('platforms')
            data__platforms = data['platforms']
            if not isinstance(data__platforms, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.platforms must be array', value=data__platforms, name='' + (name_prefix or 'data') + '.platforms', definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')
            data__platforms_is_list = isinstance(data__platforms, (list, tuple))
            if data__platforms_is_list:
                data__platforms_len = len(data__platforms)
                for data__platforms_x, data__platforms_item in enumerate(data__platforms):
                    if not isinstance(data__platforms_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.platforms[{data__platforms_x}]'.format(**locals()) + ' must be string', value=data__platforms_item, name='' + (name_prefix or 'data') + '.platforms[{data__platforms_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'provides' in data_keys:
            data_keys.remove('provides')
            data__provides = data['provides']
            if not isinstance(data__provides, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.provides must be array', value=data__provides, name='' + (name_prefix or 'data') + '.provides', definition={'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, rule='type')
            data__provides_is_list = isinstance(data__provides, (list, tuple))
            if data__provides_is_list:
                data__provides_len = len(data__provides)
                for data__provides_x, data__provides_item in enumerate(data__provides):
                    if not isinstance(data__provides_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.provides[{data__provides_x}]'.format(**locals()) + ' must be string', value=data__provides_item, name='' + (name_prefix or 'data') + '.provides[{data__provides_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'pep508-identifier'}, rule='type')
                    if isinstance(data__provides_item, str):
                        if not custom_formats['pep508-identifier'](data__provides_item):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.provides[{data__provides_x}]'.format(**locals()) + ' must be pep508-identifier', value=data__provides_item, name='' + (name_prefix or 'data') + '.provides[{data__provides_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'pep508-identifier'}, rule='format')
        if 'obsoletes' in data_keys:
            data_keys.remove('obsoletes')
            data__obsoletes = data['obsoletes']
            if not isinstance(data__obsoletes, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.obsoletes must be array', value=data__obsoletes, name='' + (name_prefix or 'data') + '.obsoletes', definition={'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, rule='type')
            data__obsoletes_is_list = isinstance(data__obsoletes, (list, tuple))
            if data__obsoletes_is_list:
                data__obsoletes_len = len(data__obsoletes)
                for data__obsoletes_x, data__obsoletes_item in enumerate(data__obsoletes):
                    if not isinstance(data__obsoletes_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.obsoletes[{data__obsoletes_x}]'.format(**locals()) + ' must be string', value=data__obsoletes_item, name='' + (name_prefix or 'data') + '.obsoletes[{data__obsoletes_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'pep508-identifier'}, rule='type')
                    if isinstance(data__obsoletes_item, str):
                        if not custom_formats['pep508-identifier'](data__obsoletes_item):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.obsoletes[{data__obsoletes_x}]'.format(**locals()) + ' must be pep508-identifier', value=data__obsoletes_item, name='' + (name_prefix or 'data') + '.obsoletes[{data__obsoletes_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'pep508-identifier'}, rule='format')
        if 'zip-safe' in data_keys:
            data_keys.remove('zip-safe')
            data__zipsafe = data['zip-safe']
            if not isinstance(data__zipsafe, bool):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.zip-safe must be boolean', value=data__zipsafe, name='' + (name_prefix or 'data') + '.zip-safe', definition={'description': 'Whether the project can be safely installed and run from a zip file.', 'type': 'boolean'}, rule='type')
        if 'script-files' in data_keys:
            data_keys.remove('script-files')
            data__scriptfiles = data['script-files']
            if not isinstance(data__scriptfiles, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.script-files must be array', value=data__scriptfiles, name='' + (name_prefix or 'data') + '.script-files', definition={'description': 'Legacy way of defining scripts (entry-points are preferred).', 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, rule='type')
            data__scriptfiles_is_list = isinstance(data__scriptfiles, (list, tuple))
            if data__scriptfiles_is_list:
                data__scriptfiles_len = len(data__scriptfiles)
                for data__scriptfiles_x, data__scriptfiles_item in enumerate(data__scriptfiles):
                    if not isinstance(data__scriptfiles_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.script-files[{data__scriptfiles_x}]'.format(**locals()) + ' must be string', value=data__scriptfiles_item, name='' + (name_prefix or 'data') + '.script-files[{data__scriptfiles_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'eager-resources' in data_keys:
            data_keys.remove('eager-resources')
            data__eagerresources = data['eager-resources']
            if not isinstance(data__eagerresources, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.eager-resources must be array', value=data__eagerresources, name='' + (name_prefix or 'data') + '.eager-resources', definition={'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.'], 'type': 'array', 'items': {'type': 'string'}}, rule='type')
            data__eagerresources_is_list = isinstance(data__eagerresources, (list, tuple))
            if data__eagerresources_is_list:
                data__eagerresources_len = len(data__eagerresources)
                for data__eagerresources_x, data__eagerresources_item in enumerate(data__eagerresources):
                    if not isinstance(data__eagerresources_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.eager-resources[{data__eagerresources_x}]'.format(**locals()) + ' must be string', value=data__eagerresources_item, name='' + (name_prefix or 'data') + '.eager-resources[{data__eagerresources_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'packages' in data_keys:
            data_keys.remove('packages')
            data__packages = data['packages']
            data__packages_one_of_count1 = 0
            if data__packages_one_of_count1 < 2:
                try:
                    if not isinstance(data__packages, (list, tuple)):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.packages must be array', value=data__packages, name='' + (name_prefix or 'data') + '.packages', definition={'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}}, rule='type')
                    data__packages_is_list = isinstance(data__packages, (list, tuple))
                    if data__packages_is_list:
                        data__packages_len = len(data__packages)
                        for data__packages_x, data__packages_item in enumerate(data__packages):
                            validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_package_name(data__packages_item, custom_formats, (name_prefix or 'data') + '.packages[{data__packages_x}]'.format(**locals()))
                    data__packages_one_of_count1 += 1
                except JsonSchemaValueException:
                    pass
            if data__packages_one_of_count1 < 2:
                try:
                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_find_directive(data__packages, custom_formats, (name_prefix or 'data') + '.packages')
                    data__packages_one_of_count1 += 1
                except JsonSchemaValueException:
                    pass
            if data__packages_one_of_count1 != 1:
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.packages must be valid exactly by one definition' + (' (' + str(data__packages_one_of_count1) + ' matches found)'), value=data__packages, name='' + (name_prefix or 'data') + '.packages', definition={'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': "'find:' directive", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, rule='oneOf')
        if 'package-dir' in data_keys:
            data_keys.remove('package-dir')
            data__packagedir = data['package-dir']
            if not isinstance(data__packagedir, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir must be object', value=data__packagedir, name='' + (name_prefix or 'data') + '.package-dir', definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='type')
            data__packagedir_is_dict = isinstance(data__packagedir, dict)
            if data__packagedir_is_dict:
                data__packagedir_keys = set(data__packagedir.keys())
                for data__packagedir_key, data__packagedir_val in data__packagedir.items():
                    if REGEX_PATTERNS['^.*$'].search(data__packagedir_key):
                        if data__packagedir_key in data__packagedir_keys:
                            data__packagedir_keys.remove(data__packagedir_key)
                        if not isinstance(data__packagedir_val, str):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir.{data__packagedir_key}'.format(**locals()) + ' must be string', value=data__packagedir_val, name='' + (name_prefix or 'data') + '.package-dir.{data__packagedir_key}'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
                if data__packagedir_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir must not contain ' + str(data__packagedir_keys) + ' properties', value=data__packagedir, name='' + (name_prefix or 'data') + '.package-dir', definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='additionalProperties')
                data__packagedir_len = len(data__packagedir)
                if data__packagedir_len != 0:
                    data__packagedir_property_names = True
                    for data__packagedir_key in data__packagedir:
                        try:
                            data__packagedir_key_one_of_count2 = 0
                            if data__packagedir_key_one_of_count2 < 2:
                                try:
                                    if data__packagedir_key != '':
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir must be same as const definition: ', value=data__packagedir_key, name='' + (name_prefix or 'data') + '.package-dir', definition={'const': ''}, rule='const')
                                    data__packagedir_key_one_of_count2 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__packagedir_key_one_of_count2 < 2:
                                try:
                                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_package_name(data__packagedir_key, custom_formats, (name_prefix or 'data') + '.package-dir')
                                    data__packagedir_key_one_of_count2 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__packagedir_key_one_of_count2 != 1:
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir must be valid exactly by one definition' + (' (' + str(data__packagedir_key_one_of_count2) + ' matches found)'), value=data__packagedir_key, name='' + (name_prefix or 'data') + '.package-dir', definition={'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, rule='oneOf')
                        except JsonSchemaValueException:
                            data__packagedir_property_names = False
                    if not data__packagedir_property_names:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-dir must be named by propertyName definition', value=data__packagedir, name='' + (name_prefix or 'data') + '.package-dir', definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='propertyNames')
        if 'package-data' in data_keys:
            data_keys.remove('package-data')
            data__packagedata = data['package-data']
            if not isinstance(data__packagedata, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must be object', value=data__packagedata, name='' + (name_prefix or 'data') + '.package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')
            data__packagedata_is_dict = isinstance(data__packagedata, dict)
            if data__packagedata_is_dict:
                data__packagedata_keys = set(data__packagedata.keys())
                for data__packagedata_key, data__packagedata_val in data__packagedata.items():
                    if REGEX_PATTERNS['^.*$'].search(data__packagedata_key):
                        if data__packagedata_key in data__packagedata_keys:
                            data__packagedata_keys.remove(data__packagedata_key)
                        if not isinstance(data__packagedata_val, (list, tuple)):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data.{data__packagedata_key}'.format(**locals()) + ' must be array', value=data__packagedata_val, name='' + (name_prefix or 'data') + '.package-data.{data__packagedata_key}'.format(**locals()) + '', definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')
                        data__packagedata_val_is_list = isinstance(data__packagedata_val, (list, tuple))
                        if data__packagedata_val_is_list:
                            data__packagedata_val_len = len(data__packagedata_val)
                            for data__packagedata_val_x, data__packagedata_val_item in enumerate(data__packagedata_val):
                                if not isinstance(data__packagedata_val_item, str):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data.{data__packagedata_key}[{data__packagedata_val_x}]'.format(**locals()) + ' must be string', value=data__packagedata_val_item, name='' + (name_prefix or 'data') + '.package-data.{data__packagedata_key}[{data__packagedata_val_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
                if data__packagedata_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must not contain ' + str(data__packagedata_keys) + ' properties', value=data__packagedata, name='' + (name_prefix or 'data') + '.package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='additionalProperties')
                data__packagedata_len = len(data__packagedata)
                if data__packagedata_len != 0:
                    data__packagedata_property_names = True
                    for data__packagedata_key in data__packagedata:
                        try:
                            data__packagedata_key_one_of_count3 = 0
                            if data__packagedata_key_one_of_count3 < 2:
                                try:
                                    if isinstance(data__packagedata_key, str):
                                        if not custom_formats['python-module-name'](data__packagedata_key):
                                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must be python-module-name', value=data__packagedata_key, name='' + (name_prefix or 'data') + '.package-data', definition={'format': 'python-module-name'}, rule='format')
                                    data__packagedata_key_one_of_count3 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__packagedata_key_one_of_count3 < 2:
                                try:
                                    if data__packagedata_key != '*':
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must be same as const definition: *', value=data__packagedata_key, name='' + (name_prefix or 'data') + '.package-data', definition={'const': '*'}, rule='const')
                                    data__packagedata_key_one_of_count3 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__packagedata_key_one_of_count3 != 1:
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must be valid exactly by one definition' + (' (' + str(data__packagedata_key_one_of_count3) + ' matches found)'), value=data__packagedata_key, name='' + (name_prefix or 'data') + '.package-data', definition={'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, rule='oneOf')
                        except JsonSchemaValueException:
                            data__packagedata_property_names = False
                    if not data__packagedata_property_names:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.package-data must be named by propertyName definition', value=data__packagedata, name='' + (name_prefix or 'data') + '.package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='propertyNames')
        if 'include-package-data' in data_keys:
            data_keys.remove('include-package-data')
            data__includepackagedata = data['include-package-data']
            if not isinstance(data__includepackagedata, bool):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.include-package-data must be boolean', value=data__includepackagedata, name='' + (name_prefix or 'data') + '.include-package-data', definition={'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, rule='type')
        if 'exclude-package-data' in data_keys:
            data_keys.remove('exclude-package-data')
            data__excludepackagedata = data['exclude-package-data']
            if not isinstance(data__excludepackagedata, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must be object', value=data__excludepackagedata, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')
            data__excludepackagedata_is_dict = isinstance(data__excludepackagedata, dict)
            if data__excludepackagedata_is_dict:
                data__excludepackagedata_keys = set(data__excludepackagedata.keys())
                for data__excludepackagedata_key, data__excludepackagedata_val in data__excludepackagedata.items():
                    if REGEX_PATTERNS['^.*$'].search(data__excludepackagedata_key):
                        if data__excludepackagedata_key in data__excludepackagedata_keys:
                            data__excludepackagedata_keys.remove(data__excludepackagedata_key)
                        if not isinstance(data__excludepackagedata_val, (list, tuple)):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data.{data__excludepackagedata_key}'.format(**locals()) + ' must be array', value=data__excludepackagedata_val, name='' + (name_prefix or 'data') + '.exclude-package-data.{data__excludepackagedata_key}'.format(**locals()) + '', definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')
                        data__excludepackagedata_val_is_list = isinstance(data__excludepackagedata_val, (list, tuple))
                        if data__excludepackagedata_val_is_list:
                            data__excludepackagedata_val_len = len(data__excludepackagedata_val)
                            for data__excludepackagedata_val_x, data__excludepackagedata_val_item in enumerate(data__excludepackagedata_val):
                                if not isinstance(data__excludepackagedata_val_item, str):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]'.format(**locals()) + ' must be string', value=data__excludepackagedata_val_item, name='' + (name_prefix or 'data') + '.exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
                if data__excludepackagedata_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must not contain ' + str(data__excludepackagedata_keys) + ' properties', value=data__excludepackagedata, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='additionalProperties')
                data__excludepackagedata_len = len(data__excludepackagedata)
                if data__excludepackagedata_len != 0:
                    data__excludepackagedata_property_names = True
                    for data__excludepackagedata_key in data__excludepackagedata:
                        try:
                            data__excludepackagedata_key_one_of_count4 = 0
                            if data__excludepackagedata_key_one_of_count4 < 2:
                                try:
                                    if isinstance(data__excludepackagedata_key, str):
                                        if not custom_formats['python-module-name'](data__excludepackagedata_key):
                                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must be python-module-name', value=data__excludepackagedata_key, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'format': 'python-module-name'}, rule='format')
                                    data__excludepackagedata_key_one_of_count4 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__excludepackagedata_key_one_of_count4 < 2:
                                try:
                                    if data__excludepackagedata_key != '*':
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must be same as const definition: *', value=data__excludepackagedata_key, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'const': '*'}, rule='const')
                                    data__excludepackagedata_key_one_of_count4 += 1
                                except JsonSchemaValueException:
                                    pass
                            if data__excludepackagedata_key_one_of_count4 != 1:
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must be valid exactly by one definition' + (' (' + str(data__excludepackagedata_key_one_of_count4) + ' matches found)'), value=data__excludepackagedata_key, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, rule='oneOf')
                        except JsonSchemaValueException:
                            data__excludepackagedata_property_names = False
                    if not data__excludepackagedata_property_names:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.exclude-package-data must be named by propertyName definition', value=data__excludepackagedata, name='' + (name_prefix or 'data') + '.exclude-package-data', definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='propertyNames')
        if 'namespace-packages' in data_keys:
            data_keys.remove('namespace-packages')
            data__namespacepackages = data['namespace-packages']
            if not isinstance(data__namespacepackages, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.namespace-packages must be array', value=data__namespacepackages, name='' + (name_prefix or 'data') + '.namespace-packages', definition={'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html'}, rule='type')
            data__namespacepackages_is_list = isinstance(data__namespacepackages, (list, tuple))
            if data__namespacepackages_is_list:
                data__namespacepackages_len = len(data__namespacepackages)
                for data__namespacepackages_x, data__namespacepackages_item in enumerate(data__namespacepackages):
                    if not isinstance(data__namespacepackages_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.namespace-packages[{data__namespacepackages_x}]'.format(**locals()) + ' must be string', value=data__namespacepackages_item, name='' + (name_prefix or 'data') + '.namespace-packages[{data__namespacepackages_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-module-name'}, rule='type')
                    if isinstance(data__namespacepackages_item, str):
                        if not custom_formats['python-module-name'](data__namespacepackages_item):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.namespace-packages[{data__namespacepackages_x}]'.format(**locals()) + ' must be python-module-name', value=data__namespacepackages_item, name='' + (name_prefix or 'data') + '.namespace-packages[{data__namespacepackages_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-module-name'}, rule='format')
        if 'py-modules' in data_keys:
            data_keys.remove('py-modules')
            data__pymodules = data['py-modules']
            if not isinstance(data__pymodules, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.py-modules must be array', value=data__pymodules, name='' + (name_prefix or 'data') + '.py-modules', definition={'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, rule='type')
            data__pymodules_is_list = isinstance(data__pymodules, (list, tuple))
            if data__pymodules_is_list:
                data__pymodules_len = len(data__pymodules)
                for data__pymodules_x, data__pymodules_item in enumerate(data__pymodules):
                    if not isinstance(data__pymodules_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.py-modules[{data__pymodules_x}]'.format(**locals()) + ' must be string', value=data__pymodules_item, name='' + (name_prefix or 'data') + '.py-modules[{data__pymodules_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-module-name'}, rule='type')
                    if isinstance(data__pymodules_item, str):
                        if not custom_formats['python-module-name'](data__pymodules_item):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.py-modules[{data__pymodules_x}]'.format(**locals()) + ' must be python-module-name', value=data__pymodules_item, name='' + (name_prefix or 'data') + '.py-modules[{data__pymodules_x}]'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-module-name'}, rule='format')
        if 'data-files' in data_keys:
            data_keys.remove('data-files')
            data__datafiles = data['data-files']
            if not isinstance(data__datafiles, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.data-files must be object', value=data__datafiles, name='' + (name_prefix or 'data') + '.data-files', definition={'$$description': ['**DEPRECATED**: dict-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', "Please notice this don't work with wheels. See `data files support", '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')
            data__datafiles_is_dict = isinstance(data__datafiles, dict)
            if data__datafiles_is_dict:
                data__datafiles_keys = set(data__datafiles.keys())
                for data__datafiles_key, data__datafiles_val in data__datafiles.items():
                    if REGEX_PATTERNS['^.*$'].search(data__datafiles_key):
                        if data__datafiles_key in data__datafiles_keys:
                            data__datafiles_keys.remove(data__datafiles_key)
                        if not isinstance(data__datafiles_val, (list, tuple)):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.data-files.{data__datafiles_key}'.format(**locals()) + ' must be array', value=data__datafiles_val, name='' + (name_prefix or 'data') + '.data-files.{data__datafiles_key}'.format(**locals()) + '', definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')
                        data__datafiles_val_is_list = isinstance(data__datafiles_val, (list, tuple))
                        if data__datafiles_val_is_list:
                            data__datafiles_val_len = len(data__datafiles_val)
                            for data__datafiles_val_x, data__datafiles_val_item in enumerate(data__datafiles_val):
                                if not isinstance(data__datafiles_val_item, str):
                                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.data-files.{data__datafiles_key}[{data__datafiles_val_x}]'.format(**locals()) + ' must be string', value=data__datafiles_val_item, name='' + (name_prefix or 'data') + '.data-files.{data__datafiles_key}[{data__datafiles_val_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'cmdclass' in data_keys:
            data_keys.remove('cmdclass')
            data__cmdclass = data['cmdclass']
            if not isinstance(data__cmdclass, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.cmdclass must be object', value=data__cmdclass, name='' + (name_prefix or 'data') + '.cmdclass', definition={'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., "dotted" form with module), e.g.::\n\n', '    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, rule='type')
            data__cmdclass_is_dict = isinstance(data__cmdclass, dict)
            if data__cmdclass_is_dict:
                data__cmdclass_keys = set(data__cmdclass.keys())
                for data__cmdclass_key, data__cmdclass_val in data__cmdclass.items():
                    if REGEX_PATTERNS['^.*$'].search(data__cmdclass_key):
                        if data__cmdclass_key in data__cmdclass_keys:
                            data__cmdclass_keys.remove(data__cmdclass_key)
                        if not isinstance(data__cmdclass_val, str):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.cmdclass.{data__cmdclass_key}'.format(**locals()) + ' must be string', value=data__cmdclass_val, name='' + (name_prefix or 'data') + '.cmdclass.{data__cmdclass_key}'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='type')
                        if isinstance(data__cmdclass_val, str):
                            if not custom_formats['python-qualified-identifier'](data__cmdclass_val):
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.cmdclass.{data__cmdclass_key}'.format(**locals()) + ' must be python-qualified-identifier', value=data__cmdclass_val, name='' + (name_prefix or 'data') + '.cmdclass.{data__cmdclass_key}'.format(**locals()) + '', definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='format')
        if 'license-files' in data_keys:
            data_keys.remove('license-files')
            data__licensefiles = data['license-files']
            if not isinstance(data__licensefiles, (list, tuple)):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.license-files must be array', value=data__licensefiles, name='' + (name_prefix or 'data') + '.license-files', definition={'type': 'array', 'items': {'type': 'string'}, '$$description': ['PROVISIONAL: List of glob patterns for all license files being distributed.', '(might become standard with PEP 639).', "By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, rule='type')
            data__licensefiles_is_list = isinstance(data__licensefiles, (list, tuple))
            if data__licensefiles_is_list:
                data__licensefiles_len = len(data__licensefiles)
                for data__licensefiles_x, data__licensefiles_item in enumerate(data__licensefiles):
                    if not isinstance(data__licensefiles_item, str):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.license-files[{data__licensefiles_x}]'.format(**locals()) + ' must be string', value=data__licensefiles_item, name='' + (name_prefix or 'data') + '.license-files[{data__licensefiles_x}]'.format(**locals()) + '', definition={'type': 'string'}, rule='type')
        if 'dynamic' in data_keys:
            data_keys.remove('dynamic')
            data__dynamic = data['dynamic']
            if not isinstance(data__dynamic, dict):
                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic must be object', value=data__dynamic, name='' + (name_prefix or 'data') + '.dynamic', definition={'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.'], 'oneOf': [{'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, 'readme': {'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}}}, rule='type')
            data__dynamic_is_dict = isinstance(data__dynamic, dict)
            if data__dynamic_is_dict:
                data__dynamic_keys = set(data__dynamic.keys())
                if 'version' in data__dynamic_keys:
                    data__dynamic_keys.remove('version')
                    data__dynamic__version = data__dynamic['version']
                    data__dynamic__version_one_of_count5 = 0
                    if data__dynamic__version_one_of_count5 < 2:
                        try:
                            validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_attr_directive(data__dynamic__version, custom_formats, (name_prefix or 'data') + '.dynamic.version')
                            data__dynamic__version_one_of_count5 += 1
                        except JsonSchemaValueException:
                            pass
                    if data__dynamic__version_one_of_count5 < 2:
                        try:
                            validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__version, custom_formats, (name_prefix or 'data') + '.dynamic.version')
                            data__dynamic__version_one_of_count5 += 1
                        except JsonSchemaValueException:
                            pass
                    if data__dynamic__version_one_of_count5 != 1:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.version must be valid exactly by one definition' + (' (' + str(data__dynamic__version_one_of_count5) + ' matches found)'), value=data__dynamic__version, name='' + (name_prefix or 'data') + '.dynamic.version', definition={'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.'], 'oneOf': [{'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, rule='oneOf')
                if 'classifiers' in data__dynamic_keys:
                    data__dynamic_keys.remove('classifiers')
                    data__dynamic__classifiers = data__dynamic['classifiers']
                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__classifiers, custom_formats, (name_prefix or 'data') + '.dynamic.classifiers')
                if 'description' in data__dynamic_keys:
                    data__dynamic_keys.remove('description')
                    data__dynamic__description = data__dynamic['description']
                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__description, custom_formats, (name_prefix or 'data') + '.dynamic.description')
                if 'dependencies' in data__dynamic_keys:
                    data__dynamic_keys.remove('dependencies')
                    data__dynamic__dependencies = data__dynamic['dependencies']
                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__dependencies, custom_formats, (name_prefix or 'data') + '.dynamic.dependencies')
                if 'entry-points' in data__dynamic_keys:
                    data__dynamic_keys.remove('entry-points')
                    data__dynamic__entrypoints = data__dynamic['entry-points']
                    validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__entrypoints, custom_formats, (name_prefix or 'data') + '.dynamic.entry-points')
                if 'optional-dependencies' in data__dynamic_keys:
                    data__dynamic_keys.remove('optional-dependencies')
                    data__dynamic__optionaldependencies = data__dynamic['optional-dependencies']
                    if not isinstance(data__dynamic__optionaldependencies, dict):
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.optional-dependencies must be object', value=data__dynamic__optionaldependencies, name='' + (name_prefix or 'data') + '.dynamic.optional-dependencies', definition={'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, rule='type')
                    data__dynamic__optionaldependencies_is_dict = isinstance(data__dynamic__optionaldependencies, dict)
                    if data__dynamic__optionaldependencies_is_dict:
                        data__dynamic__optionaldependencies_keys = set(data__dynamic__optionaldependencies.keys())
                        for data__dynamic__optionaldependencies_key, data__dynamic__optionaldependencies_val in data__dynamic__optionaldependencies.items():
                            if REGEX_PATTERNS['.+'].search(data__dynamic__optionaldependencies_key):
                                if data__dynamic__optionaldependencies_key in data__dynamic__optionaldependencies_keys:
                                    data__dynamic__optionaldependencies_keys.remove(data__dynamic__optionaldependencies_key)
                                validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__optionaldependencies_val, custom_formats, (name_prefix or 'data') + '.dynamic.optional-dependencies.{data__dynamic__optionaldependencies_key}'.format(**locals()))
                        if data__dynamic__optionaldependencies_keys:
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.optional-dependencies must not contain ' + str(data__dynamic__optionaldependencies_keys) + ' properties', value=data__dynamic__optionaldependencies, name='' + (name_prefix or 'data') + '.dynamic.optional-dependencies', definition={'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, rule='additionalProperties')
                        data__dynamic__optionaldependencies_len = len(data__dynamic__optionaldependencies)
                        if data__dynamic__optionaldependencies_len != 0:
                            data__dynamic__optionaldependencies_property_names = True
                            for data__dynamic__optionaldependencies_key in data__dynamic__optionaldependencies:
                                try:
                                    if isinstance(data__dynamic__optionaldependencies_key, str):
                                        if not custom_formats['python-identifier'](data__dynamic__optionaldependencies_key):
                                            raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.optional-dependencies must be python-identifier', value=data__dynamic__optionaldependencies_key, name='' + (name_prefix or 'data') + '.dynamic.optional-dependencies', definition={'format': 'python-identifier'}, rule='format')
                                except JsonSchemaValueException:
                                    data__dynamic__optionaldependencies_property_names = False
                            if not data__dynamic__optionaldependencies_property_names:
                                raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.optional-dependencies must be named by propertyName definition', value=data__dynamic__optionaldependencies, name='' + (name_prefix or 'data') + '.dynamic.optional-dependencies', definition={'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, rule='propertyNames')
                if 'readme' in data__dynamic_keys:
                    data__dynamic_keys.remove('readme')
                    data__dynamic__readme = data__dynamic['readme']
                    data__dynamic__readme_any_of_count6 = 0
                    if not data__dynamic__readme_any_of_count6:
                        try:
                            validate_https___setuptools_pypa_io_en_latest_references_keywords_html__definitions_file_directive(data__dynamic__readme, custom_formats, (name_prefix or 'data') + '.dynamic.readme')
                            data__dynamic__readme_any_of_count6 += 1
                        except JsonSchemaValueException:
                            pass
                    if not data__dynamic__readme_any_of_count6:
                        try:
                            data__dynamic__readme_is_dict = isinstance(data__dynamic__readme, dict)
                            if data__dynamic__readme_is_dict:
                                data__dynamic__readme_keys = set(data__dynamic__readme.keys())
                                if 'content-type' in data__dynamic__readme_keys:
                                    data__dynamic__readme_keys.remove('content-type')
                                    data__dynamic__readme__contenttype = data__dynamic__readme['content-type']
                                    if not isinstance(data__dynamic__readme__contenttype, str):
                                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.readme.content-type must be string', value=data__dynamic__readme__contenttype, name='' + (name_prefix or 'data') + '.dynamic.readme.content-type', definition={'type': 'string'}, rule='type')
                            data__dynamic__readme_any_of_count6 += 1
                        except JsonSchemaValueException:
                            pass
                    if not data__dynamic__readme_any_of_count6:
                        raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic.readme cannot be validated by any definition', value=data__dynamic__readme, name='' + (name_prefix or 'data') + '.dynamic.readme', definition={'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}, rule='anyOf')
                    data__dynamic__readme_is_dict = isinstance(data__dynamic__readme, dict)
                    if data__dynamic__readme_is_dict:
                        data__dynamic__readme_len = len(data__dynamic__readme)
                        if not all((prop in data__dynamic__readme for prop in ['file'])):
                            raise JsonSchemaValueException('' + (name_prefix or 'data') + ".dynamic.readme must contain ['file'] properties", value=data__dynamic__readme, name='' + (name_prefix or 'data') + '.dynamic.readme', definition={'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}, rule='required')
                if data__dynamic_keys:
                    raise JsonSchemaValueException('' + (name_prefix or 'data') + '.dynamic must not contain ' + str(data__dynamic_keys) + ' properties', value=data__dynamic, name='' + (name_prefix or 'data') + '.dynamic', definition={'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.'], 'oneOf': [{'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, 'readme': {'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}}}, rule='additionalProperties')
        if data_keys:
            raise JsonSchemaValueException('' + (name_prefix or 'data') + ' must not contain ' + str(data_keys) + ' properties', value=data, name='' + (name_prefix or 'data') + '', definition={'$schema': 'http://json-schema.org/draft-07/schema', '$id': 'https://setuptools.pypa.io/en/latest/references/keywords.html', 'title': '``tool.setuptools`` table', '$$description': ['Please notice for the time being the ``setuptools`` project does not specify', 'a way of configuring builds via ``pyproject.toml``.', 'Therefore this schema should be taken just as a *"thought experiment"* on how', 'this *might be done*, by following the principles established in', '`ini2toml <https://ini2toml.readthedocs.io/en/latest/setuptools_pep621.html>`_.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`_', 'that can currently be configured via ``setup.cfg`` and are not covered by :pep:`621`', 'but intentionally excludes ``dependency_links`` and ``setup_requires``.', 'NOTE: ``scripts`` was renamed to ``script-files`` to avoid confusion with', 'entry-point based scripts (defined in :pep:`621`).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'description': 'Whether the project can be safely installed and run from a zip file.', 'type': 'boolean'}, 'script-files': {'description': 'Legacy way of defining scripts (entry-points are preferred).', 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': "'find:' directive", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'oneOf': [{'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['**DEPRECATED**: dict-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', "Please notice this don't work with wheels. See `data files support", '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., "dotted" form with module), e.g.::\n\n', '    cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['PROVISIONAL: List of glob patterns for all license files being distributed.', '(might become standard with PEP 639).', "By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.'], 'oneOf': [{'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'format': 'python-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}}}, 'readme': {'anyOf': [{'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'properties': {'content-type': {'type': 'string'}}}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or PEP 561).', 'type': 'string', 'anyOf': [{'format': 'python-module-name'}, {'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': "'file:' directive", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'attr-directive': {'title': "'attr:' directive", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': "'find:' directive", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', "Can container shell-style wildcards (e.g. ``'pkg.*'``)"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}, rule='additionalProperties')
    return data