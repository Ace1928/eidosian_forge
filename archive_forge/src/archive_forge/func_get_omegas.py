import warnings
from typing import Sequence, Callable
import numpy as np
from scipy.sparse.linalg import expm
import pennylane as qml
from pennylane import transform
from pennylane.tape import QuantumTape
from pennylane.queuing import QueuingManager
def get_omegas(self):
    """Measure the coefficients of the Riemannian gradient with respect to a Pauli word basis.
        We want to calculate the components of the Riemannian gradient in the Lie algebra
        with respect to a Pauli word basis. For a Hamiltonian of the form :math:`H = \\sum_i c_i O_i`,
        where :math:`c_i\\in\\mathbb{R}`, this can be achieved by calculating

        .. math::

            \\omega_{i,j} = \\text{Tr}(c_i[\\rho, O_i] P_j)

        where :math:`P_j` is a Pauli word in the set of Pauli monomials on :math:`N` qubits.

        Via the parameter shift rule, the commutator can be calculated as

        .. math::

            [\\rho, O_i] = \\frac{1}{2}(V(\\pi/2) \\rho V^\\dagger(\\pi/2) - V(-\\pi/2) \\rho V^\\dagger(-\\pi/2))

        where :math:`V` is the unitary generated by the Pauli word :math:`V(\\theta) = \\exp\\{-i\\theta P_j\\}`.

        Returns:
            array: array of omegas for each direction in the Lie algebra.
        """
    obs_groupings, _ = qml.pauli.group_observables(self.observables, self.coeffs)
    circuits = algebra_commutator(self.circuit.qtape, obs_groupings, self.lie_algebra_basis_names, self.nqubits)
    if isinstance(self.circuit.device, qml.devices.Device):
        program, config = self.circuit.device.preprocess()
        circuits = qml.execute(circuits, self.circuit.device, transform_program=program, config=config, gradient_fn=None)
    else:
        circuits = qml.execute(circuits, self.circuit.device, gradient_fn=None)
    program, _ = self.circuit.device.preprocess()
    circuits_plus = np.array(circuits[:len(circuits) // 2]).reshape(len(self.coeffs), len(self.lie_algebra_basis_names))
    circuits_min = np.array(circuits[len(circuits) // 2:]).reshape(len(self.coeffs), len(self.lie_algebra_basis_names))
    omegas = circuits_plus - circuits_min
    return np.dot(self.coeffs, omegas)