import os
from ...base import (
class dtiprocessInputSpec(CommandLineInputSpec):
    dti_image = File(desc='DTI tensor volume', exists=True, argstr='--dti_image %s')
    fa_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Fractional Anisotropy output file', argstr='--fa_output %s')
    md_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Mean Diffusivity output file', argstr='--md_output %s')
    sigma = traits.Float(desc='Scale of gradients', argstr='--sigma %f')
    fa_gradient_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Fractional Anisotropy Gradient output file', argstr='--fa_gradient_output %s')
    fa_gradmag_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Fractional Anisotropy Gradient Magnitude output file', argstr='--fa_gradmag_output %s')
    color_fa_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Color Fractional Anisotropy output file', argstr='--color_fa_output %s')
    principal_eigenvector_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Principal Eigenvectors Output', argstr='--principal_eigenvector_output %s')
    negative_eigenvector_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Negative Eigenvectors Output: create a binary image where if any of the eigen value is below zero, the voxel is set to 1, otherwise 0.', argstr='--negative_eigenvector_output %s')
    frobenius_norm_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Frobenius Norm Output', argstr='--frobenius_norm_output %s')
    lambda1_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Axial Diffusivity - Lambda 1 (largest eigenvalue) output', argstr='--lambda1_output %s')
    lambda2_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Lambda 2 (middle eigenvalue) output', argstr='--lambda2_output %s')
    lambda3_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Lambda 3 (smallest eigenvalue) output', argstr='--lambda3_output %s')
    RD_output = traits.Either(traits.Bool, File(), hash_files=False, desc='RD (Radial Diffusivity 1/2*(lambda2+lambda3)) output', argstr='--RD_output %s')
    rot_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Rotated tensor output file.  Must also specify the dof file.', argstr='--rot_output %s')
    affineitk_file = File(desc='Transformation file for affine transformation.  ITK format.', exists=True, argstr='--affineitk_file %s')
    dof_file = File(desc='Transformation file for affine transformation.  This can be ITK format (or the outdated RView).', exists=True, argstr='--dof_file %s')
    newdof_file = File(desc='Transformation file for affine transformation.  RView NEW format. (txt file output of dof2mat)', exists=True, argstr='--newdof_file %s')
    mask = File(desc='Mask tensors. Specify --outmask if you want to save the masked tensor field, otherwise the mask is applied just for the current processing ', exists=True, argstr='--mask %s')
    outmask = traits.Either(traits.Bool, File(), hash_files=False, desc='Name of the masked tensor field.', argstr='--outmask %s')
    hField = traits.Bool(desc='forward and inverse transformations are h-fields instead of displacement fields', argstr='--hField ')
    forward = File(desc='Forward transformation.  Assumed to be a deformation field in world coordinates, unless the --h-field option is specified.', exists=True, argstr='--forward %s')
    deformation_output = traits.Either(traits.Bool, File(), hash_files=False, desc='Warped tensor field based on a deformation field.  This option requires the --forward,-F transformation to be specified.', argstr='--deformation_output %s')
    interpolation = traits.Enum('nearestneighbor', 'linear', 'cubic', desc='Interpolation type (nearestneighbor, linear, cubic)', argstr='--interpolation %s')
    reorientation = traits.Enum('fs', 'ppd', desc='Reorientation type (fs, ppd)', argstr='--reorientation %s')
    correction = traits.Enum('none', 'zero', 'abs', 'nearest', desc='Correct the tensors if computed tensor is not semi-definite positive', argstr='--correction %s')
    scalar_float = traits.Bool(desc='Write scalar [FA,MD] as unscaled float (with their actual values, otherwise scaled by 10 000).  Also causes FA to be unscaled [0..1].', argstr='--scalar_float ')
    DTI_double = traits.Bool(desc='Tensor components are saved as doubles (cannot be visualized in Slicer)', argstr='--DTI_double ')
    verbose = traits.Bool(desc='produce verbose output', argstr='--verbose ')