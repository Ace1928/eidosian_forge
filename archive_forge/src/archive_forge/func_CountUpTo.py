import itertools
def CountUpTo(nItems, nSlots, vs, idx=0, startAt=0):
    """ Figures out where a given combination of indices would
     occur in the combinatorial explosion generated by _GetIndexCombinations_

     **Arguments**

       - nItems: the number of items to distribute

       - nSlots: the number of slots in which to distribute them

       - vs: a sequence containing the values to find

       - idx: used in the recursion

       - startAt: used in the recursion

    **Returns**

       an integer

    """
    global _countCache
    if _verbose:
        print('  ' * idx, f'CountUpTo({idx})', vs[idx], startAt)
    if idx == 0 and (nItems, nSlots, tuple(vs)) in _countCache:
        return _countCache[nItems, nSlots, tuple(vs)]
    elif idx >= nSlots:
        accum = 0
    elif idx == nSlots - 1:
        accum = vs[idx] - startAt
    else:
        accum = 0
        for i in range(startAt, vs[idx]):
            nLevsUnder = nSlots - idx - 1
            nValsOver = nItems - i
            numCombs = NumCombinations(nValsOver, nLevsUnder)
            if _verbose:
                print('  ' * idx, ' ', i, nValsOver, nLevsUnder, numCombs)
            accum += numCombs
        accum += CountUpTo(nItems, nSlots, vs, idx + 1, vs[idx])
    if _verbose:
        print('  ' * idx, '>', accum)
    if idx == 0:
        _countCache[nItems, nSlots, tuple(vs)] = accum
    return accum