from collections import Counter
import sys
import warnings
from time import time
from .apis import LpSolverDefault, PULP_CBC_CMD
from .apis.core import clock
from .utilities import value
from . import constants as const
from . import mps_lp as mpslp
import logging
import re
class FixedElasticSubProblem(LpProblem):
    """
    Contains the subproblem generated by converting a fixed constraint
    :math:`\\sum_{i}a_i x_i = b` into an elastic constraint.

    :param constraint: The LpConstraint that the elastic constraint is based on
    :param penalty: penalty applied for violation (+ve or -ve) of the constraints
    :param proportionFreeBound:
        the proportional bound (+ve and -ve) on
        constraint violation that is free from penalty
    :param proportionFreeBoundList: the proportional bound on         constraint violation that is free from penalty, expressed as a list        where [-ve, +ve]
    """

    def __init__(self, constraint, penalty=None, proportionFreeBound=None, proportionFreeBoundList=None):
        subProblemName = f'{constraint.name}_elastic_SubProblem'
        LpProblem.__init__(self, subProblemName, const.LpMinimize)
        self.objective = LpAffineExpression()
        self.constraint = constraint
        self.constant = constraint.constant
        self.RHS = -constraint.constant
        self.objective = LpAffineExpression()
        self += (constraint, '_Constraint')
        self.freeVar = LpVariable('_free_bound', upBound=0, lowBound=0)
        self.upVar = LpVariable('_pos_penalty_var', upBound=0, lowBound=0)
        self.lowVar = LpVariable('_neg_penalty_var', upBound=0, lowBound=0)
        constraint.addInPlace(self.freeVar + self.lowVar + self.upVar)
        if proportionFreeBound:
            proportionFreeBoundList = [proportionFreeBound, proportionFreeBound]
        if proportionFreeBoundList:
            self.freeVar.upBound = abs(constraint.constant * proportionFreeBoundList[0])
            self.freeVar.lowBound = -abs(constraint.constant * proportionFreeBoundList[1])
        if penalty is not None:
            self.upVar.upBound = None
            self.lowVar.lowBound = None
            self.objective = penalty * self.upVar - penalty * self.lowVar

    def _findValue(self, attrib):
        """
        safe way to get the value of a variable that may not exist
        """
        var = getattr(self, attrib, 0)
        if var:
            if value(var) is not None:
                return value(var)
            else:
                return 0.0
        else:
            return 0.0

    def isViolated(self):
        """
        returns true if the penalty variables are non-zero
        """
        upVar = self._findValue('upVar')
        lowVar = self._findValue('lowVar')
        freeVar = self._findValue('freeVar')
        result = abs(upVar + lowVar) >= const.EPS
        if result:
            log.debug('isViolated %s, upVar %s, lowVar %s, freeVar %s result %s' % (self.name, upVar, lowVar, freeVar, result))
            log.debug(f'isViolated value lhs {self.findLHSValue()} constant {self.RHS}')
        return result

    def findDifferenceFromRHS(self):
        """
        The amount the actual value varies from the RHS (sense: LHS - RHS)
        """
        return self.findLHSValue() - self.RHS

    def findLHSValue(self):
        """
        for elastic constraints finds the LHS value of the constraint without
        the free variable and or penalty variable assumes the constant is on the
        rhs
        """
        upVar = self._findValue('upVar')
        lowVar = self._findValue('lowVar')
        freeVar = self._findValue('freeVar')
        return self.constraint.value() - self.constant - upVar - lowVar - freeVar

    def deElasticize(self):
        """de-elasticize constraint"""
        self.upVar.upBound = 0
        self.lowVar.lowBound = 0

    def reElasticize(self):
        """
        Make the Subproblem elastic again after deElasticize
        """
        self.upVar.lowBound = 0
        self.upVar.upBound = None
        self.lowVar.upBound = 0
        self.lowVar.lowBound = None

    def alterName(self, name):
        """
        Alters the name of anonymous parts of the problem

        """
        self.name = f'{name}_elastic_SubProblem'
        if hasattr(self, 'freeVar'):
            self.freeVar.name = self.name + '_free_bound'
        if hasattr(self, 'upVar'):
            self.upVar.name = self.name + '_pos_penalty_var'
        if hasattr(self, 'lowVar'):
            self.lowVar.name = self.name + '_neg_penalty_var'