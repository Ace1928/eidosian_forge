from __future__ import absolute_import, division, print_function
import re
from ansible_collections.ansible.netcommon.plugins.module_utils.network.common.rm_base.network_template import (
class Static_routesTemplate(NetworkTemplate):

    def __init__(self, lines=None, module=None):
        super(Static_routesTemplate, self).__init__(lines=lines, tmplt=self, module=module)
    PARSERS = [{'name': 'ipv4', 'getval': re.compile('\n                ^ip\\sroute\n                (\\stopology\\s(?P<topology>\\S+))?\n                (\\svrf\\s(?P<vrf>\\S+))?\n                (\\s(?P<dest>\\S+))\n                (\\s(?P<netmask>\\S+))\n                (\\s(?P<interface>(ACR|ATM-ACR|Analysis-Module|AppNav-Compress|AppNav-UnCompress|Async|Auto-Template|BD-VIF|BDI|BVI|Bluetooth|CDMA-Ix|CEM-ACR|CEM-PG|CTunnel|Container|Dialer|EsconPhy|Ethernet-Internal|Fcpa|Filter|Filtergroup|GigabitEthernet|IMA-ACR|LongReachEthernet|Loopback|Lspvif|MFR|Multilink|NVI|Null|PROTECTION_GROUP|Port-channel|Portgroup|Pos-channel|SBC|SDH_ACR|SERIAL-ACR|SONET_ACR|SSLVPN-VIF|SYSCLOCK|Serial-PG|Service-Engine|TLS-VIF|Tunnel|VPN|Vif|Vir-cem-ACR|Virtual-PPP|Virtual-TokenRing)\\S+))?\n                (\\s(?P<forward_router_address>(?!multicast|dhcp|global|tag|track|permanent|name)\\S+))?\n                (\\s(?P<distance_metric>\\d+))?\n                (\\stag\\s(?P<tag>\\d+))?\n                (\\s(?P<permanent>permanent))?\n                (\\sname\\s(?P<next_hop_name>\\S+))?\n                (\\strack\\s(?P<track>\\d+))?\n                (\\s(?P<multicast>multicast))?\n                (\\s(?P<dhcp>dhcp))?\n                (\\s(?P<global>global))?\n                $', re.VERBOSE), 'setval': "ip route{{ (' topology ' + ipv4.topology) if ipv4.topology is defined else '' }}{{ (' vrf ' + ipv4.vrf) if ipv4.vrf is defined else '' }}{{ (' ' + ipv4.dest) if ipv4.dest is defined else '' }}{{ (' ' + ipv4.interface) if ipv4.interface is defined else '' }}{{ (' ' + ipv4.forward_router_address) if ipv4.forward_router_address is defined else '' }}{{ (' ' + ipv4.distance_metric|string) if ipv4.distance_metric is defined else '' }}{{ (' tag ' + ipv4.tag|string) if ipv4.tag is defined else '' }}{{ (' permanent' ) if ipv4.permanent|d(False) else '' }}{{ (' name ' + ipv4.name) if ipv4.name is defined else '' }}{{ (' track ' + ipv4.track|string) if ipv4.track is defined else '' }}{{ (' multicast' ) if ipv4.multicast|d(False) else '' }}{{ (' dhcp' ) if ipv4.dhcp|d(False) else '' }}{{ (' global' ) if ipv4.global|d(False) else '' }}", 'result': {'{{ dest }}_{{ vrf|d() }}_{{ topology|d() }}_ipv4': [{'_vrf': '{{ vrf }}', '_topology': '{{ topology }}', '_afi': 'ipv4', '_dest': '{{ dest }}', '_netmask': '{{ netmask }}', 'interface': '{{ interface }}', 'forward_router_address': '{{ forward_router_address }}', 'distance_metric': '{{ distance_metric }}', 'tag': '{{ tag }}', 'permanent': '{{ not not permanent }}', 'name': '{{ next_hop_name }}', 'track': '{{ track }}', 'multicast': '{{ not not multicast }}', 'dhcp': '{{ not not dhcp }}', 'global': '{{ not not global }}'}]}}, {'name': 'ipv6', 'getval': re.compile('\n                ^ipv6\\sroute\n                (\\stopology\\s(?P<topology>\\S+))?\n                (\\svrf\\s(?P<vrf>\\S+))?\n                (\\s(?P<dest>\\S+))\n                (\\s(?P<interface>(ACR|ATM-ACR|Analysis-Module|AppNav-Compress|AppNav-UnCompress|Async|Auto-Template|BD-VIF|BDI|BVI|Bluetooth|CDMA-Ix|CEM-ACR|CEM-PG|CTunnel|Container|Dialer|EsconPhy|Ethernet-Internal|Fcpa|Filter|Filtergroup|GigabitEthernet|IMA-ACR|LongReachEthernet|Loopback|Lspvif|MFR|Multilink|NVI|Null|PROTECTION_GROUP|Port-channel|Portgroup|Pos-channel|SBC|SDH_ACR|SERIAL-ACR|SONET_ACR|SSLVPN-VIF|SYSCLOCK|Serial-PG|Service-Engine|TLS-VIF|Tunnel|VPN|Vif|Vir-cem-ACR|Virtual-PPP|Virtual-TokenRing)\\S+))?\n                (\\s(?P<forward_router_address>(?!multicast|unicast|tag|track|permanent|name)\\S+))?\n                (\\s(?P<distance_metric>\\d+))?\n                (\\s(?P<multicast>multicast))?\n                (\\s(?P<unicast>unicast))?\n                (\\stag\\s(?P<tag>\\d+))?\n                (\\strack\\s(?P<track>\\d+))?\n                (\\s(?P<permanent>permanent))?\n                (\\sname\\s(?P<next_hop_name>\\S+))?\n                $', re.VERBOSE), 'setval': "ipv6 route{{ (' topology ' + ipv6.topology) if ipv6.topology is defined else '' }}{{ (' vrf ' + ipv6.vrf) if ipv6.vrf is defined else '' }}{{ (' ' + ipv6.dest) if ipv6.dest is defined else '' }}{{ (' ' + ipv6.interface) if ipv6.interface is defined else '' }}{{ (' ' + ipv6.forward_router_address) if ipv6.forward_router_address is defined else '' }}{{ (' ' + ipv6.distance_metric|string) if ipv6.distance_metric is defined else '' }}{{ (' multicast' ) if ipv6.multicast|d(False) else '' }}{{ (' unicast' ) if ipv6.unicast|d(False) else '' }}{{ (' tag ' + ipv6.tag|string) if ipv6.tag is defined else '' }}{{ (' track ' + ipv6.track|string) if ipv6.track is defined else '' }}{{ (' permanent' ) if ipv6.permanent|d(False) else '' }}{{ (' name ' + ipv6.name) if ipv6.name is defined else '' }}", 'result': {'{{ dest }}_{{ vrf|d() }}_{{ topology|d() }}_ipv6': [{'_vrf': '{{ vrf }}', '_topology': '{{ topology }}', '_afi': 'ipv6', '_dest': '{{ dest }}', 'interface': '{{ interface }}', 'forward_router_address': '{{ forward_router_address }}', 'distance_metric': '{{ distance_metric }}', 'tag': '{{ tag }}', 'permanent': '{{ not not permanent }}', 'name': '{{ next_hop_name }}', 'track': '{{ track }}', 'multicast': '{{ not not multicast }}', 'unicast': '{{ not not unicast }}'}]}}]