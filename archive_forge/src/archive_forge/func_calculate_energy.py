import os
import numpy as np
from ase.neighborlist import NeighborList
from ase.calculators.calculator import Calculator, all_changes
from scipy.interpolate import InterpolatedUnivariateSpline as spline
from ase.units import Bohr, Hartree
def calculate_energy(self, atoms):
    """Calculate the energy
        the energy is made up of the ionic or pair interaction and
        the embedding energy of each atom into the electron cloud
        generated by its neighbors
        """
    pair_energy = 0.0
    embedding_energy = 0.0
    mu_energy = 0.0
    lam_energy = 0.0
    trace_energy = 0.0
    self.total_density = np.zeros(len(atoms))
    if self.form == 'adp':
        self.mu = np.zeros([len(atoms), 3])
        self.lam = np.zeros([len(atoms), 3, 3])
    for i in range(len(atoms)):
        neighbors, offsets = self.neighbors.get_neighbors(i)
        offset = np.dot(offsets, atoms.get_cell())
        rvec = atoms.positions[neighbors] + offset - atoms.positions[i]
        r = np.sqrt(np.sum(np.square(rvec), axis=1))
        nearest = np.arange(len(r))[r <= self.cutoff]
        for j_index in range(self.Nelements):
            use = self.index[neighbors[nearest]] == j_index
            if not use.any():
                continue
            pair_energy += np.sum(self.phi[self.index[i], j_index](r[nearest][use])) / 2.0
            if self.form == 'fs':
                density = np.sum(self.electron_density[j_index, self.index[i]](r[nearest][use]))
            else:
                density = np.sum(self.electron_density[j_index](r[nearest][use]))
            self.total_density[i] += density
            if self.form == 'adp':
                self.mu[i] += self.adp_dipole(r[nearest][use], rvec[nearest][use], self.d[self.index[i], j_index])
                self.lam[i] += self.adp_quadrupole(r[nearest][use], rvec[nearest][use], self.q[self.index[i], j_index])
        embedding_energy += self.embedded_energy[self.index[i]](self.total_density[i])
    components = dict(pair=pair_energy, embedding=embedding_energy)
    if self.form == 'adp':
        mu_energy += np.sum(self.mu ** 2) / 2.0
        lam_energy += np.sum(self.lam ** 2) / 2.0
        for i in range(len(atoms)):
            trace_energy -= np.sum(self.lam[i].trace() ** 2) / 6.0
        adp_result = dict(adp_mu=mu_energy, adp_lam=lam_energy, adp_trace=trace_energy)
        components.update(adp_result)
    self.positions = atoms.positions.copy()
    self.cell = atoms.get_cell().copy()
    energy = 0.0
    for i in components.keys():
        energy += components[i]
    self.energy_free = energy
    self.energy_zero = energy
    self.results['energy_components'] = components
    self.results['energy'] = energy