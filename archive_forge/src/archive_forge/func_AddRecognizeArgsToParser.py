from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals
from googlecloudsdk.api_lib.util import apis
from googlecloudsdk.calliope import actions
from googlecloudsdk.calliope import arg_parsers
from googlecloudsdk.calliope import exceptions
from googlecloudsdk.command_lib.ml.speech import util
from googlecloudsdk.command_lib.util.apis import arg_utils
def AddRecognizeArgsToParser(self, parser, api_version):
    """Add common, GA level flags for recognize commands."""
    parser.add_argument('audio', help='The location of the audio file to transcribe. Must be a local path or a Google Cloud Storage URL (in the format gs://bucket/object).')
    language_args = parser.add_group(mutex=True, required=True)
    language_args.add_argument('--language-code', help='The language of the supplied audio as a BCP-47 (https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: "en-US". See https://cloud.google.com/speech/docs/languages for a list of the currently supported language codes.')
    language_args.add_argument('--language', action=actions.DeprecationAction('--language', warn='The `--language` flag is deprecated. Use the `--language-code` flag instead.'), hidden=True, help='The language of the supplied audio as a BCP-47 (https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: "en-US". See https://cloud.google.com/speech/docs/languages for a list of the currently supported language codes.')
    self._encoding_type_mapper = GetEncodingTypeMapper(api_version)
    self._encoding_type_mapper.choice_arg.AddToParser(parser)
    parser.add_argument('--sample-rate', type=int, required=False, help="The sample rate in Hertz. For best results, set the sampling rate of the audio source to 16000 Hz. If that's not possible, use the native sample rate of the audio source (instead of re-sampling).")
    audio_channel_args = parser.add_group(required=False, help='Audio channel settings.')
    audio_channel_args.add_argument('--audio-channel-count', type=int, required=True, help='The number of channels in the input audio data.  Set this for separate-channel-recognition. Valid values are: 1)LINEAR16 and FLAC are 1-8 2)OGG_OPUS are 1-254 3) MULAW, AMR, AMR_WB and SPEEX_WITH_HEADER_BYTE is only `1`.')
    audio_channel_args.add_argument('--separate-channel-recognition', action='store_true', required=True, help='Recognition result will contain a `channel_tag` field to state which channel that result belongs to. If this is not true, only the first channel will be recognized.')
    parser.add_argument('--model', choices={'default': 'audio that is not one of the specific audio models. For example, long-form audio. Ideally the audio is high-fidelity, recorded at a 16khz or greater sampling rate.', 'command_and_search': 'short queries such as voice commands or voice search.', 'latest_long': 'Use this model for any kind of long form content such as media or spontaneous speech and conversations. Consider using this model in place of the video model, especially if the video model is not available in your target language. You can also use this in place of the default model.', 'latest_short': 'Use this model for short utterances that are a few seconds in length. It is useful for trying to capture commands or other single shot directed speech use cases. Consider using this model instead of the command and search model.', 'medical_conversation': 'Best for audio that originated from a conversation between a medical provider and patient.', 'medical_dictation': 'Best for audio that originated from dictation notes by a medical provider.', 'phone_call': 'audio that originated from a phone call (typically recorded at an 8khz sampling rate).', 'phone_call_enhanced': 'audio that originated from a phone call (typically recorded at an 8khz sampling rate). This is a premium model and can produce better results but costs more than the standard rate.', 'telephony': 'Improved version of the "phone_call" model, best for audio that originated from a phone call, typically recorded at an 8kHz sampling rate.', 'telephony_short': 'Dedicated version of the modern "telephony" model for short or even single-word utterances for audio that originated from a phone call, typically recorded at an 8kHz sampling rate.', 'video_enhanced': 'audio that originated from video or includes multiple speakers. Ideally the audio is recorded at a 16khz or greater sampling rate. This is a premium model that costs more than the standard rate.'}, help='Select the model best suited to your domain to get best results. If you do not explicitly specify a model, Speech-to-Text will auto-select a model based on your other specified parameters. Some models are premium and cost more than standard models (although you can reduce the price by opting into https://cloud.google.com/speech-to-text/docs/data-logging)')
    parser.add_argument('--max-alternatives', type=int, default=1, help='Maximum number of recognition hypotheses to be returned. The server may return fewer than max_alternatives. Valid values are 0-30. A value of 0 or 1 will return a maximum of one.')
    parser.add_argument('--hints', type=arg_parsers.ArgList(), metavar='HINT', default=[], help='A list of strings containing word and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See https://cloud.google.com/speech/limits#content.')
    parser.add_argument('--include-word-time-offsets', action='store_true', default=False, help='If True, the top result includes a list of words with the start and end time offsets (timestamps) for those words. If False, no word-level time offset information is returned.')
    parser.add_argument('--filter-profanity', action='store_true', default=False, help='If True, the server will attempt to filter out profanities, replacing all but the initial character in each filtered word with asterisks, e.g. ```f***```.')
    parser.add_argument('--enable-automatic-punctuation', action='store_true', help='Adds punctuation to recognition result hypotheses.')