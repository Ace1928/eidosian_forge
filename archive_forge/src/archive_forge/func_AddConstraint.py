from sys import version_info as _swig_python_version_info
import weakref
def AddConstraint(self, c):
    """
        Adds the constraint 'c' to the model.

        After calling this method, and until there is a backtrack that undoes the
        addition, any assignment of variables to values must satisfy the given
        constraint in order to be considered feasible. There are two fairly
        different use cases:

        - the most common use case is modeling: the given constraint is really
        part of the problem that the user is trying to solve. In this use case,
        AddConstraint is called outside of search (i.e., with state() ==
        OUTSIDE_SEARCH). Most users should only use AddConstraint in this
        way. In this case, the constraint will belong to the model forever: it
        cannot be removed by backtracking.

        - a rarer use case is that 'c' is not a real constraint of the model. It
        may be a constraint generated by a branching decision (a constraint whose
        goal is to restrict the search space), a symmetry breaking constraint (a
        constraint that does restrict the search space, but in a way that cannot
        have an impact on the quality of the solutions in the subtree), or an
        inferred constraint that, while having no semantic value to the model (it
        does not restrict the set of solutions), is worth having because we
        believe it may strengthen the propagation. In these cases, it happens
        that the constraint is added during the search (i.e., with state() ==
        IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is
        added during a search, it applies only to the subtree of the search tree
        rooted at the current node, and will be automatically removed by
        backtracking.

        This method does not take ownership of the constraint. If the constraint
        has been created by any factory method (Solver::MakeXXX), it will
        automatically be deleted. However, power users who implement their own
        constraints should do: solver.AddConstraint(solver.RevAlloc(new
        MyConstraint(...));
        """
    return _pywrapcp.Solver_AddConstraint(self, c)