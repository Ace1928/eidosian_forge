import functools
import itertools
import logging
import math
from numbers import Integral, Number, Real
import numpy as np
from numpy import ma
import matplotlib as mpl
import matplotlib.category  # Register category unit converter as side effect.
import matplotlib.cbook as cbook
import matplotlib.collections as mcoll
import matplotlib.colors as mcolors
import matplotlib.contour as mcontour
import matplotlib.dates  # noqa # Register date unit converter as side effect.
import matplotlib.image as mimage
import matplotlib.legend as mlegend
import matplotlib.lines as mlines
import matplotlib.markers as mmarkers
import matplotlib.mlab as mlab
import matplotlib.patches as mpatches
import matplotlib.path as mpath
import matplotlib.quiver as mquiver
import matplotlib.stackplot as mstack
import matplotlib.streamplot as mstream
import matplotlib.table as mtable
import matplotlib.text as mtext
import matplotlib.ticker as mticker
import matplotlib.transforms as mtransforms
import matplotlib.tri as mtri
import matplotlib.units as munits
from matplotlib import _api, _docstring, _preprocess_data
from matplotlib.axes._base import (
from matplotlib.axes._secondary_axes import SecondaryAxis
from matplotlib.container import BarContainer, ErrorbarContainer, StemContainer
@_preprocess_data(replace_names=['x', 'explode', 'labels', 'colors'])
def pie(self, x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=0, radius=1, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False, *, normalize=True, hatch=None):
    """
        Plot a pie chart.

        Make a pie chart of array *x*.  The fractional area of each wedge is
        given by ``x/sum(x)``.

        The wedges are plotted counterclockwise, by default starting from the
        x-axis.

        Parameters
        ----------
        x : 1D array-like
            The wedge sizes.

        explode : array-like, default: None
            If not *None*, is a ``len(x)`` array which specifies the fraction
            of the radius with which to offset each wedge.

        labels : list, default: None
            A sequence of strings providing the labels for each wedge

        colors : color or array-like of color, default: None
            A sequence of colors through which the pie chart will cycle.  If
            *None*, will use the colors in the currently active cycle.

        hatch : str or list, default: None
            Hatching pattern applied to all pie wedges or sequence of patterns
            through which the chart will cycle. For a list of valid patterns,
            see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.

            .. versionadded:: 3.7

        autopct : None or str or callable, default: None
            If not *None*, *autopct* is a string or function used to label the
            wedges with their numeric value. The label will be placed inside
            the wedge. If *autopct* is a format string, the label will be
            ``fmt % pct``. If *autopct* is a function, then it will be called.

        pctdistance : float, default: 0.6
            The relative distance along the radius at which the text
            generated by *autopct* is drawn. To draw the text outside the pie,
            set *pctdistance* > 1. This parameter is ignored if *autopct* is
            ``None``.

        labeldistance : float or None, default: 1.1
            The relative distance along the radius at which the labels are
            drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
            If set to ``None``, labels are not drawn but are still stored for
            use in `.legend`.

        shadow : bool or dict, default: False
            If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
            passing the properties in the dict to `.Shadow`.

            .. versionadded:: 3.8
                *shadow* can be a dict.

        startangle : float, default: 0 degrees
            The angle by which the start of the pie is rotated,
            counterclockwise from the x-axis.

        radius : float, default: 1
            The radius of the pie.

        counterclock : bool, default: True
            Specify fractions direction, clockwise or counterclockwise.

        wedgeprops : dict, default: None
            Dict of arguments passed to each `.patches.Wedge` of the pie.
            For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
            the wedge border lines equal to 3. By default, ``clip_on=False``.
            When there is a conflict between these properties and other
            keywords, properties passed to *wedgeprops* take precedence.

        textprops : dict, default: None
            Dict of arguments to pass to the text objects.

        center : (float, float), default: (0, 0)
            The coordinates of the center of the chart.

        frame : bool, default: False
            Plot Axes frame with the chart if true.

        rotatelabels : bool, default: False
            Rotate each label to the angle of the corresponding slice if true.

        normalize : bool, default: True
            When *True*, always make a full pie by normalizing x so that
            ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
            and raises a `ValueError` for ``sum(x) > 1``.

        data : indexable object, optional
            DATA_PARAMETER_PLACEHOLDER

        Returns
        -------
        patches : list
            A sequence of `matplotlib.patches.Wedge` instances

        texts : list
            A list of the label `.Text` instances.

        autotexts : list
            A list of `.Text` instances for the numeric labels. This will only
            be returned if the parameter *autopct* is not *None*.

        Notes
        -----
        The pie chart will probably look best if the figure and Axes are
        square, or the Axes aspect is equal.
        This method sets the aspect ratio of the axis to "equal".
        The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
        """
    self.set_aspect('equal')
    x = np.asarray(x, np.float32)
    if x.ndim > 1:
        raise ValueError('x must be 1D')
    if np.any(x < 0):
        raise ValueError("Wedge sizes 'x' must be non negative values")
    sx = x.sum()
    if normalize:
        x = x / sx
    elif sx > 1:
        raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
    if labels is None:
        labels = [''] * len(x)
    if explode is None:
        explode = [0] * len(x)
    if len(x) != len(labels):
        raise ValueError("'label' must be of length 'x'")
    if len(x) != len(explode):
        raise ValueError("'explode' must be of length 'x'")
    if colors is None:
        get_next_color = self._get_patches_for_fill.get_next_color
    else:
        color_cycle = itertools.cycle(colors)

        def get_next_color():
            return next(color_cycle)
    hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
    _api.check_isinstance(Real, radius=radius, startangle=startangle)
    if radius <= 0:
        raise ValueError(f'radius must be a positive number, not {radius}')
    theta1 = startangle / 360
    if wedgeprops is None:
        wedgeprops = {}
    if textprops is None:
        textprops = {}
    texts = []
    slices = []
    autotexts = []
    for frac, label, expl in zip(x, labels, explode):
        x, y = center
        theta2 = theta1 + frac if counterclock else theta1 - frac
        thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
        x += expl * math.cos(thetam)
        y += expl * math.sin(thetam)
        w = mpatches.Wedge((x, y), radius, 360.0 * min(theta1, theta2), 360.0 * max(theta1, theta2), facecolor=get_next_color(), hatch=next(hatch_cycle), clip_on=False, label=label)
        w.set(**wedgeprops)
        slices.append(w)
        self.add_patch(w)
        if shadow:
            shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
            if isinstance(shadow, dict):
                shadow_dict.update(shadow)
            self.add_patch(mpatches.Shadow(w, **shadow_dict))
        if labeldistance is not None:
            xt = x + labeldistance * radius * math.cos(thetam)
            yt = y + labeldistance * radius * math.sin(thetam)
            label_alignment_h = 'left' if xt > 0 else 'right'
            label_alignment_v = 'center'
            label_rotation = 'horizontal'
            if rotatelabels:
                label_alignment_v = 'bottom' if yt > 0 else 'top'
                label_rotation = np.rad2deg(thetam) + (0 if xt > 0 else 180)
            t = self.text(xt, yt, label, clip_on=False, horizontalalignment=label_alignment_h, verticalalignment=label_alignment_v, rotation=label_rotation, size=mpl.rcParams['xtick.labelsize'])
            t.set(**textprops)
            texts.append(t)
        if autopct is not None:
            xt = x + pctdistance * radius * math.cos(thetam)
            yt = y + pctdistance * radius * math.sin(thetam)
            if isinstance(autopct, str):
                s = autopct % (100.0 * frac)
            elif callable(autopct):
                s = autopct(100.0 * frac)
            else:
                raise TypeError('autopct must be callable or a format string')
            t = self.text(xt, yt, s, clip_on=False, horizontalalignment='center', verticalalignment='center')
            t.set(**textprops)
            autotexts.append(t)
        theta1 = theta2
    if frame:
        self._request_autoscale_view()
    else:
        self.set(frame_on=False, xticks=[], yticks=[], xlim=(-1.25 + center[0], 1.25 + center[0]), ylim=(-1.25 + center[1], 1.25 + center[1]))
    if autopct is None:
        return (slices, texts)
    else:
        return (slices, texts, autotexts)