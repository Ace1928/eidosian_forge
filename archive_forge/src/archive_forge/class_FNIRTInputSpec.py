import os
import os.path as op
from warnings import warn
import numpy as np
from nibabel import load
from ... import LooseVersion
from ...utils.filemanip import split_filename
from ..base import (
from .base import FSLCommand, FSLCommandInputSpec, Info
class FNIRTInputSpec(FSLCommandInputSpec):
    ref_file = File(exists=True, argstr='--ref=%s', mandatory=True, desc='name of reference image')
    in_file = File(exists=True, argstr='--in=%s', mandatory=True, desc='name of input image')
    affine_file = File(exists=True, argstr='--aff=%s', desc='name of file containing affine transform')
    inwarp_file = File(exists=True, argstr='--inwarp=%s', desc='name of file containing initial non-linear warps')
    in_intensitymap_file = traits.List(File(exists=True), argstr='--intin=%s', copyfile=False, minlen=1, maxlen=2, desc='name of file/files containing initial intensity mapping usually generated by previous fnirt run')
    fieldcoeff_file = traits.Either(traits.Bool, File, argstr='--cout=%s', desc='name of output file with field coefficients or true')
    warped_file = File(argstr='--iout=%s', desc='name of output image', genfile=True, hash_files=False)
    field_file = traits.Either(traits.Bool, File, argstr='--fout=%s', desc='name of output file with field or true', hash_files=False)
    jacobian_file = traits.Either(traits.Bool, File, argstr='--jout=%s', desc='name of file for writing out the Jacobian of the field (for diagnostic or VBM purposes)', hash_files=False)
    modulatedref_file = traits.Either(traits.Bool, File, argstr='--refout=%s', desc='name of file for writing out intensity modulated --ref (for diagnostic purposes)', hash_files=False)
    out_intensitymap_file = traits.Either(traits.Bool, File, argstr='--intout=%s', desc='name of files for writing information pertaining to intensity mapping', hash_files=False)
    log_file = File(argstr='--logout=%s', desc='Name of log-file', genfile=True, hash_files=False)
    config_file = traits.Either(traits.Enum('T1_2_MNI152_2mm', 'FA_2_FMRIB58_1mm'), File(exists=True), argstr='--config=%s', desc='Name of config file specifying command line arguments')
    refmask_file = File(exists=True, argstr='--refmask=%s', desc='name of file with mask in reference space')
    inmask_file = File(exists=True, argstr='--inmask=%s', desc='name of file with mask in input image space')
    skip_refmask = traits.Bool(argstr='--applyrefmask=0', xor=['apply_refmask'], desc='Skip specified refmask if set, default false')
    skip_inmask = traits.Bool(argstr='--applyinmask=0', xor=['apply_inmask'], desc='skip specified inmask if set, default false')
    apply_refmask = traits.List(traits.Enum(0, 1), argstr='--applyrefmask=%s', xor=['skip_refmask'], desc='list of iterations to use reference mask on (1 to use, 0 to skip)', sep=',')
    apply_inmask = traits.List(traits.Enum(0, 1), argstr='--applyinmask=%s', xor=['skip_inmask'], desc='list of iterations to use input mask on (1 to use, 0 to skip)', sep=',')
    skip_implicit_ref_masking = traits.Bool(argstr='--imprefm=0', desc='skip implicit masking  based on value in --ref image. Default = 0')
    skip_implicit_in_masking = traits.Bool(argstr='--impinm=0', desc='skip implicit masking  based on value in --in image. Default = 0')
    refmask_val = traits.Float(argstr='--imprefval=%f', desc='Value to mask out in --ref image. Default =0.0')
    inmask_val = traits.Float(argstr='--impinval=%f', desc='Value to mask out in --in image. Default =0.0')
    max_nonlin_iter = traits.List(traits.Int, argstr='--miter=%s', desc='Max # of non-linear iterations list, default [5, 5, 5, 5]', sep=',')
    subsampling_scheme = traits.List(traits.Int, argstr='--subsamp=%s', desc='sub-sampling scheme, list, default [4, 2, 1, 1]', sep=',')
    warp_resolution = traits.Tuple(traits.Int, traits.Int, traits.Int, argstr='--warpres=%d,%d,%d', desc='(approximate) resolution (in mm) of warp basis in x-, y- and z-direction, default 10, 10, 10')
    spline_order = traits.Int(argstr='--splineorder=%d', desc='Order of spline, 2->Qadratic spline, 3->Cubic spline. Default=3')
    in_fwhm = traits.List(traits.Int, argstr='--infwhm=%s', desc='FWHM (in mm) of gaussian smoothing kernel for input volume, default [6, 4, 2, 2]', sep=',')
    ref_fwhm = traits.List(traits.Int, argstr='--reffwhm=%s', desc='FWHM (in mm) of gaussian smoothing kernel for ref volume, default [4, 2, 0, 0]', sep=',')
    regularization_model = traits.Enum('membrane_energy', 'bending_energy', argstr='--regmod=%s', desc='Model for regularisation of warp-field [membrane_energy bending_energy], default bending_energy')
    regularization_lambda = traits.List(traits.Float, argstr='--lambda=%s', desc='Weight of regularisation, default depending on --ssqlambda and --regmod switches. See user documentation.', sep=',')
    skip_lambda_ssq = traits.Bool(argstr='--ssqlambda=0', desc='If true, lambda is not weighted by current ssq, default false')
    jacobian_range = traits.Tuple(traits.Float, traits.Float, argstr='--jacrange=%f,%f', desc='Allowed range of Jacobian determinants, default 0.01, 100.0')
    derive_from_ref = traits.Bool(argstr='--refderiv', desc='If true, ref image is used to calculate derivatives. Default false')
    intensity_mapping_model = traits.Enum('none', 'global_linear', 'global_non_linear', 'local_linear', 'global_non_linear_with_bias', 'local_non_linear', argstr='--intmod=%s', desc='Model for intensity-mapping')
    intensity_mapping_order = traits.Int(argstr='--intorder=%d', desc='Order of poynomial for mapping intensities, default 5')
    biasfield_resolution = traits.Tuple(traits.Int, traits.Int, traits.Int, argstr='--biasres=%d,%d,%d', desc='Resolution (in mm) of bias-field modelling local intensities, default 50, 50, 50')
    bias_regularization_lambda = traits.Float(argstr='--biaslambda=%f', desc='Weight of regularisation for bias-field, default 10000')
    skip_intensity_mapping = traits.Bool(argstr='--estint=0', xor=['apply_intensity_mapping'], desc='Skip estimate intensity-mapping default false')
    apply_intensity_mapping = traits.List(traits.Enum(0, 1), argstr='--estint=%s', xor=['skip_intensity_mapping'], desc='List of subsampling levels to apply intensity mapping for (0 to skip, 1 to apply)', sep=',')
    hessian_precision = traits.Enum('double', 'float', argstr='--numprec=%s', desc='Precision for representing Hessian, double or float. Default double')