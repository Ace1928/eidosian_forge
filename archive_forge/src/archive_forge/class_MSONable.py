from __future__ import annotations
import datetime
import json
import os
import pathlib
import traceback
import types
from collections import OrderedDict, defaultdict
from enum import Enum
from hashlib import sha1
from importlib import import_module
from inspect import getfullargspec
from pathlib import Path
from uuid import UUID
class MSONable:
    """
    This is a mix-in base class specifying an API for msonable objects. MSON
    is Monty JSON. Essentially, MSONable objects must implement an as_dict
    method, which must return a json serializable dict and must also support
    no arguments (though optional arguments to finetune the output is ok),
    and a from_dict class method that regenerates the object from the dict
    generated by the as_dict method. The as_dict method should contain the
    "@module" and "@class" keys which will allow the MontyEncoder to
    dynamically deserialize the class. E.g.::

        d["@module"] = self.__class__.__module__
        d["@class"] = self.__class__.__name__

    A default implementation is provided in MSONable, which automatically
    determines if the class already contains self.argname or self._argname
    attributes for every arg. If so, these will be used for serialization in
    the dict format. Similarly, the default from_dict will deserialization
    classes of such form. An example is given below::

        class MSONClass(MSONable):

        def __init__(self, a, b, c, d=1, **kwargs):
            self.a = a
            self.b = b
            self._c = c
            self._d = d
            self.kwargs = kwargs

    For such classes, you merely need to inherit from MSONable and you do not
    need to implement your own as_dict or from_dict protocol.

    New to Monty V2.0.6....
    Classes can be redirected to moved implementations by putting in the old
    fully qualified path and new fully qualified path into .monty.yaml in the
    home folder

    Example:
    old_module.old_class: new_module.new_class
    """
    REDIRECT = _load_redirect(os.path.join(os.path.expanduser('~'), '.monty.yaml'))

    def as_dict(self) -> dict:
        """
        A JSON serializable dict representation of an object.
        """
        d = {'@module': self.__class__.__module__, '@class': self.__class__.__name__}
        try:
            parent_module = self.__class__.__module__.split('.', maxsplit=1)[0]
            module_version = import_module(parent_module).__version__
            d['@version'] = str(module_version)
        except (AttributeError, ImportError):
            d['@version'] = None
        spec = getfullargspec(self.__class__.__init__)

        def recursive_as_dict(obj):
            if isinstance(obj, (list, tuple)):
                return [recursive_as_dict(it) for it in obj]
            if isinstance(obj, dict):
                return {kk: recursive_as_dict(vv) for kk, vv in obj.items()}
            if hasattr(obj, 'as_dict'):
                return obj.as_dict()
            if dataclasses is not None and dataclasses.is_dataclass(obj):
                d = dataclasses.asdict(obj)
                d.update({'@module': obj.__class__.__module__, '@class': obj.__class__.__name__})
                return d
            return obj
        for c in spec.args + spec.kwonlyargs:
            if c != 'self':
                try:
                    a = getattr(self, c)
                except AttributeError:
                    try:
                        a = getattr(self, '_' + c)
                    except AttributeError:
                        raise NotImplementedError('Unable to automatically determine as_dict format from class. MSONAble requires all args to be present as either self.argname or self._argname, and kwargs to be present under a self.kwargs variable to automatically determine the dict format. Alternatively, you can implement both as_dict and from_dict.')
                d[c] = recursive_as_dict(a)
        if hasattr(self, 'kwargs'):
            d.update(**self.kwargs)
        if spec.varargs is not None and getattr(self, spec.varargs, None) is not None:
            d.update({spec.varargs: getattr(self, spec.varargs)})
        if hasattr(self, '_kwargs'):
            d.update(**self._kwargs)
        if isinstance(self, Enum):
            d.update({'value': self.value})
        return d

    @classmethod
    def from_dict(cls, d):
        """
        :param d: Dict representation.
        :return: MSONable class.
        """
        decoded = {k: MontyDecoder().process_decoded(v) for k, v in d.items() if not k.startswith('@')}
        return cls(**decoded)

    def to_json(self) -> str:
        """
        Returns a json string representation of the MSONable object.
        """
        return json.dumps(self, cls=MontyEncoder)

    def unsafe_hash(self):
        """
        Returns an hash of the current object. This uses a generic but low
        performance method of converting the object to a dictionary, flattening
        any nested keys, and then performing a hash on the resulting object
        """

        def flatten(obj, separator='.'):
            flat_dict = {}
            for key, value in obj.items():
                if isinstance(value, dict):
                    flat_dict.update({separator.join([key, _key]): _value for _key, _value in flatten(value).items()})
                elif isinstance(value, list):
                    list_dict = {f'{key}{separator}{num}': item for num, item in enumerate(value)}
                    flat_dict.update(flatten(list_dict))
                else:
                    flat_dict[key] = value
            return flat_dict
        ordered_keys = sorted(flatten(jsanitize(self.as_dict())).items(), key=lambda x: x[0])
        ordered_keys = [item for item in ordered_keys if '@' not in item[0]]
        return sha1(json.dumps(OrderedDict(ordered_keys)).encode('utf-8'))

    @classmethod
    def _validate_monty(cls, __input_value):
        """
        pydantic Validator for MSONable pattern
        """
        if isinstance(__input_value, cls):
            return __input_value
        if isinstance(__input_value, dict):
            try:
                new_obj = MontyDecoder().process_decoded(__input_value)
                if isinstance(new_obj, cls):
                    return new_obj
                return cls(**__input_value)
            except Exception:
                raise ValueError(f'Error while deserializing {cls.__name__} object: {traceback.format_exc()}')
        raise ValueError(f'Must provide {cls.__name__}, the as_dict form, or the proper')

    @classmethod
    def validate_monty_v1(cls, __input_value):
        """
        Pydantic validator with correct signature for pydantic v1.x
        """
        return cls._validate_monty(__input_value)

    @classmethod
    def validate_monty_v2(cls, __input_value, _):
        """
        Pydantic validator with correct signature for pydantic v2.x
        """
        return cls._validate_monty(__input_value)

    @classmethod
    def __get_validators__(cls):
        """Return validators for use in pydantic"""
        yield cls.validate_monty_v1

    @classmethod
    def __get_pydantic_core_schema__(cls, source_type, handler):
        """
        pydantic v2 core schema definition
        """
        if core_schema is None:
            raise RuntimeError('Pydantic >= 2.0 is required for validation')
        s = core_schema.with_info_plain_validator_function(cls.validate_monty_v2)
        return core_schema.json_or_python_schema(json_schema=s, python_schema=s)

    @classmethod
    def _generic_json_schema(cls):
        return {'type': 'object', 'properties': {'@class': {'enum': [cls.__name__], 'type': 'string'}, '@module': {'enum': [cls.__module__], 'type': 'string'}, '@version': {'type': 'string'}}, 'required': ['@class', '@module']}

    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema, handler):
        """JSON schema for MSONable pattern"""
        return cls._generic_json_schema()

    @classmethod
    def __modify_schema__(cls, field_schema):
        """JSON schema for MSONable pattern"""
        custom_schema = cls._generic_json_schema()
        field_schema.update(custom_schema)