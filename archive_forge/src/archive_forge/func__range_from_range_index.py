from statsmodels.compat.pandas import (
from abc import ABC, abstractmethod
import datetime as dt
from typing import Optional, Union
from collections.abc import Hashable, Sequence
import numpy as np
import pandas as pd
from scipy.linalg import qr
from statsmodels.iolib.summary import d_or_f
from statsmodels.tools.validation import (
from statsmodels.tsa.tsatools import freq_to_period
def _range_from_range_index(self, start: int, stop: int) -> pd.DataFrame:
    index = self._index
    is_int64_index = is_int_index(index)
    assert isinstance(index, pd.RangeIndex) or is_int64_index
    if start < index[0]:
        raise ValueError(START_BEFORE_INDEX_ERR)
    if isinstance(index, pd.RangeIndex):
        idx_step = index.step
    else:
        idx_step = np.diff(index).max() if len(index) > 1 else 1
    if idx_step != 1 and (start - index[0]) % idx_step != 0:
        raise ValueError(f'The step of the index is not 1 (actual step={idx_step}). start must be in the sequence that would have been generated by the index.')
    if is_int64_index:
        new_idx = pd.Index(np.arange(start, stop))
    else:
        new_idx = pd.RangeIndex(start, stop, step=idx_step)
    if new_idx[-1] <= self._index[-1]:
        in_sample = self.in_sample()
        in_sample = in_sample.loc[new_idx]
        return in_sample
    elif new_idx[0] > self._index[-1]:
        next_value = index[-1] + idx_step
        if new_idx[0] != next_value:
            tmp = pd.RangeIndex(next_value, stop, step=idx_step)
            oos = self.out_of_sample(tmp.shape[0], forecast_index=tmp)
            return oos.loc[new_idx]
        return self.out_of_sample(new_idx.shape[0], forecast_index=new_idx)
    in_sample_loc = new_idx <= self._index[-1]
    in_sample_idx = new_idx[in_sample_loc]
    out_of_sample_idx = new_idx[~in_sample_loc]
    in_sample_exog = self.in_sample().loc[in_sample_idx]
    oos_exog = self.out_of_sample(steps=out_of_sample_idx.shape[0], forecast_index=out_of_sample_idx)
    return pd.concat([in_sample_exog, oos_exog], axis=0)