import datetime
import difflib
import functools
import inspect
import json
import os
import re
import tempfile
import threading
import unittest
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
import torch
import torch._dynamo
import torch.utils._pytree as pytree
from torch._dynamo.utils import clone_input
from torch._subclasses.schema_check_mode import SchemaCheckMode
from torch._utils_internal import get_file_path_2
from torch.overrides import TorchFunctionMode
from torch.testing._internal.optests import (
def validate_failures_dict_structure(failure_dict: 'FailuresDict', test_utils: List[str], testcase: Any) -> None:
    """Validates the failures dict.

    The failure dict looks something like the following.
    It maps operator name (qualname) to a list of autogenerated tests.
    Each autogenerated test may have a check for the operator (if the operator is
    called by the test); the dictionary specifies if we should skip the check,
    or if we expect some check to fail.

    {
        "fbgemm::split_lengths": {
            "test_schema__test_split_lengths": {
                "comment": "you can put whatever you want into the comment section",
                "status": "xfail",
            }
            "test_schema__test_split_lengths_empty": {
                "comment": "",
                "status": "skip",
            },
        },
        "fbgemm::gather_lengths": {
            "test_schema__test_gather_lengths": {
                "comment": "",
                "status": "skip",
            },
        },
    }

    """
    failure_dict = failure_dict.data
    qualnames = list(failure_dict.keys())
    for test_to_option in failure_dict.values():
        test_names = list(test_to_option.keys())
        for test_name, test_dict in test_to_option.items():
            if set(test_dict.keys()) != set({'comment', 'status'}):
                raise RuntimeError("in failures_dict, expected sub-dict to have keys 'comment' and 'status'")
            test_option = test_dict['status']
            if test_option not in TEST_OPTIONS:
                raise RuntimeError(f'In failures_dict, got status={test_option} but it needs to be in {TEST_OPTIONS}')
            test_class, actual_test_name = test_name.split('.')
            if not any((actual_test_name.startswith(test) for test in test_utils)):
                raise RuntimeError(f"In failures_dict, test name '{test_name}' should begin with one of {test_utils}")
            for test in test_utils:
                if not actual_test_name.startswith(test):
                    continue
                base_test_name = actual_test_name[len(test) + 2:]
                base_test_name = re.sub('\\[.*\\]', '', base_test_name)
                if testcase.__name__ != test_class:
                    continue
                if hasattr(testcase, base_test_name):
                    continue
                raise RuntimeError(f"In failures dict, got test name '{test_name}'. We parsed this as running test '{test}' on '{base_test_name}', but {base_test_name} does not exist on the TestCase '{testcase.__name__}]. Maybe you need to change the test name?")