import warnings
from typing import Sequence, Callable
import numpy as np
from scipy.sparse.linalg import expm
import pennylane as qml
from pennylane import transform
from pennylane.tape import QuantumTape
from pennylane.queuing import QueuingManager
@transform
def append_time_evolution(tape: QuantumTape, riemannian_gradient, t, n, exact=False) -> (Sequence[QuantumTape], Callable):
    """Append an approximate time evolution, corresponding to a Riemannian
    gradient on the Lie group, to an existing circuit.

    We want to implement the time evolution generated by an operator of the form

    .. math::

        \\text{grad} f(U) = sum_i c_i O_i,

    where :math:`O_i` are Pauli words and :math:`c_t \\in \\mathbb{R}`.
    If ``exact`` is ``False``, we Trotterize this operator and apply the unitary

    .. math::

        U' = \\prod_{n=1}^{N_{Trot.}} \\left(\\prod_i \\exp{-it / N_{Trot.} O_i}\\right),

    which is then appended to the current circuit.

    If ``exact`` is ``True``, we calculate the exact time evolution for the Riemannian gradient
     by way of the matrix exponential.

    .. math:

        U' = \\exp{-it \\text{grad} f(U)}

    and append this unitary.

    Args:
        tape (QuantumTape or QNode or Callable): circuit to transform.
        riemannian_gradient (.Hamiltonian): Hamiltonian object representing the Riemannian gradient.
        t (float): time evolution parameter.
        n (int): number of Trotter steps.

    Returns:
        qnode (QNode) or quantum function (Callable) or tuple[List[QuantumTape], function]: The transformed circuit as described in :func:`qml.transform <pennylane.transform>`.


    """
    new_operations = tape.operations
    if exact:
        with QueuingManager.stop_recording():
            new_operations.append(qml.QubitUnitary(expm(-1j * t * riemannian_gradient.sparse_matrix().toarray()), wires=range(len(riemannian_gradient.wires))))
    else:
        with QueuingManager.stop_recording():
            new_operations.append(qml.templates.ApproxTimeEvolution(riemannian_gradient, t, n))
    new_tape = type(tape)(new_operations, tape.measurements, shots=tape.shots)

    def null_postprocessing(results):
        """A postprocesing function returned by a transform that only converts the batch of results
        into a result for a single ``QuantumTape``.
        """
        return results[0]
    return ([new_tape], null_postprocessing)