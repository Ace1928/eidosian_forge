import logging
import re
from argparse import (
from collections import defaultdict
from functools import total_ordering
from itertools import starmap
from string import Template
from typing import Any, Dict, List
from typing import Optional as Opt
from typing import Union
@mark_completer('bash')
def complete_bash(parser, root_prefix=None, preamble='', choice_functions=None):
    """
    Returns bash syntax autocompletion script.

    See `complete` for arguments.
    """
    root_prefix = wordify(f'_shtab_{root_prefix or parser.prog}')
    subparsers, option_strings, compgens, choices, nargs = get_bash_commands(parser, root_prefix, choice_functions=choice_functions)
    return Template('# AUTOMATICALLY GENERATED by `shtab`\n\n${subparsers}\n\n${option_strings}\n\n${compgens}\n\n${choices}\n\n${nargs}\n\n${preamble}\n# $1=COMP_WORDS[1]\n_shtab_compgen_files() {\n  compgen -f -- $1  # files\n}\n\n# $1=COMP_WORDS[1]\n_shtab_compgen_dirs() {\n  compgen -d -- $1  # recurse into subdirs\n}\n\n# $1=COMP_WORDS[1]\n_shtab_replace_nonword() {\n  echo "${1//[^[:word:]]/_}"\n}\n\n# set default values (called for the initial parser & any subparsers)\n_set_parser_defaults() {\n  local subparsers_var="${prefix}_subparsers[@]"\n  sub_parsers=${!subparsers_var-}\n\n  local current_option_strings_var="${prefix}_option_strings[@]"\n  current_option_strings=${!current_option_strings_var}\n\n  completed_positional_actions=0\n\n  _set_new_action "pos_${completed_positional_actions}" true\n}\n\n# $1=action identifier\n# $2=positional action (bool)\n# set all identifiers for an action\'s parameters\n_set_new_action() {\n  current_action="${prefix}_$(_shtab_replace_nonword $1)"\n\n  local current_action_compgen_var=${current_action}_COMPGEN\n  current_action_compgen="${!current_action_compgen_var-}"\n\n  local current_action_choices_var="${current_action}_choices[@]"\n  current_action_choices="${!current_action_choices_var-}"\n\n  local current_action_nargs_var="${current_action}_nargs"\n  if [ -n "${!current_action_nargs_var-}" ]; then\n    current_action_nargs="${!current_action_nargs_var}"\n  else\n    current_action_nargs=1\n  fi\n\n  current_action_args_start_index=$(( $word_index + 1 - $pos_only ))\n\n  current_action_is_positional=$2\n}\n\n# Notes:\n# `COMPREPLY`: what will be rendered after completion is triggered\n# `completing_word`: currently typed word to generate completions for\n# `${!var}`: evaluates the content of `var` and expand its content as a variable\n#     hello="world"\n#     x="hello"\n#     ${!x} -> ${hello} -> "world"\n${root_prefix}() {\n  local completing_word="${COMP_WORDS[COMP_CWORD]}"\n  local completed_positional_actions\n  local current_action\n  local current_action_args_start_index\n  local current_action_choices\n  local current_action_compgen\n  local current_action_is_positional\n  local current_action_nargs\n  local current_option_strings\n  local sub_parsers\n  COMPREPLY=()\n\n  local prefix=${root_prefix}\n  local word_index=0\n  local pos_only=0 # "--" delimeter not encountered yet\n  _set_parser_defaults\n  word_index=1\n\n  # determine what arguments are appropriate for the current state\n  # of the arg parser\n  while [ $word_index -ne $COMP_CWORD ]; do\n    local this_word="${COMP_WORDS[$word_index]}"\n\n    if [[ $pos_only = 1 || " $this_word " != " -- " ]]; then\n      if [[ -n $sub_parsers && " ${sub_parsers[@]} " == *" ${this_word} "* ]]; then\n        # valid subcommand: add it to the prefix & reset the current action\n        prefix="${prefix}_$(_shtab_replace_nonword $this_word)"\n        _set_parser_defaults\n      fi\n\n      if [[ " ${current_option_strings[@]} " == *" ${this_word} "* ]]; then\n        # a new action should be acquired (due to recognised option string or\n        # no more input expected from current action);\n        # the next positional action can fill in here\n        _set_new_action $this_word false\n      fi\n\n      if [[ "$current_action_nargs" != "*" ]] && \\\n         [[ "$current_action_nargs" != "+" ]] && \\\n         [[ "$current_action_nargs" != *"..." ]] && \\\n         (( $word_index + 1 - $current_action_args_start_index - $pos_only >= \\\n            $current_action_nargs )); then\n        $current_action_is_positional && let "completed_positional_actions += 1"\n        _set_new_action "pos_${completed_positional_actions}" true\n      fi\n    else\n      pos_only=1 # "--" delimeter encountered\n    fi\n\n    let "word_index+=1"\n  done\n\n  # Generate the completions\n\n  if [[ $pos_only = 0 && "${completing_word}" == -* ]]; then\n    # optional argument started: use option strings\n    COMPREPLY=( $(compgen -W "${current_option_strings[*]}" -- "${completing_word}") )\n  else\n    # use choices & compgen\n    local IFS=$\'\\n\' # items may contain spaces, so delimit using newline\n    COMPREPLY=( $([ -n "${current_action_compgen}" ] \\\n                  && "${current_action_compgen}" "${completing_word}") )\n    unset IFS\n    COMPREPLY+=( $(compgen -W "${current_action_choices[*]}" -- "${completing_word}") )\n  fi\n\n  return 0\n}\n\ncomplete -o filenames -F ${root_prefix} ${prog}').safe_substitute(subparsers='\n'.join(subparsers), option_strings='\n'.join(option_strings), compgens='\n'.join(compgens), choices='\n'.join(choices), nargs='\n'.join(nargs), preamble='\n# Custom Preamble\n' + preamble + '\n# End Custom Preamble\n' if preamble else '', root_prefix=root_prefix, prog=parser.prog)