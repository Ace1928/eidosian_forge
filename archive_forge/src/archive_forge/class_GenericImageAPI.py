import io
import pathlib
import sys
import warnings
from functools import partial
from itertools import product
import numpy as np
from ..optpkg import optional_package
import unittest
import pytest
from numpy.testing import assert_allclose, assert_almost_equal, assert_array_equal
from nibabel.arraywriters import WriterError
from nibabel.testing import (
from .. import (
from ..casting import sctypes
from ..spatialimages import SpatialImage
from ..tmpdirs import InTemporaryDirectory
from .test_api_validators import ValidateAPI
from .test_brikhead import EXAMPLE_IMAGES as AFNI_EXAMPLE_IMAGES
from .test_minc1 import EXAMPLE_IMAGES as MINC1_EXAMPLE_IMAGES
from .test_minc2 import EXAMPLE_IMAGES as MINC2_EXAMPLE_IMAGES
from .test_parrec import EXAMPLE_IMAGES as PARREC_EXAMPLE_IMAGES
class GenericImageAPI(ValidateAPI):
    """General image validation API"""
    has_scaling = False
    can_save = False
    standard_extension = '.img'

    def obj_params(self):
        """Return generator returning (`img_creator`, `img_params`) tuples

        ``img_creator`` is a function taking no arguments and returning a fresh
        image.  We need to return this ``img_creator`` function rather than an
        image instance so we can recreate the images fresh for each of multiple
        tests run from the ``validate_xxx`` autogenerated test methods.  This
        allows the tests to modify the image without having an effect on the
        later tests in the same function, because each test will create a fresh
        image with ``img_creator``.

        Returns
        -------
        func_params_gen : generator
            Generator returning tuples with:

            * img_creator : callable
              Callable returning a fresh image for testing
            * img_params : mapping
              Expected properties of image returned from ``img_creator``
              callable.  Key, value pairs should include:

              * ``data`` : array returned from ``get_fdata()`` on image - OR -
                ``data_summary`` : dict with data ``min``, ``max``, ``mean``;
              * ``shape`` : shape of image;
              * ``affine`` : shape (4, 4) affine array for image;
              * ``dtype`` : dtype of data returned from ``np.asarray(dataobj)``;
              * ``is_proxy`` : bool, True if image data is proxied;

        Notes
        -----
        Passing ``data_summary`` instead of ``data`` allows you gentle user to
        avoid having to have a saved copy of the entire data array from example
        images for testing.
        """
        raise NotImplementedError

    def validate_header(self, imaker, params):
        img = imaker()
        hdr = img.header
        with pytest.raises(AttributeError):
            img.header = hdr

    def validate_filenames(self, imaker, params):
        if not self.can_save:
            raise unittest.SkipTest
        img = imaker()
        img.set_data_dtype(np.float32)
        img.file_map = None
        rt_img = bytesio_round_trip(img)
        assert_array_equal(img.shape, rt_img.shape)
        assert_almost_equal(img.get_fdata(), rt_img.get_fdata())
        assert_almost_equal(np.asanyarray(img.dataobj), np.asanyarray(rt_img.dataobj))
        klass = type(img)
        rt_img.file_map = bytesio_filemap(klass)
        rt_img.to_file_map()
        rt_rt_img = klass.from_file_map(rt_img.file_map)
        assert_almost_equal(img.get_fdata(), rt_rt_img.get_fdata())
        assert_almost_equal(np.asanyarray(img.dataobj), np.asanyarray(rt_img.dataobj))
        fname = 'an_image' + self.standard_extension
        for path in (fname, pathlib.Path(fname)):
            img.set_filename(path)
            assert img.get_filename() == str(path)
            assert img.file_map['image'].filename == str(path)
        fname = 'another_image' + self.standard_extension
        for path in (fname, pathlib.Path(fname)):
            with InTemporaryDirectory():
                with clear_and_catch_warnings():
                    warnings.filterwarnings('error', category=DeprecationWarning, module='nibabel.*')
                    img.to_filename(path)
                    rt_img = img.__class__.from_filename(path)
                assert_array_equal(img.shape, rt_img.shape)
                assert_almost_equal(img.get_fdata(), rt_img.get_fdata())
                assert_almost_equal(np.asanyarray(img.dataobj), np.asanyarray(rt_img.dataobj))
                del rt_img

    def validate_no_slicing(self, imaker, params):
        img = imaker()
        with pytest.raises(TypeError):
            img['string']
        with pytest.raises(TypeError):
            img[:]

    @expires('5.0.0')
    def validate_get_data_deprecated(self, imaker, params):
        img = imaker()
        with deprecated_to('5.0.0'):
            data = img.get_data()
        assert_array_equal(np.asanyarray(img.dataobj), data)