import logging
import re
from argparse import (
from collections import defaultdict
from functools import total_ordering
from itertools import starmap
from string import Template
from typing import Any, Dict, List
from typing import Optional as Opt
from typing import Union
@mark_completer('tcsh')
def complete_tcsh(parser, root_prefix=None, preamble='', choice_functions=None):
    """
    Return tcsh syntax autocompletion script.

    root_prefix:
      ignored (tcsh has no support for functions)

    See `complete` for other arguments.
    """
    optionals_single = set()
    optionals_double = set()
    specials = []
    index_choices = defaultdict(dict)
    choice_type2fn = {k: v['tcsh'] for k, v in CHOICE_FUNCTIONS.items()}
    if choice_functions:
        choice_type2fn.update(choice_functions)

    def get_specials(arg, arg_type, arg_sel):
        if arg.choices:
            choice_strs = ' '.join(map(str, arg.choices))
            yield f"'{arg_type}/{arg_sel}/({choice_strs})/'"
        elif hasattr(arg, 'complete'):
            complete_fn = complete2pattern(arg.complete, 'tcsh', choice_type2fn)
            if complete_fn:
                yield f"'{arg_type}/{arg_sel}/{complete_fn}/'"

    def recurse_parser(cparser, positional_idx, requirements=None):
        log_prefix = '| ' * positional_idx
        log.debug('%sParser @ %d', log_prefix, positional_idx)
        if requirements:
            log.debug('%s- Requires: %s', log_prefix, ' '.join(requirements))
        else:
            requirements = []
        for optional in cparser._get_optional_actions():
            log.debug('%s| Optional: %s', log_prefix, optional.dest)
            if optional.help != SUPPRESS:
                for optional_str in optional.option_strings:
                    log.debug('%s| | %s', log_prefix, optional_str)
                    if optional_str.startswith('--'):
                        optionals_double.add(optional_str[2:])
                    elif optional_str.startswith('-'):
                        optionals_single.add(optional_str[1:])
                    specials.extend(get_specials(optional, 'n', optional_str))
        for positional in cparser._get_positional_actions():
            if positional.help != SUPPRESS:
                positional_idx += 1
                log.debug('%s| Positional #%d: %s', log_prefix, positional_idx, positional.dest)
                index_choices[positional_idx][tuple(requirements)] = positional
                if not requirements and isinstance(positional.choices, dict):
                    for subcmd, subparser in positional.choices.items():
                        log.debug('%s| | SubParser: %s', log_prefix, subcmd)
                        recurse_parser(subparser, positional_idx, requirements + [subcmd])
    recurse_parser(parser, 0)
    for idx, ndict in index_choices.items():
        if len(ndict) == 1:
            arg = list(ndict.values())[0]
            specials.extend(get_specials(arg, 'p', str(idx)))
        else:
            nlist = []
            for nn, arg in ndict.items():
                if arg.choices:
                    checks = [f'[ "$cmd[{iidx}]" == "{n}" ]' for iidx, n in enumerate(nn, start=2)]
                    choices_str = "' '".join(arg.choices)
                    checks_str = ' && '.join(checks + [f"echo '{choices_str}'"])
                    nlist.append(f'( {checks_str} || false )')
            nlist_str = ' || '.join(nlist)
            specials.append(f"'p@{str(idx)}@`set cmd=($COMMAND_LINE); {nlist_str}`@'")
    if optionals_double:
        if optionals_single:
            optionals_single.add('-')
        else:
            optionals_single = ('-', '-')
    return Template("# AUTOMATICALLY GENERATED by `shtab`\n\n${preamble}\n\ncomplete ${prog} \\\n        'c/--/(${optionals_double_str})/' \\\n        'c/-/(${optionals_single_str})/' \\\n        ${optionals_special_str} \\\n        'p/*/()/'").safe_substitute(preamble='\n# Custom Preamble\n' + preamble + '\n# End Custom Preamble\n' if preamble else '', root_prefix=root_prefix, prog=parser.prog, optionals_double_str=' '.join(sorted(optionals_double)), optionals_single_str=' '.join(sorted(optionals_single)), optionals_special_str=' \\\n        '.join(specials))