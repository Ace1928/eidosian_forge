from binascii import hexlify, unhexlify
from base64 import b64encode, b64decode
import logging; log = logging.getLogger(__name__)
from passlib.utils import to_unicode
from passlib.utils.binary import ab64_decode, ab64_encode
from passlib.utils.compat import str_to_bascii, u, uascii_to_str, unicode
from passlib.crypto.digest import pbkdf2_hmac
import passlib.utils.handlers as uh
class dlitz_pbkdf2_sha1(uh.HasRounds, uh.HasSalt, uh.GenericHandler):
    """This class implements Dwayne Litzenberger's PBKDF2-based crypt algorithm, and follows the :ref:`password-hash-api`.

    It supports a variable-length salt, and a variable number of rounds.

    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:

    :type salt: str
    :param salt:
        Optional salt string.
        If specified, it may be any length, but must use the characters in the regexp range ``[./0-9A-Za-z]``.
        If not specified, a 16 character salt will be autogenerated (this is recommended).

    :type salt_size: int
    :param salt_size:
        Optional number of bytes to use when autogenerating new salts.
        Defaults to 16 bytes, but can be any value between 0 and 1024.

    :type rounds: int
    :param rounds:
        Optional number of rounds to use.
        Defaults to 60000, must be within ``range(1,1<<32)``.

    :type relaxed: bool
    :param relaxed:
        By default, providing an invalid value for one of the other
        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,
        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`
        will be issued instead. Correctable errors include ``rounds``
        that are too small or too large, and ``salt`` strings that are too long.

        .. versionadded:: 1.6
    """
    name = 'dlitz_pbkdf2_sha1'
    setting_kwds = ('salt', 'salt_size', 'rounds')
    ident = u('$p5k2$')
    _stub_checksum = u('0' * 48 + '=')
    default_salt_size = 16
    max_salt_size = 1024
    salt_chars = uh.HASH64_CHARS
    default_rounds = pbkdf2_sha1.default_rounds
    min_rounds = 1
    max_rounds = 4294967295
    rounds_cost = 'linear'

    @classmethod
    def from_string(cls, hash):
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, rounds_base=16, default_rounds=400, handler=cls)
        return cls(rounds=rounds, salt=salt, checksum=chk)

    def to_string(self):
        rounds = self.rounds
        if rounds == 400:
            rounds = None
        return uh.render_mc3(self.ident, rounds, self.salt, self.checksum, rounds_base=16)

    def _get_config(self):
        rounds = self.rounds
        if rounds == 400:
            rounds = None
        return uh.render_mc3(self.ident, rounds, self.salt, None, rounds_base=16)

    def _calc_checksum(self, secret):
        salt = self._get_config()
        result = pbkdf2_hmac('sha1', secret, salt, self.rounds, 24)
        return ab64_encode(result).decode('ascii')