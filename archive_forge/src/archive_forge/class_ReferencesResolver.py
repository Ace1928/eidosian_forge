import re
from typing import Any, Dict, List, Optional, Sequence, Tuple, Type, cast
from docutils import nodes
from docutils.nodes import Element, Node
from sphinx import addnodes
from sphinx.addnodes import pending_xref
from sphinx.application import Sphinx
from sphinx.domains import Domain
from sphinx.errors import NoUri
from sphinx.locale import __
from sphinx.transforms import SphinxTransform
from sphinx.util import logging
from sphinx.util.docutils import SphinxTranslator
from sphinx.util.nodes import find_pending_xref_condition, process_only_nodes
class ReferencesResolver(SphinxPostTransform):
    """
    Resolves cross-references on doctrees.
    """
    default_priority = 10

    def run(self, **kwargs: Any) -> None:
        for node in self.document.findall(addnodes.pending_xref):
            content = self.find_pending_xref_condition(node, ('resolved', '*'))
            if content:
                contnode = cast(Element, content[0].deepcopy())
            else:
                contnode = cast(Element, node[0].deepcopy())
            newnode = None
            typ = node['reftype']
            target = node['reftarget']
            node.setdefault('refdoc', self.env.docname)
            refdoc = node.get('refdoc')
            domain = None
            try:
                if 'refdomain' in node and node['refdomain']:
                    try:
                        domain = self.env.domains[node['refdomain']]
                    except KeyError as exc:
                        raise NoUri(target, typ) from exc
                    newnode = domain.resolve_xref(self.env, refdoc, self.app.builder, typ, target, node, contnode)
                elif typ == 'any':
                    newnode = self.resolve_anyref(refdoc, node, contnode)
                if newnode is None:
                    newnode = self.app.emit_firstresult('missing-reference', self.env, node, contnode, allowed_exceptions=(NoUri,))
                    if newnode is None:
                        self.warn_missing_reference(refdoc, typ, target, node, domain)
            except NoUri:
                newnode = None
            if newnode:
                newnodes: List[Node] = [newnode]
            else:
                newnodes = [contnode]
                if newnode is None and isinstance(node[0], addnodes.pending_xref_condition):
                    matched = self.find_pending_xref_condition(node, ('*',))
                    if matched:
                        newnodes = matched
                    else:
                        logger.warning(__('Could not determine the fallback text for the cross-reference. Might be a bug.'), location=node)
            node.replace_self(newnodes)

    def resolve_anyref(self, refdoc: str, node: pending_xref, contnode: Element) -> Optional[Element]:
        """Resolve reference generated by the "any" role."""
        stddomain = self.env.get_domain('std')
        target = node['reftarget']
        results: List[Tuple[str, Element]] = []
        doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder, 'doc', target, node, contnode)
        if doc_ref:
            results.append(('doc', doc_ref))
        results.extend(stddomain.resolve_any_xref(self.env, refdoc, self.app.builder, target, node, contnode))
        for domain in self.env.domains.values():
            if domain.name == 'std':
                continue
            try:
                results.extend(domain.resolve_any_xref(self.env, refdoc, self.app.builder, target, node, contnode))
            except NotImplementedError:
                for role in domain.roles:
                    res = domain.resolve_xref(self.env, refdoc, self.app.builder, role, target, node, contnode)
                    if res and len(res) > 0 and isinstance(res[0], nodes.Element):
                        results.append(('%s:%s' % (domain.name, role), res))
        if not results:
            return None
        if len(results) > 1:

            def stringify(name: str, node: Element) -> str:
                reftitle = node.get('reftitle', node.astext())
                return ':%s:`%s`' % (name, reftitle)
            candidates = ' or '.join((stringify(name, role) for name, role in results))
            logger.warning(__("more than one target found for 'any' cross-reference %r: could be %s"), target, candidates, location=node)
        res_role, newnode = results[0]
        res_domain = res_role.split(':')[0]
        if len(newnode) > 0 and isinstance(newnode[0], nodes.Element) and newnode[0].get('classes'):
            newnode[0]['classes'].append(res_domain)
            newnode[0]['classes'].append(res_role.replace(':', '-'))
        return newnode

    def warn_missing_reference(self, refdoc: str, typ: str, target: str, node: pending_xref, domain: Optional[Domain]) -> None:
        warn = node.get('refwarn')
        if self.config.nitpicky:
            warn = True
            dtype = '%s:%s' % (domain.name, typ) if domain else typ
            if self.config.nitpick_ignore:
                if (dtype, target) in self.config.nitpick_ignore:
                    warn = False
                if (not domain or domain.name == 'std') and (typ, target) in self.config.nitpick_ignore:
                    warn = False
            if self.config.nitpick_ignore_regex:

                def matches_ignore(entry_type: str, entry_target: str) -> bool:
                    for ignore_type, ignore_target in self.config.nitpick_ignore_regex:
                        if re.fullmatch(ignore_type, entry_type) and re.fullmatch(ignore_target, entry_target):
                            return True
                    return False
                if matches_ignore(dtype, target):
                    warn = False
                if (not domain or domain.name == 'std') and matches_ignore(typ, target):
                    warn = False
        if not warn:
            return
        if self.app.emit_firstresult('warn-missing-reference', domain, node):
            return
        elif domain and typ in domain.dangling_warnings:
            msg = domain.dangling_warnings[typ] % {'target': target}
        elif node.get('refdomain', 'std') not in ('', 'std'):
            msg = __('%s:%s reference target not found: %s') % (node['refdomain'], typ, target)
        else:
            msg = __('%r reference target not found: %s') % (typ, target)
        logger.warning(msg, location=node, type='ref', subtype=typ)

    def find_pending_xref_condition(self, node: pending_xref, conditions: Sequence[str]) -> Optional[List[Node]]:
        for condition in conditions:
            matched = find_pending_xref_condition(node, condition)
            if matched:
                return matched.children
        else:
            return None