import os
from ...utils.filemanip import ensure_list
from ..base import TraitedSpec, File, Str, traits, InputMultiPath, isdefined
from .base import ANTSCommand, ANTSCommandInputSpec, LOCAL_DEFAULT_NUMBER_OF_THREADS
class RegistrationInputSpec(ANTSCommandInputSpec):
    dimension = traits.Enum(3, 2, argstr='--dimensionality %d', usedefault=True, desc='image dimension (2 or 3)')
    fixed_image = InputMultiPath(File(exists=True), mandatory=True, desc='Image to which the moving_image should be transformed(usually a structural image)')
    fixed_image_mask = File(exists=True, argstr='%s', max_ver='2.1.0', xor=['fixed_image_masks'], desc='Mask used to limit metric sampling region of the fixed imagein all stages')
    fixed_image_masks = InputMultiPath(traits.Either('NULL', File(exists=True)), min_ver='2.2.0', xor=['fixed_image_mask'], desc='Masks used to limit metric sampling region of the fixed image, defined per registration stage(Use "NULL" to omit a mask at a given stage)')
    moving_image = InputMultiPath(File(exists=True), mandatory=True, desc='Image that will be registered to the space of fixed_image. This is theimage on which the transformations will be applied to')
    moving_image_mask = File(exists=True, requires=['fixed_image_mask'], max_ver='2.1.0', xor=['moving_image_masks'], desc='mask used to limit metric sampling region of the moving imagein all stages')
    moving_image_masks = InputMultiPath(traits.Either('NULL', File(exists=True)), min_ver='2.2.0', xor=['moving_image_mask'], desc='Masks used to limit metric sampling region of the moving image, defined per registration stage(Use "NULL" to omit a mask at a given stage)')
    save_state = File(argstr='--save-state %s', exists=False, desc='Filename for saving the internal restorable state of the registration')
    restore_state = File(argstr='--restore-state %s', exists=True, desc='Filename for restoring the internal restorable state of the registration')
    initial_moving_transform = InputMultiPath(File(exists=True), argstr='%s', desc='A transform or a list of transforms that should be applied before the registration begins. Note that, when a list is given, the transformations are applied in reverse order.', xor=['initial_moving_transform_com'])
    invert_initial_moving_transform = InputMultiPath(traits.Bool(), requires=['initial_moving_transform'], desc='One boolean or a list of booleans that indicatewhether the inverse(s) of the transform(s) definedin initial_moving_transform should be used.', xor=['initial_moving_transform_com'])
    initial_moving_transform_com = traits.Enum(0, 1, 2, argstr='%s', xor=['initial_moving_transform'], desc='Align the moving_image and fixed_image before registration using the geometric center of the images (=0), the image intensities (=1), or the origin of the images (=2).')
    metric_item_trait = traits.Enum('CC', 'MeanSquares', 'Demons', 'GC', 'MI', 'Mattes')
    metric_stage_trait = traits.Either(metric_item_trait, traits.List(metric_item_trait))
    metric = traits.List(metric_stage_trait, mandatory=True, desc='the metric(s) to use for each stage. Note that multiple metrics per stage are not supported in ANTS 1.9.1 and earlier.')
    metric_weight_item_trait = traits.Float(1.0, usedefault=True)
    metric_weight_stage_trait = traits.Either(metric_weight_item_trait, traits.List(metric_weight_item_trait))
    metric_weight = traits.List(metric_weight_stage_trait, value=[1.0], usedefault=True, requires=['metric'], mandatory=True, desc='the metric weight(s) for each stage. The weights must sum to 1 per stage.')
    radius_bins_item_trait = traits.Int(5, usedefault=True)
    radius_bins_stage_trait = traits.Either(radius_bins_item_trait, traits.List(radius_bins_item_trait))
    radius_or_number_of_bins = traits.List(radius_bins_stage_trait, value=[5], usedefault=True, requires=['metric_weight'], desc='the number of bins in each stage for the MI and Mattes metric, the radius for other metrics')
    sampling_strategy_item_trait = traits.Enum('None', 'Regular', 'Random', None)
    sampling_strategy_stage_trait = traits.Either(sampling_strategy_item_trait, traits.List(sampling_strategy_item_trait))
    sampling_strategy = traits.List(trait=sampling_strategy_stage_trait, requires=['metric_weight'], desc='the metric sampling strategy (strategies) for each stage')
    sampling_percentage_item_trait = traits.Either(traits.Range(low=0.0, high=1.0), None)
    sampling_percentage_stage_trait = traits.Either(sampling_percentage_item_trait, traits.List(sampling_percentage_item_trait))
    sampling_percentage = traits.List(trait=sampling_percentage_stage_trait, requires=['sampling_strategy'], desc='the metric sampling percentage(s) to use for each stage')
    use_estimate_learning_rate_once = traits.List(traits.Bool(), desc='')
    use_histogram_matching = traits.Either(traits.Bool, traits.List(traits.Bool(argstr='%s')), default=True, usedefault=True, desc='Histogram match the images before registration.')
    interpolation = traits.Enum('Linear', 'NearestNeighbor', 'CosineWindowedSinc', 'WelchWindowedSinc', 'HammingWindowedSinc', 'LanczosWindowedSinc', 'BSpline', 'MultiLabel', 'Gaussian', 'GenericLabel', argstr='%s', usedefault=True)
    interpolation_parameters = traits.Either(traits.Tuple(traits.Int()), traits.Tuple(traits.Float(), traits.Float()), traits.Tuple(traits.Str()))
    write_composite_transform = traits.Bool(argstr='--write-composite-transform %d', default_value=False, usedefault=True, desc='')
    collapse_output_transforms = traits.Bool(argstr='--collapse-output-transforms %d', default_value=True, usedefault=True, desc='Collapse output transforms. Specifically, enabling this option combines all adjacent linear transforms and composes all adjacent displacement field transforms before writing the results to disk.')
    initialize_transforms_per_stage = traits.Bool(argstr='--initialize-transforms-per-stage %d', default_value=False, usedefault=True, desc='Initialize linear transforms from the previous stage. By enabling this option, the current linear stage transform is directly initialized from the previous stages linear transform; this allows multiple linear stages to be run where each stage directly updates the estimated linear transform from the previous stage. (e.g. Translation -> Rigid -> Affine). ')
    float = traits.Bool(argstr='--float %d', default_value=False, desc='Use float instead of double for computations.')
    transforms = traits.List(traits.Enum('Rigid', 'Affine', 'CompositeAffine', 'Similarity', 'Translation', 'BSpline', 'GaussianDisplacementField', 'TimeVaryingVelocityField', 'TimeVaryingBSplineVelocityField', 'SyN', 'BSplineSyN', 'Exponential', 'BSplineExponential'), argstr='%s', mandatory=True)
    transform_parameters = traits.List(traits.Either(traits.Tuple(traits.Float()), traits.Tuple(traits.Float(), traits.Float(), traits.Float()), traits.Tuple(traits.Float(), traits.Int(), traits.Int(), traits.Int()), traits.Tuple(traits.Float(), traits.Int(), traits.Float(), traits.Float(), traits.Float(), traits.Float()), traits.Tuple(traits.Float(), traits.Float(), traits.Float(), traits.Int()), traits.Tuple(traits.Float(), traits.Int(), traits.Int(), traits.Int(), traits.Int())))
    restrict_deformation = traits.List(traits.List(traits.Range(low=0.0, high=1.0)), desc="This option allows the user to restrict the optimization of the displacement field, translation, rigid or affine transform on a per-component basis. For example, if one wants to limit the deformation or rotation of 3-D volume to the  first two dimensions, this is possible by specifying a weight vector of '1x1x0' for a deformation field or '1x1x0x1x1x0' for a rigid transformation.  Low-dimensional restriction only works if there are no preceding transformations.")
    number_of_iterations = traits.List(traits.List(traits.Int()))
    smoothing_sigmas = traits.List(traits.List(traits.Float()), mandatory=True)
    sigma_units = traits.List(traits.Enum('mm', 'vox'), requires=['smoothing_sigmas'], desc='units for smoothing sigmas')
    shrink_factors = traits.List(traits.List(traits.Int()), mandatory=True)
    convergence_threshold = traits.List(trait=traits.Float(), value=[1e-06], minlen=1, requires=['number_of_iterations'], usedefault=True)
    convergence_window_size = traits.List(trait=traits.Int(), value=[10], minlen=1, requires=['convergence_threshold'], usedefault=True)
    output_transform_prefix = Str('transform', usedefault=True, argstr='%s', desc='')
    output_warped_image = traits.Either(traits.Bool, File(), hash_files=False, desc='')
    output_inverse_warped_image = traits.Either(traits.Bool, File(), hash_files=False, requires=['output_warped_image'], desc='')
    winsorize_upper_quantile = traits.Range(low=0.0, high=1.0, value=1.0, argstr='%s', usedefault=True, desc='The Upper quantile to clip image ranges')
    winsorize_lower_quantile = traits.Range(low=0.0, high=1.0, value=0.0, argstr='%s', usedefault=True, desc='The Lower quantile to clip image ranges')
    random_seed = traits.Int(argstr='--random-seed %d', desc='Fixed seed for random number generation', min_ver='2.3.0')
    verbose = traits.Bool(argstr='-v', default_value=False, usedefault=True, nohash=True)