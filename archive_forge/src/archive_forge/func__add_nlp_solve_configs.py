from pyomo.common.config import (
from pyomo.common.deprecation import deprecation_warning
from pyomo.contrib.gdpopt.discrete_problem_initialize import valid_init_strategies
from pyomo.contrib.gdpopt.nlp_initialization import restore_vars_to_original_values
from pyomo.contrib.gdpopt.util import a_logger, _DoNothing
def _add_nlp_solve_configs(CONFIG, default_nlp_init_method):
    CONFIG.declare('integer_tolerance', ConfigValue(default=1e-05, description='Tolerance on integral values.'))
    CONFIG.declare('constraint_tolerance', ConfigValue(default=1e-06, description='\n            Tolerance on constraint satisfaction.\n    \n            Increasing this tolerance corresponds to being more conservative in\n            declaring the model or an NLP subproblem to be infeasible.\n            '))
    CONFIG.declare('variable_tolerance', ConfigValue(default=1e-08, description='Tolerance on variable bounds.'))
    CONFIG.declare('subproblem_initialization_method', ConfigValue(default=default_nlp_init_method, description='"\n            callback to specify custom routines to initialize the\n            (MI)NLP subproblems.', doc='\n            Callback to specify custom routines for initializing the (MI)NLP\n            subproblems. This method is called after the discrete problem solution\n            is fixed in the subproblem and before the subproblem is solved (or\n            pre-solved).\n    \n            For algorithms with a discrete problem relaxation:\n            This method accepts three arguments: the solver object, the subproblem\n            GDPopt utility block and the discrete problem GDPopt utility block. The\n            discrete problem contains the most recent discrete problem solution.\n    \n            For algorithms without a discrete problem relaxation:\n            This method accepts four arguments: the list of Disjuncts that are\n            currently fixed as being active, a list of values for the non-indicator\n            BooleanVars (empty if force_nlp_subproblem=False), and a list of\n            values for the integer vars (also empty if force_nlp_subproblem=False),\n            and last the subproblem GDPopt utility block.\n    \n            The return of this method will be unused: The method should directly\n            set the value of the variables on the subproblem\n            '))
    CONFIG.declare('call_before_subproblem_solve', ConfigValue(default=_DoNothing, description='callback hook before calling the subproblem solver', doc="\n            Callback called right before the (MI)NLP subproblem is solved.\n            Takes three arguments: The solver object, the subproblem and the\n            GDPopt utility block on the subproblem.\n    \n            Note that unless you are *very* confident in what you are doing, the\n            subproblem should not be modified in this callback: it should be used\n            to interrogate the problem only.\n    \n            To initialize the problem before it is solved, please specify a method\n            in the 'subproblem_initialization_method' argument.\n            "))
    CONFIG.declare('call_after_subproblem_solve', ConfigValue(default=_DoNothing, description='\n            callback hook after a solution of the\n            "nonlinear subproblem', doc='\n            Callback called right after the (MI)NLP subproblem is solved.\n            Takes three arguments: The solver object, the subproblem, and the\n            GDPopt utility block on the subproblem.\n    \n            Note that unless you are *very* confident in what you are doing, the\n            subproblem should not be modified in this callback: it should be used\n            to interrogate the problem only.\n            '))
    CONFIG.declare('call_after_subproblem_feasible', ConfigValue(default=_DoNothing, description='\n            callback hook after feasible solution of\n            the nonlinear subproblem', doc='\n            Callback called right after the (MI)NLP subproblem is solved,\n            if it was feasible. Takes three arguments: The solver object, the\n            subproblem and the GDPopt utility block on the subproblem.\n    \n            Note that unless you are *very* confident in what you are doing, the\n            subproblem should not be modified in this callback: it should be used\n            to interrogate the problem only.\n            '))
    CONFIG.declare('force_subproblem_nlp', ConfigValue(default=False, description='Force subproblems to be NLP, even if discrete variables\n            exist.'))
    CONFIG.declare('subproblem_presolve', ConfigValue(default=True, description='\n        Flag to enable or disable subproblem presolve.\n        Default=True.', domain=bool))
    CONFIG.declare('tighten_nlp_var_bounds', ConfigValue(default=False, description='\n            Whether or not to do feasibility-based bounds tightening\n            on the variables in the NLP subproblem before solving it.', domain=bool))
    CONFIG.declare('round_discrete_vars', ConfigValue(default=True, description='Flag to round subproblem discrete variable values to the\n            nearest integer. Rounding is done before fixing disjuncts.'))
    CONFIG.declare('max_fbbt_iterations', ConfigValue(default=3, description='\n            Maximum number of feasibility-based bounds tightening\n            iterations to do during NLP subproblem preprocessing.', domain=PositiveInt))