import contextlib
import os
from .. import branch as _mod_branch
from .. import conflicts, errors, memorytree
from .. import merge as _mod_merge
from .. import option
from .. import revision as _mod_revision
from .. import tests, transform
from ..bzr import inventory, knit, versionedfile
from ..bzr.conflicts import (ContentsConflict, DeletingParent, MissingParent,
from ..conflicts import ConflictList
from ..errors import NoCommits, UnrelatedBranches
from ..merge import _PlanMerge, merge_inner, transform_tree
from ..osutils import basename, file_kind, pathjoin
from ..workingtree import PointlessMerge, WorkingTree
from . import (TestCaseWithMemoryTransport, TestCaseWithTransport, features,
class TestMergerEntriesLCAOnDisk(tests.TestCaseWithTransport):

    def get_builder(self):
        builder = self.make_branch_builder('path')
        builder.start_series()
        self.addCleanup(builder.finish_series)
        return builder

    def get_wt_from_builder(self, builder):
        """Get a real WorkingTree from the builder."""
        the_branch = builder.get_branch()
        wt = the_branch.controldir.create_workingtree()
        wt._branch = the_branch
        wt.lock_write()
        self.addCleanup(wt.unlock)
        return wt

    def do_merge(self, builder, other_revision_id):
        wt = self.get_wt_from_builder(builder)
        merger = _mod_merge.Merger.from_revision_ids(wt, other_revision_id)
        merger.merge_type = _mod_merge.Merge3Merger
        return (wt, merger.do_merge())

    def test_simple_lca(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('a', b'a-id', 'file', b'a\nb\nc\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [], revision_id=b'E-id')
        builder.build_snapshot([b'B-id', b'C-id'], [('modify', ('a', b'a\nb\nc\nd\ne\nf\n'))], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'E-id')
        self.assertEqual([], conflicts)
        self.assertEqual(b'a\nb\nc\nd\ne\nf\n', wt.get_file_text('a'))

    def test_conflict_without_lca(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'a\nb\nc\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [('rename', ('foo', 'bar'))], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('rename', ('foo', 'bar'))], revision_id=b'E-id')
        builder.build_snapshot([b'E-id'], [('rename', ('bar', 'baz'))], revision_id=b'F-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'F-id')
        self.assertEqual([], conflicts)
        self.assertEqual('baz', wt.id2path(b'foo-id'))

    def test_other_deletes_lca_renames(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'a\nb\nc\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [('rename', ('foo', 'bar'))], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('rename', ('foo', 'bar'))], revision_id=b'E-id')
        builder.build_snapshot([b'E-id'], [('unversion', 'bar')], revision_id=b'F-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'F-id')
        self.assertEqual([], conflicts)
        self.assertRaises(errors.NoSuchId, wt.id2path, b'foo-id')

    def test_executable_changes(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'a\nb\nc\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'B-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        builder.build_snapshot([b'C-id', b'B-id'], [], revision_id=b'E-id')
        wt = self.get_wt_from_builder(builder)
        with wt.transform() as tt:
            tt.set_executability(True, tt.trans_id_tree_path('foo'))
            tt.apply()
        self.assertTrue(wt.is_executable('foo'))
        wt.commit('F-id', rev_id=b'F-id')
        wt.set_parent_ids([b'D-id'])
        wt.branch.set_last_revision_info(3, b'D-id')
        wt.revert()
        self.assertFalse(wt.is_executable('foo'))
        conflicts = wt.merge_from_branch(wt.branch, to_revision=b'F-id')
        self.assertEqual(0, len(conflicts))
        self.assertTrue(wt.is_executable('foo'))

    def test_create_symlink(self):
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'B-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        builder.build_snapshot([b'C-id', b'B-id'], [], revision_id=b'E-id')
        wt = self.get_wt_from_builder(builder)
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        self.assertEqual('bar', wt.get_symlink_target('foo'))
        wt.commit('add symlink', rev_id=b'F-id')
        wt.set_parent_ids([b'D-id'])
        wt.branch.set_last_revision_info(3, b'D-id')
        wt.revert()
        self.assertFalse(wt.is_versioned('foo'))
        conflicts = wt.merge_from_branch(wt.branch, to_revision=b'F-id')
        self.assertEqual(0, len(conflicts))
        self.assertEqual(b'foo-id', wt.path2id('foo'))
        self.assertEqual('bar', wt.get_symlink_target('foo'))

    def test_both_sides_revert(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'A content\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'B-id')
        builder.build_snapshot([b'A-id'], [('modify', ('foo', b'C content\n'))], revision_id=b'C-id')
        builder.build_snapshot([b'C-id', b'B-id'], [], revision_id=b'E-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'E-id')
        self.assertEqual(1, len(conflicts))
        self.assertEqualDiff(b'<<<<<<< TREE\nB content\n=======\nC content\n>>>>>>> MERGE-SOURCE\n', wt.get_file_text('foo'))

    def test_modified_symlink(self):
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        wt = self.make_branch_and_tree('path')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        wt.commit('add symlink', rev_id=b'A-id')
        os.remove('path/foo')
        os.symlink('baz', 'path/foo')
        wt.commit('foo => baz', rev_id=b'B-id')
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.revert()
        wt.commit('C', rev_id=b'C-id')
        wt.merge_from_branch(wt.branch, b'B-id')
        self.assertEqual('baz', wt.get_symlink_target('foo'))
        wt.commit('E merges C & B', rev_id=b'E-id')
        os.remove('path/foo')
        os.symlink('bing', 'path/foo')
        wt.commit('F foo => bing', rev_id=b'F-id')
        wt.set_last_revision(b'B-id')
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.revert()
        wt.merge_from_branch(wt.branch, b'C-id')
        wt.commit('D merges B & C', rev_id=b'D-id')
        conflicts = wt.merge_from_branch(wt.branch, to_revision=b'F-id')
        self.assertEqual(0, len(conflicts))
        self.assertEqual('bing', wt.get_symlink_target('foo'))

    def test_renamed_symlink(self):
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        wt = self.make_branch_and_tree('path')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        wt.commit('A add symlink', rev_id=b'A-id')
        wt.rename_one('foo', 'barry')
        wt.commit('B foo => barry', rev_id=b'B-id')
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.revert()
        wt.commit('C', rev_id=b'C-id')
        wt.merge_from_branch(wt.branch, b'B-id')
        self.assertEqual('barry', wt.id2path(b'foo-id'))
        self.assertEqual('bar', wt.get_symlink_target('barry'))
        wt.commit('E merges C & B', rev_id=b'E-id')
        wt.rename_one('barry', 'blah')
        wt.commit('F barry => blah', rev_id=b'F-id')
        wt.set_last_revision(b'B-id')
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.revert()
        wt.merge_from_branch(wt.branch, b'C-id')
        wt.commit('D merges B & C', rev_id=b'D-id')
        self.assertEqual('barry', wt.id2path(b'foo-id'))
        merger = _mod_merge.Merger.from_revision_ids(wt, b'F-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        root_id = wt.path2id('')
        entries = list(merge_obj._entries_lca())
        self.assertEqual([(b'foo-id', False, (('foo', ['barry', 'foo']), 'blah', 'barry'), ((root_id, [root_id, root_id]), root_id, root_id), (('foo', ['barry', 'foo']), 'blah', 'barry'), ((False, [False, False]), False, False), False)], entries)
        conflicts = wt.merge_from_branch(wt.branch, to_revision=b'F-id')
        self.assertEqual(0, len(conflicts))
        self.assertEqual('blah', wt.id2path(b'foo-id'))

    def test_symlink_no_content_change(self):
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        wt = self.make_branch_and_tree('path')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        wt.commit('add symlink', rev_id=b'A-id')
        os.remove('path/foo')
        os.symlink('baz', 'path/foo')
        wt.commit('foo => baz', rev_id=b'B-id')
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.revert()
        wt.commit('C', rev_id=b'C-id')
        wt.merge_from_branch(wt.branch, b'B-id')
        self.assertEqual('baz', wt.get_symlink_target('foo'))
        wt.commit('E merges C & B', rev_id=b'E-id')
        wt.set_last_revision(b'B-id')
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.revert()
        wt.merge_from_branch(wt.branch, b'C-id')
        wt.commit('D merges B & C', rev_id=b'D-id')
        os.remove('path/foo')
        os.symlink('bing', 'path/foo')
        wt.commit('F foo => bing', rev_id=b'F-id')
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        self.assertEqual([], list(merge_obj._entries_lca()))
        conflicts = wt.merge_from_branch(wt.branch, to_revision=b'E-id')
        self.assertEqual(0, len(conflicts))
        self.assertEqual('bing', wt.get_symlink_target('foo'))

    def test_symlink_this_changed_kind(self):
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        wt = self.make_branch_and_tree('path')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        wt.commit('base', rev_id=b'A-id')
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        wt.commit('add symlink foo => bar', rev_id=b'B-id')
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.revert()
        wt.commit('C', rev_id=b'C-id')
        wt.merge_from_branch(wt.branch, b'B-id')
        self.assertEqual('bar', wt.get_symlink_target('foo'))
        os.remove('path/foo')
        os.symlink('bing', 'path/foo')
        wt.commit('E merges C & B, overrides to bing', rev_id=b'E-id')
        wt.set_last_revision(b'B-id')
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.revert()
        wt.merge_from_branch(wt.branch, b'C-id')
        os.remove('path/foo')
        self.build_tree_contents([('path/foo', b'file content\n')])
        list(wt.iter_changes(wt.basis_tree()))
        wt.commit('D merges B & C, makes it a file', rev_id=b'D-id')
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        entries = list(merge_obj._entries_lca())
        root_id = wt.path2id('')
        self.assertEqual([(b'foo-id', True, ((None, ['foo', None]), 'foo', 'foo'), ((None, [root_id, None]), root_id, root_id), ((None, ['foo', None]), 'foo', 'foo'), ((None, [False, None]), False, False), False)], entries)

    def test_symlink_all_wt(self):
        """Check behavior if all trees are Working Trees."""
        self.requireFeature(features.SymlinkFeature(self.test_dir))
        wt = self.make_branch_and_tree('path')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        os.symlink('bar', 'path/foo')
        wt.add(['foo'], ids=[b'foo-id'])
        wt.commit('add symlink', rev_id=b'A-id')
        os.remove('path/foo')
        os.symlink('baz', 'path/foo')
        wt.commit('foo => baz', rev_id=b'B-id')
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.revert()
        wt.commit('C', rev_id=b'C-id')
        wt.merge_from_branch(wt.branch, b'B-id')
        self.assertEqual('baz', wt.get_symlink_target('foo'))
        wt.commit('E merges C & B', rev_id=b'E-id')
        os.remove('path/foo')
        os.symlink('bing', 'path/foo')
        wt.commit('F foo => bing', rev_id=b'F-id')
        wt.set_last_revision(b'B-id')
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.revert()
        wt.merge_from_branch(wt.branch, b'C-id')
        wt.commit('D merges B & C', rev_id=b'D-id')
        wt_base = wt.controldir.sprout('base', b'A-id').open_workingtree()
        wt_base.lock_read()
        self.addCleanup(wt_base.unlock)
        wt_lca1 = wt.controldir.sprout('b-tree', b'B-id').open_workingtree()
        wt_lca1.lock_read()
        self.addCleanup(wt_lca1.unlock)
        wt_lca2 = wt.controldir.sprout('c-tree', b'C-id').open_workingtree()
        wt_lca2.lock_read()
        self.addCleanup(wt_lca2.unlock)
        wt_other = wt.controldir.sprout('other', b'F-id').open_workingtree()
        wt_other.lock_read()
        self.addCleanup(wt_other.unlock)
        merge_obj = _mod_merge.Merge3Merger(wt, wt, wt_base, wt_other, lca_trees=[wt_lca1, wt_lca2], do_merge=False)
        entries = list(merge_obj._entries_lca())
        root_id = wt.path2id('')
        self.assertEqual([(b'foo-id', True, (('foo', ['foo', 'foo']), 'foo', 'foo'), ((root_id, [root_id, root_id]), root_id, root_id), (('foo', ['foo', 'foo']), 'foo', 'foo'), ((False, [False, False]), False, False), False)], entries)

    def test_other_reverted_path_to_base(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'a\nb\nc\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [('rename', ('foo', 'bar'))], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('rename', ('foo', 'bar'))], revision_id=b'E-id')
        builder.build_snapshot([b'E-id'], [('rename', ('bar', 'foo'))], revision_id=b'F-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'F-id')
        self.assertEqual([], conflicts)
        self.assertEqual('foo', wt.id2path(b'foo-id'))

    def test_other_reverted_content_to_base(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'base content\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'E-id')
        builder.build_snapshot([b'E-id'], [('modify', ('foo', b'base content\n'))], revision_id=b'F-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'F-id')
        self.assertEqual([], conflicts)
        self.assertEqual(b'base content\n', wt.get_file_text('foo'))

    def test_other_modified_content(self):
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('foo', b'foo-id', 'file', b'base content\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [], revision_id=b'C-id')
        builder.build_snapshot([b'A-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'B-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'E-id')
        builder.build_snapshot([b'E-id'], [('modify', ('foo', b'F content\n'))], revision_id=b'F-id')
        builder.build_snapshot([b'B-id', b'C-id'], [], revision_id=b'D-id')
        wt, conflicts = self.do_merge(builder, b'F-id')
        self.assertEqual([], conflicts)
        self.assertEqual(b'F content\n', wt.get_file_text('foo'))

    def test_all_wt(self):
        """Check behavior if all trees are Working Trees."""
        builder = self.get_builder()
        builder.build_snapshot(None, [('add', ('', b'a-root-id', 'directory', None)), ('add', ('a', b'a-id', 'file', b'base content\n')), ('add', ('foo', b'foo-id', 'file', b'base content\n'))], revision_id=b'A-id')
        builder.build_snapshot([b'A-id'], [('modify', ('foo', b'B content\n'))], revision_id=b'B-id')
        builder.build_snapshot([b'A-id'], [('rename', ('a', 'b'))], revision_id=b'C-id')
        builder.build_snapshot([b'C-id', b'B-id'], [('rename', ('b', 'c')), ('modify', ('foo', b'E content\n'))], revision_id=b'E-id')
        builder.build_snapshot([b'B-id', b'C-id'], [('rename', ('a', 'b'))], revision_id=b'D-id')
        wt_this = self.get_wt_from_builder(builder)
        wt_base = wt_this.controldir.sprout('base', b'A-id').open_workingtree()
        wt_base.lock_read()
        self.addCleanup(wt_base.unlock)
        wt_lca1 = wt_this.controldir.sprout('b-tree', b'B-id').open_workingtree()
        wt_lca1.lock_read()
        self.addCleanup(wt_lca1.unlock)
        wt_lca2 = wt_this.controldir.sprout('c-tree', b'C-id').open_workingtree()
        wt_lca2.lock_read()
        self.addCleanup(wt_lca2.unlock)
        wt_other = wt_this.controldir.sprout('other', b'E-id').open_workingtree()
        wt_other.lock_read()
        self.addCleanup(wt_other.unlock)
        merge_obj = _mod_merge.Merge3Merger(wt_this, wt_this, wt_base, wt_other, lca_trees=[wt_lca1, wt_lca2], do_merge=False)
        entries = list(merge_obj._entries_lca())
        root_id = b'a-root-id'
        self.assertEqual([(b'a-id', False, (('a', ['a', 'b']), 'c', 'b'), ((root_id, [root_id, root_id]), root_id, root_id), (('a', ['a', 'b']), 'c', 'b'), ((False, [False, False]), False, False), False), (b'foo-id', True, (('foo', ['foo', 'foo']), 'foo', 'foo'), ((root_id, [root_id, root_id]), root_id, root_id), (('foo', ['foo', 'foo']), 'foo', 'foo'), ((False, [False, False]), False, False), False)], entries)

    def test_nested_tree_unmodified(self):
        wt = self.make_branch_and_tree('tree', format='development-subtree')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        sub_tree = self.make_branch_and_tree('tree/sub-tree', format='development-subtree')
        wt.set_root_id(b'a-root-id')
        sub_tree.set_root_id(b'sub-tree-root')
        self.build_tree_contents([('tree/sub-tree/file', b'text1')])
        sub_tree.add('file')
        sub_tree.commit('foo', rev_id=b'sub-A-id')
        wt.add_reference(sub_tree)
        wt.commit('set text to 1', rev_id=b'A-id', recursive=None)
        wt.commit('B', rev_id=b'B-id', recursive=None)
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.commit('C', rev_id=b'C-id', recursive=None)
        wt.merge_from_branch(wt.branch, to_revision=b'B-id')
        wt.commit('E', rev_id=b'E-id', recursive=None)
        wt.set_parent_ids([b'B-id', b'C-id'])
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.commit('D', rev_id=b'D-id', recursive=None)
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        entries = list(merge_obj._entries_lca())
        self.assertEqual([], entries)

    def test_nested_tree_subtree_modified(self):
        wt = self.make_branch_and_tree('tree', format='development-subtree')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        sub_tree = self.make_branch_and_tree('tree/sub', format='development-subtree')
        wt.set_root_id(b'a-root-id')
        sub_tree.set_root_id(b'sub-tree-root')
        self.build_tree_contents([('tree/sub/file', b'text1')])
        sub_tree.add('file')
        sub_tree.commit('foo', rev_id=b'sub-A-id')
        wt.add_reference(sub_tree)
        wt.commit('set text to 1', rev_id=b'A-id', recursive=None)
        wt.commit('B', rev_id=b'B-id', recursive=None)
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.commit('C', rev_id=b'C-id', recursive=None)
        wt.merge_from_branch(wt.branch, to_revision=b'B-id')
        self.build_tree_contents([('tree/sub/file', b'text2')])
        sub_tree.commit('modify contents', rev_id=b'sub-B-id')
        wt.commit('E', rev_id=b'E-id', recursive=None)
        wt.set_parent_ids([b'B-id', b'C-id'])
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.commit('D', rev_id=b'D-id', recursive=None)
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        entries = list(merge_obj._entries_lca())
        self.assertEqual([], entries)

    def test_nested_tree_subtree_renamed(self):
        wt = self.make_branch_and_tree('tree', format='development-subtree')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        sub_tree = self.make_branch_and_tree('tree/sub', format='development-subtree')
        wt.set_root_id(b'a-root-id')
        sub_tree.set_root_id(b'sub-tree-root')
        self.build_tree_contents([('tree/sub/file', b'text1')])
        sub_tree.add('file')
        sub_tree.commit('foo', rev_id=b'sub-A-id')
        wt.add_reference(sub_tree)
        wt.commit('set text to 1', rev_id=b'A-id', recursive=None)
        wt.commit('B', rev_id=b'B-id', recursive=None)
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.commit('C', rev_id=b'C-id', recursive=None)
        wt.merge_from_branch(wt.branch, to_revision=b'B-id')
        wt.rename_one('sub', 'alt_sub')
        wt.commit('E', rev_id=b'E-id', recursive=None)
        wt.set_last_revision(b'B-id')
        wt.revert()
        wt.set_parent_ids([b'B-id', b'C-id'])
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.commit('D', rev_id=b'D-id', recursive=None)
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        entries = list(merge_obj._entries_lca())
        root_id = b'a-root-id'
        self.assertEqual([(b'sub-tree-root', False, (('sub', ['sub', 'sub']), 'alt_sub', 'sub'), ((root_id, [root_id, root_id]), root_id, root_id), (('sub', ['sub', 'sub']), 'alt_sub', 'sub'), ((False, [False, False]), False, False), False)], entries)

    def test_nested_tree_subtree_renamed_and_modified(self):
        wt = self.make_branch_and_tree('tree', format='development-subtree')
        wt.lock_write()
        self.addCleanup(wt.unlock)
        sub_tree = self.make_branch_and_tree('tree/sub', format='development-subtree')
        wt.set_root_id(b'a-root-id')
        sub_tree.set_root_id(b'sub-tree-root')
        self.build_tree_contents([('tree/sub/file', b'text1')])
        sub_tree.add('file')
        sub_tree.commit('foo', rev_id=b'sub-A-id')
        wt.add_reference(sub_tree)
        wt.commit('set text to 1', rev_id=b'A-id', recursive=None)
        wt.commit('B', rev_id=b'B-id', recursive=None)
        wt.set_last_revision(b'A-id')
        wt.branch.set_last_revision_info(1, b'A-id')
        wt.commit('C', rev_id=b'C-id', recursive=None)
        wt.merge_from_branch(wt.branch, to_revision=b'B-id')
        self.build_tree_contents([('tree/sub/file', b'text2')])
        sub_tree.commit('modify contents', rev_id=b'sub-B-id')
        wt.rename_one('sub', 'alt_sub')
        wt.commit('E', rev_id=b'E-id', recursive=None)
        wt.set_last_revision(b'B-id')
        wt.revert()
        wt.set_parent_ids([b'B-id', b'C-id'])
        wt.branch.set_last_revision_info(2, b'B-id')
        wt.commit('D', rev_id=b'D-id', recursive=None)
        merger = _mod_merge.Merger.from_revision_ids(wt, b'E-id')
        merger.merge_type = _mod_merge.Merge3Merger
        merge_obj = merger.make_merger()
        entries = list(merge_obj._entries_lca())
        root_id = b'a-root-id'
        self.assertEqual([(b'sub-tree-root', False, (('sub', ['sub', 'sub']), 'alt_sub', 'sub'), ((root_id, [root_id, root_id]), root_id, root_id), (('sub', ['sub', 'sub']), 'alt_sub', 'sub'), ((False, [False, False]), False, False), False)], entries)