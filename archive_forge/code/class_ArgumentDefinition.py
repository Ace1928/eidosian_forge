from __future__ import annotations
import argparse
import dataclasses
import enum
import functools
import itertools
import json
import shlex
from typing import (
import rich.markup
import shtab
from . import _fields, _instantiators, _resolver, _strings
from ._typing import TypeForm
from .conf import _markers
@dataclasses.dataclass(frozen=True)
class ArgumentDefinition:
    """Structure containing everything needed to define an argument."""
    intern_prefix: str
    extern_prefix: str
    subcommand_prefix: str
    field: _fields.FieldDefinition
    type_from_typevar: Dict[TypeVar, TypeForm[Any]]

    def add_argument(self, parser: Union[argparse.ArgumentParser, argparse._ArgumentGroup]) -> None:
        """Add a defined argument to a parser."""
        kwargs = dict(self.lowered.__dict__)
        kwargs.pop('instantiator')
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        name_or_flag = kwargs.pop('name_or_flag')
        if len(name_or_flag) == 0:
            name_or_flag = _strings.dummy_field_name
        action = kwargs.get('action', None)
        if action != 'append':
            kwargs['default'] = _fields.MISSING_NONPROP
        elif action == BooleanOptionalAction:
            pass
        else:
            kwargs['default'] = []
        if self.field.argconf.metavar is not None:
            kwargs['metavar'] = self.field.argconf.metavar
        if self.field.argconf.aliases is not None and (not self.field.is_positional()):
            arg = parser.add_argument(name_or_flag, *self.field.argconf.aliases, **kwargs)
        else:
            if self.field.argconf.aliases is not None:
                import warnings
                warnings.warn(f'Aliases were specified, but {name_or_flag} is positional. Aliases will be ignored.')
            arg = parser.add_argument(name_or_flag, **kwargs)
        if 'choices' not in kwargs:
            name_suggests_dir = self.field.intern_name.endswith('_dir') or self.field.intern_name.endswith('_directory') or self.field.intern_name.endswith('_folder')
            name_suggests_path = self.field.intern_name.endswith('_file') or self.field.intern_name.endswith('_path') or self.field.intern_name.endswith('_filename') or name_suggests_dir
            complete_as_path = 'Path' in str(self.field.type_or_callable) or ('str' in str(self.field.type_or_callable) and name_suggests_path)
            if complete_as_path:
                arg.complete = shtab.DIRECTORY if name_suggests_dir else shtab.FILE

    @cached_property
    def lowered(self) -> LoweredArgumentDefinition:
        """Lowered argument definition, generated by applying a sequence of rules."""
        rules = (_rule_handle_defaults, _rule_handle_boolean_flags, _rule_recursive_instantiator_from_type, _rule_convert_defaults_to_strings, _rule_generate_helptext, _rule_set_name_or_flag_and_dest, _rule_positional_special_handling, _rule_static_cast_choices_to_patched_list)
        return functools.reduce(lambda lowered, rule: rule(self, lowered), rules, LoweredArgumentDefinition())