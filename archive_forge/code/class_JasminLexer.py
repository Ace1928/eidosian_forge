import re
from pygments.lexer import Lexer, RegexLexer, include, bygroups, using, \
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
from pygments.util import shebang_matches
from pygments import unistring as uni
class JasminLexer(RegexLexer):
    """
    For `Jasmin <http://jasmin.sourceforge.net/>`_ assembly code.

    .. versionadded:: 2.0
    """
    name = 'Jasmin'
    aliases = ['jasmin', 'jasminxt']
    filenames = ['*.j']
    _whitespace = ' \\n\\t\\r'
    _ws = '(?:[%s]+)' % _whitespace
    _separator = '%s:=' % _whitespace
    _break = '(?=[%s]|$)' % _separator
    _name = '[^%s]+' % _separator
    _unqualified_name = '(?:[^%s.;\\[/]+)' % _separator
    tokens = {'default': [('\\n', Text, '#pop'), ("'", String.Single, ('#pop', 'quote')), ('"', String.Double, 'string'), ('=', Punctuation), (':', Punctuation, 'label'), (_ws, Text), (';.*', Comment.Single), ('(\\$[-+])?0x-?[\\da-fA-F]+%s' % _break, Number.Hex), ('(\\$[-+]|\\+)?-?\\d+%s' % _break, Number.Integer), ('-?(\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?[fFdD]?[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]*%s' % _break, Number.Float), ('\\$%s' % _name, Name.Variable), ('\\.annotation%s' % _break, Keyword.Reserved, 'annotation'), ('(\\.attribute|\\.bytecode|\\.debug|\\.deprecated|\\.enclosing|\\.interface|\\.line|\\.signature|\\.source|\\.stack|\\.var|abstract|annotation|bridge|class|default|enum|field|final|fpstrict|interface|native|private|protected|public|signature|static|synchronized|synthetic|transient|varargs|volatile)%s' % _break, Keyword.Reserved), ('\\.catch%s' % _break, Keyword.Reserved, 'caught-exception'), ('(\\.class|\\.implements|\\.inner|\\.super|inner|invisible|invisibleparam|outer|visible|visibleparam)%s' % _break, Keyword.Reserved, 'class/convert-dots'), ('\\.field%s' % _break, Keyword.Reserved, ('descriptor/convert-dots', 'field')), ('(\\.end|\\.limit|use)%s' % _break, Keyword.Reserved, 'no-verification'), ('\\.method%s' % _break, Keyword.Reserved, 'method'), ('\\.set%s' % _break, Keyword.Reserved, 'var'), ('\\.throws%s' % _break, Keyword.Reserved, 'exception'), ('(from|offset|to|using)%s' % _break, Keyword.Reserved, 'label'), ('is%s' % _break, Keyword.Reserved, ('descriptor/convert-dots', 'var')), ('(locals|stack)%s' % _break, Keyword.Reserved, 'verification'), ('method%s' % _break, Keyword.Reserved, 'enclosing-method'), (words(('aaload', 'aastore', 'aconst_null', 'aload', 'aload_0', 'aload_1', 'aload_2', 'aload_3', 'aload_w', 'areturn', 'arraylength', 'astore', 'astore_0', 'astore_1', 'astore_2', 'astore_3', 'astore_w', 'athrow', 'baload', 'bastore', 'bipush', 'breakpoint', 'caload', 'castore', 'd2f', 'd2i', 'd2l', 'dadd', 'daload', 'dastore', 'dcmpg', 'dcmpl', 'dconst_0', 'dconst_1', 'ddiv', 'dload', 'dload_0', 'dload_1', 'dload_2', 'dload_3', 'dload_w', 'dmul', 'dneg', 'drem', 'dreturn', 'dstore', 'dstore_0', 'dstore_1', 'dstore_2', 'dstore_3', 'dstore_w', 'dsub', 'dup', 'dup2', 'dup2_x1', 'dup2_x2', 'dup_x1', 'dup_x2', 'f2d', 'f2i', 'f2l', 'fadd', 'faload', 'fastore', 'fcmpg', 'fcmpl', 'fconst_0', 'fconst_1', 'fconst_2', 'fdiv', 'fload', 'fload_0', 'fload_1', 'fload_2', 'fload_3', 'fload_w', 'fmul', 'fneg', 'frem', 'freturn', 'fstore', 'fstore_0', 'fstore_1', 'fstore_2', 'fstore_3', 'fstore_w', 'fsub', 'i2b', 'i2c', 'i2d', 'i2f', 'i2l', 'i2s', 'iadd', 'iaload', 'iand', 'iastore', 'iconst_0', 'iconst_1', 'iconst_2', 'iconst_3', 'iconst_4', 'iconst_5', 'iconst_m1', 'idiv', 'iinc', 'iinc_w', 'iload', 'iload_0', 'iload_1', 'iload_2', 'iload_3', 'iload_w', 'imul', 'ineg', 'int2byte', 'int2char', 'int2short', 'ior', 'irem', 'ireturn', 'ishl', 'ishr', 'istore', 'istore_0', 'istore_1', 'istore_2', 'istore_3', 'istore_w', 'isub', 'iushr', 'ixor', 'l2d', 'l2f', 'l2i', 'ladd', 'laload', 'land', 'lastore', 'lcmp', 'lconst_0', 'lconst_1', 'ldc2_w', 'ldiv', 'lload', 'lload_0', 'lload_1', 'lload_2', 'lload_3', 'lload_w', 'lmul', 'lneg', 'lookupswitch', 'lor', 'lrem', 'lreturn', 'lshl', 'lshr', 'lstore', 'lstore_0', 'lstore_1', 'lstore_2', 'lstore_3', 'lstore_w', 'lsub', 'lushr', 'lxor', 'monitorenter', 'monitorexit', 'nop', 'pop', 'pop2', 'ret', 'ret_w', 'return', 'saload', 'sastore', 'sipush', 'swap'), suffix=_break), Keyword.Reserved), ('(anewarray|checkcast|instanceof|ldc|ldc_w|new)%s' % _break, Keyword.Reserved, 'class/no-dots'), ('invoke(dynamic|interface|nonvirtual|special|static|virtual)%s' % _break, Keyword.Reserved, 'invocation'), ('(getfield|putfield)%s' % _break, Keyword.Reserved, ('descriptor/no-dots', 'field')), ('(getstatic|putstatic)%s' % _break, Keyword.Reserved, ('descriptor/no-dots', 'static')), (words(('goto', 'goto_w', 'if_acmpeq', 'if_acmpne', 'if_icmpeq', 'if_icmpge', 'if_icmpgt', 'if_icmple', 'if_icmplt', 'if_icmpne', 'ifeq', 'ifge', 'ifgt', 'ifle', 'iflt', 'ifne', 'ifnonnull', 'ifnull', 'jsr', 'jsr_w'), suffix=_break), Keyword.Reserved, 'label'), ('(multianewarray|newarray)%s' % _break, Keyword.Reserved, 'descriptor/convert-dots'), ('tableswitch%s' % _break, Keyword.Reserved, 'table')], 'quote': [("'", String.Single, '#pop'), ('\\\\u[\\da-fA-F]{4}', String.Escape), ("[^'\\\\]+", String.Single)], 'string': [('"', String.Double, '#pop'), ('\\\\([nrtfb"\\\'\\\\]|u[\\da-fA-F]{4}|[0-3]?[0-7]{1,2})', String.Escape), ('[^"\\\\]+', String.Double)], 'root': [('\\n+', Text), ("'", String.Single, 'quote'), include('default'), ('(%s)([ \\t\\r]*)(:)' % _name, bygroups(Name.Label, Text, Punctuation)), (_name, String.Other)], 'annotation': [('\\n', Text, ('#pop', 'annotation-body')), ('default%s' % _break, Keyword.Reserved, ('#pop', 'annotation-default')), include('default')], 'annotation-body': [('\\n+', Text), ('\\.end%s' % _break, Keyword.Reserved, '#pop'), include('default'), (_name, String.Other, ('annotation-items', 'descriptor/no-dots'))], 'annotation-default': [('\\n+', Text), ('\\.end%s' % _break, Keyword.Reserved, '#pop'), include('default'), default(('annotation-items', 'descriptor/no-dots'))], 'annotation-items': [("'", String.Single, 'quote'), include('default'), (_name, String.Other)], 'caught-exception': [('all%s' % _break, Keyword, '#pop'), include('exception')], 'class/convert-dots': [include('default'), ('(L)((?:%s[/.])*)(%s)(;)' % (_unqualified_name, _name), bygroups(Keyword.Type, Name.Namespace, Name.Class, Punctuation), '#pop'), ('((?:%s[/.])*)(%s)' % (_unqualified_name, _name), bygroups(Name.Namespace, Name.Class), '#pop')], 'class/no-dots': [include('default'), ('\\[+', Punctuation, ('#pop', 'descriptor/no-dots')), ('(L)((?:%s/)*)(%s)(;)' % (_unqualified_name, _name), bygroups(Keyword.Type, Name.Namespace, Name.Class, Punctuation), '#pop'), ('((?:%s/)*)(%s)' % (_unqualified_name, _name), bygroups(Name.Namespace, Name.Class), '#pop')], 'descriptor/convert-dots': [include('default'), ('\\[+', Punctuation), ('(L)((?:%s[/.])*)(%s?)(;)' % (_unqualified_name, _name), bygroups(Keyword.Type, Name.Namespace, Name.Class, Punctuation), '#pop'), ('[^%s\\[)L]+' % _separator, Keyword.Type, '#pop'), default('#pop')], 'descriptor/no-dots': [include('default'), ('\\[+', Punctuation), ('(L)((?:%s/)*)(%s)(;)' % (_unqualified_name, _name), bygroups(Keyword.Type, Name.Namespace, Name.Class, Punctuation), '#pop'), ('[^%s\\[)L]+' % _separator, Keyword.Type, '#pop'), default('#pop')], 'descriptors/convert-dots': [('\\)', Punctuation, '#pop'), default('descriptor/convert-dots')], 'enclosing-method': [(_ws, Text), ('(?=[^%s]*\\()' % _separator, Text, ('#pop', 'invocation')), default(('#pop', 'class/convert-dots'))], 'exception': [include('default'), ('((?:%s[/.])*)(%s)' % (_unqualified_name, _name), bygroups(Name.Namespace, Name.Exception), '#pop')], 'field': [('static%s' % _break, Keyword.Reserved, ('#pop', 'static')), include('default'), ('((?:%s[/.](?=[^%s]*[/.]))*)(%s[/.])?(%s)' % (_unqualified_name, _separator, _unqualified_name, _name), bygroups(Name.Namespace, Name.Class, Name.Variable.Instance), '#pop')], 'invocation': [include('default'), ('((?:%s[/.](?=[^%s(]*[/.]))*)(%s[/.])?(%s)(\\()' % (_unqualified_name, _separator, _unqualified_name, _name), bygroups(Name.Namespace, Name.Class, Name.Function, Punctuation), ('#pop', 'descriptor/convert-dots', 'descriptors/convert-dots', 'descriptor/convert-dots'))], 'label': [include('default'), (_name, Name.Label, '#pop')], 'method': [include('default'), ('(%s)(\\()' % _name, bygroups(Name.Function, Punctuation), ('#pop', 'descriptor/convert-dots', 'descriptors/convert-dots', 'descriptor/convert-dots'))], 'no-verification': [('(locals|method|stack)%s' % _break, Keyword.Reserved, '#pop'), include('default')], 'static': [include('default'), ('((?:%s[/.](?=[^%s]*[/.]))*)(%s[/.])?(%s)' % (_unqualified_name, _separator, _unqualified_name, _name), bygroups(Name.Namespace, Name.Class, Name.Variable.Class), '#pop')], 'table': [('\\n+', Text), ('default%s' % _break, Keyword.Reserved, '#pop'), include('default'), (_name, Name.Label)], 'var': [include('default'), (_name, Name.Variable, '#pop')], 'verification': [include('default'), ('(Double|Float|Integer|Long|Null|Top|UninitializedThis)%s' % _break, Keyword, '#pop'), ('Object%s' % _break, Keyword, ('#pop', 'class/no-dots')), ('Uninitialized%s' % _break, Keyword, ('#pop', 'label'))]}

    def analyse_text(text):
        score = 0
        if re.search('^\\s*\\.class\\s', text, re.MULTILINE):
            score += 0.5
            if re.search('^\\s*[a-z]+_[a-z]+\\b', text, re.MULTILINE):
                score += 0.3
        if re.search('^\\s*\\.(attribute|bytecode|debug|deprecated|enclosing|inner|interface|limit|set|signature|stack)\\b', text, re.MULTILINE):
            score += 0.6
        return score