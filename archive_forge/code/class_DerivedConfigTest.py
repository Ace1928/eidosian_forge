from unittest import mock
import swiftclient.client
import testscenarios
import testtools
from testtools import matchers
import time
from heatclient.common import deployment_utils
from heatclient import exc
from heatclient.v1 import software_configs
class DerivedConfigTest(testtools.TestCase):
    scenarios = [('defaults', dict(action='UPDATE', source=mock_sc(), name='s1', input_values=None, server_id='1234', signal_transport='NO_SIGNAL', signal_id=None, result={'config': '', 'group': 'Heat::Ungrouped', 'inputs': [{'description': 'ID of the server being deployed to', 'name': 'deploy_server_id', 'type': 'String', 'value': '1234'}, {'description': 'Name of the current action being deployed', 'name': 'deploy_action', 'type': 'String', 'value': 'UPDATE'}, {'description': 'How the server should signal to heat with the deployment output values.', 'name': 'deploy_signal_transport', 'type': 'String', 'value': 'NO_SIGNAL'}], 'name': 's1', 'options': {}, 'outputs': []})), ('defaults_empty', dict(action='UPDATE', source={}, name='s1', input_values=None, server_id='1234', signal_transport='NO_SIGNAL', signal_id=None, result={'config': '', 'group': 'Heat::Ungrouped', 'inputs': [{'description': 'ID of the server being deployed to', 'name': 'deploy_server_id', 'type': 'String', 'value': '1234'}, {'description': 'Name of the current action being deployed', 'name': 'deploy_action', 'type': 'String', 'value': 'UPDATE'}, {'description': 'How the server should signal to heat with the deployment output values.', 'name': 'deploy_signal_transport', 'type': 'String', 'value': 'NO_SIGNAL'}], 'name': 's1', 'options': {}, 'outputs': []})), ('config_values', dict(action='UPDATE', source=mock_sc(group='puppet', config='do the foo', inputs=[{'name': 'one', 'default': '1'}, {'name': 'two'}], options={'option1': 'value'}, outputs=[{'name': 'output1'}, {'name': 'output2'}]), name='s2', input_values={'one': 'foo', 'two': 'bar', 'three': 'baz'}, server_id='1234', signal_transport='NO_SIGNAL', signal_id=None, result={'config': 'do the foo', 'group': 'puppet', 'inputs': [{'name': 'one', 'default': '1', 'value': 'foo'}, {'name': 'two', 'value': 'bar'}, {'name': 'three', 'type': 'String', 'value': 'baz'}, {'description': 'ID of the server being deployed to', 'name': 'deploy_server_id', 'type': 'String', 'value': '1234'}, {'description': 'Name of the current action being deployed', 'name': 'deploy_action', 'type': 'String', 'value': 'UPDATE'}, {'description': 'How the server should signal to heat with the deployment output values.', 'name': 'deploy_signal_transport', 'type': 'String', 'value': 'NO_SIGNAL'}], 'name': 's2', 'options': {'option1': 'value'}, 'outputs': [{'name': 'output1'}, {'name': 'output2'}]})), ('temp_url', dict(action='UPDATE', source=mock_sc(), name='s1', input_values=None, server_id='1234', signal_transport='TEMP_URL_SIGNAL', signal_id='http://192.0.2.1:8080/foo', result={'config': '', 'group': 'Heat::Ungrouped', 'inputs': [{'description': 'ID of the server being deployed to', 'name': 'deploy_server_id', 'type': 'String', 'value': '1234'}, {'description': 'Name of the current action being deployed', 'name': 'deploy_action', 'type': 'String', 'value': 'UPDATE'}, {'description': 'How the server should signal to heat with the deployment output values.', 'name': 'deploy_signal_transport', 'type': 'String', 'value': 'TEMP_URL_SIGNAL'}, {'description': 'ID of signal to use for signaling output values', 'name': 'deploy_signal_id', 'type': 'String', 'value': 'http://192.0.2.1:8080/foo'}, {'description': 'HTTP verb to use for signaling output values', 'name': 'deploy_signal_verb', 'type': 'String', 'value': 'PUT'}], 'name': 's1', 'options': {}, 'outputs': []})), ('unsupported', dict(action='UPDATE', source=mock_sc(), name='s1', input_values=None, server_id='1234', signal_transport='ASDF', signal_id=None, result_error=exc.CommandError, result_error_msg='Unsupported signal transport ASDF', result=None))]

    def test_build_derived_config_params(self):
        try:
            self.assertEqual(self.result, deployment_utils.build_derived_config_params(action=self.action, source=self.source, name=self.name, input_values=self.input_values, server_id=self.server_id, signal_transport=self.signal_transport, signal_id=self.signal_id))
        except Exception as e:
            if not self.result_error:
                raise e
            self.assertIsInstance(e, self.result_error)
            self.assertEqual(self.result_error_msg, str(e))