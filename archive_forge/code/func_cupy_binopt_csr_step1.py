import operator
import warnings
import numpy
import cupy
from cupy._core import _accelerator
from cupy.cuda import cub
from cupy.cuda import runtime
from cupyx import cusparse
from cupyx.scipy.sparse import _base
from cupyx.scipy.sparse import _compressed
from cupyx.scipy.sparse import _csc
from cupyx.scipy.sparse import SparseEfficiencyWarning
from cupyx.scipy.sparse import _util
@cupy._util.memoize(for_each_device=True)
def cupy_binopt_csr_step1(op_name, preamble=''):
    name = 'cupyx_scipy_sparse_csr_binopt_' + op_name + 'step1'
    return cupy.ElementwiseKernel('\n        int32 M, int32 N,\n        raw I A_INDPTR, raw I A_INDICES, raw T A_DATA,\n        int32 A_M, int32 A_N, int32 A_NNZ_ACT, int32 A_NNZ,\n        raw I B_INDPTR, raw I B_INDICES, raw T B_DATA,\n        int32 B_M, int32 B_N, int32 B_NNZ_ACT, int32 B_NNZ\n        ', '\n        raw I A_INFO, raw B A_VALID, raw I A_TMP_INDICES, raw O A_TMP_DATA,\n        raw I B_INFO, raw B B_VALID, raw I B_TMP_INDICES, raw O B_TMP_DATA,\n        raw I C_INFO\n        ', '\n        if (i >= A_NNZ + B_NNZ) return;\n\n        const int *MY_INDPTR, *MY_INDICES;  int *MY_INFO;  const T *MY_DATA;\n        const int *OP_INDPTR, *OP_INDICES;  int *OP_INFO;  const T *OP_DATA;\n        int MY_M, MY_N, MY_NNZ_ACT, MY_NNZ;\n        int OP_M, OP_N, OP_NNZ_ACT, OP_NNZ;\n        signed char *MY_VALID;  I *MY_TMP_INDICES;  O *MY_TMP_DATA;\n\n        int my_j;\n        if (i < A_NNZ) {\n            // in charge of one of non-zero element of sparse matrix A\n            my_j = i;\n            MY_INDPTR  = &(A_INDPTR[0]);   OP_INDPTR  = &(B_INDPTR[0]);\n            MY_INDICES = &(A_INDICES[0]);  OP_INDICES = &(B_INDICES[0]);\n            MY_INFO    = &(A_INFO[0]);     OP_INFO    = &(B_INFO[0]);\n            MY_DATA    = &(A_DATA[0]);     OP_DATA    = &(B_DATA[0]);\n            MY_M       = A_M;              OP_M       = B_M;\n            MY_N       = A_N;              OP_N       = B_N;\n            MY_NNZ_ACT = A_NNZ_ACT;        OP_NNZ_ACT = B_NNZ_ACT;\n            MY_NNZ     = A_NNZ;            OP_NNZ     = B_NNZ;\n            MY_VALID   = &(A_VALID[0]);\n            MY_TMP_DATA= &(A_TMP_DATA[0]);\n            MY_TMP_INDICES = &(A_TMP_INDICES[0]);\n        } else {\n            // in charge of one of non-zero element of sparse matrix B\n            my_j = i - A_NNZ;\n            MY_INDPTR  = &(B_INDPTR[0]);   OP_INDPTR  = &(A_INDPTR[0]);\n            MY_INDICES = &(B_INDICES[0]);  OP_INDICES = &(A_INDICES[0]);\n            MY_INFO    = &(B_INFO[0]);     OP_INFO    = &(A_INFO[0]);\n            MY_DATA    = &(B_DATA[0]);     OP_DATA    = &(A_DATA[0]);\n            MY_M       = B_M;              OP_M       = A_M;\n            MY_N       = B_N;              OP_N       = A_N;\n            MY_NNZ_ACT = B_NNZ_ACT;        OP_NNZ_ACT = A_NNZ_ACT;\n            MY_NNZ     = B_NNZ;            OP_NNZ     = A_NNZ;\n            MY_VALID   = &(B_VALID[0]);\n            MY_TMP_DATA= &(B_TMP_DATA[0]);\n            MY_TMP_INDICES = &(B_TMP_INDICES[0]);\n        }\n        int _min, _max, _mid;\n\n        // get column location\n        int my_col;\n        int my_j_act = my_j;\n        if (MY_M == 1 && MY_M < M) {\n            if (MY_N == 1 && MY_N < N) my_j_act = 0;\n            else                       my_j_act = my_j % MY_NNZ_ACT;\n        } else {\n            if (MY_N == 1 && MY_N < N) my_j_act = my_j / N;\n        }\n        my_col = MY_INDICES[my_j_act];\n        if (MY_N == 1 && MY_N < N) {\n            my_col = my_j % N;\n        }\n\n        // get row location\n        int my_row = get_row_id(my_j_act, 0, MY_M - 1, &(MY_INDPTR[0]));\n        if (MY_M == 1 && MY_M < M) {\n            if (MY_N == 1 && MY_N < N) my_row = my_j / N;\n            else                       my_row = my_j / MY_NNZ_ACT;\n        }\n\n        int op_row = my_row;\n        int op_row_act = op_row;\n        if (OP_M == 1 && OP_M < M) {\n            op_row_act = 0;\n        }\n\n        int op_col = 0;\n        _min = OP_INDPTR[op_row_act];\n        _max = OP_INDPTR[op_row_act + 1] - 1;\n        int op_j_act = _min;\n        bool op_nz = false;\n        if (_min <= _max) {\n            if (OP_N == 1 && OP_N < N) {\n                op_col = my_col;\n                op_nz = true;\n            }\n            else {\n                _mid = (_min + _max) / 2;\n                op_col = OP_INDICES[_mid];\n                while (_min < _max) {\n                    if (op_col < my_col) {\n                        _min = _mid + 1;\n                    } else if (op_col > my_col) {\n                        _max = _mid;\n                    } else {\n                        break;\n                    }\n                    _mid = (_min + _max) / 2;\n                    op_col = OP_INDICES[_mid];\n                }\n                op_j_act = _mid;\n                if (op_col == my_col) {\n                    op_nz = true;\n                } else if (op_col < my_col) {\n                    op_col = N;\n                    op_j_act += 1;\n                }\n            }\n        }\n\n        int op_j = op_j_act;\n        if (OP_M == 1 && OP_M < M) {\n            if (OP_N == 1 && OP_N < N) {\n                op_j = (op_col + N * op_row) * OP_NNZ_ACT;\n            } else {\n                op_j = op_j_act + OP_NNZ_ACT * op_row;\n            }\n        } else {\n            if (OP_N == 1 && OP_N < N) {\n                op_j = op_col + N * op_j_act;\n            }\n        }\n\n        if (i < A_NNZ || !op_nz) {\n            T my_data = MY_DATA[my_j_act];\n            T op_data = 0;\n            if (op_nz) op_data = OP_DATA[op_j_act];\n            O out;\n            if (i < A_NNZ) out = binopt(my_data, op_data);\n            else           out = binopt(op_data, my_data);\n            if (out != static_cast<O>(0)) {\n                MY_VALID[my_j] = 1;\n                MY_TMP_DATA[my_j] = out;\n                MY_TMP_INDICES[my_j] = my_col;\n                atomicAdd( &(C_INFO[my_row + 1]), 1 );\n                atomicAdd( &(MY_INFO[my_j + 1]), 1 );\n                atomicAdd( &(OP_INFO[op_j]), 1 );\n            }\n        }\n        ', name, preamble=preamble)