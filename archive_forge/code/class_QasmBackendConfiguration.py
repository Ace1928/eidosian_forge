import re
import copy
import numbers
from typing import Dict, List, Any, Iterable, Tuple, Union
from collections import defaultdict
from qiskit.exceptions import QiskitError
from qiskit.providers.exceptions import BackendConfigurationError
from qiskit.pulse.channels import (
class QasmBackendConfiguration:
    """Class representing an OpenQASM 2.0 Backend Configuration.

    Attributes:
        backend_name: backend name.
        backend_version: backend version in the form X.Y.Z.
        n_qubits: number of qubits.
        basis_gates: list of basis gates names on the backend.
        gates: list of basis gates on the backend.
        local: backend is local or remote.
        simulator: backend is a simulator.
        conditional: backend supports conditional operations.
        open_pulse: backend supports open pulse.
        memory: backend supports memory.
        max_shots: maximum number of shots supported.
    """
    _data = {}

    def __init__(self, backend_name, backend_version, n_qubits, basis_gates, gates, local, simulator, conditional, open_pulse, memory, max_shots, coupling_map, supported_instructions=None, dynamic_reprate_enabled=False, rep_delay_range=None, default_rep_delay=None, max_experiments=None, sample_name=None, n_registers=None, register_map=None, configurable=None, credits_required=None, online_date=None, display_name=None, description=None, tags=None, dt=None, dtm=None, processor_type=None, parametric_pulses=None, **kwargs):
        """Initialize a QasmBackendConfiguration Object

        Args:
            backend_name (str): The backend name
            backend_version (str): The backend version in the form X.Y.Z
            n_qubits (int): the number of qubits for the backend
            basis_gates (list): The list of strings for the basis gates of the
                backends
            gates (list): The list of GateConfig objects for the basis gates of
                the backend
            local (bool): True if the backend is local or False if remote
            simulator (bool): True if the backend is a simulator
            conditional (bool): True if the backend supports conditional
                operations
            open_pulse (bool): True if the backend supports OpenPulse
            memory (bool): True if the backend supports memory
            max_shots (int): The maximum number of shots allowed on the backend
            coupling_map (list): The coupling map for the device
            supported_instructions (List[str]): Instructions supported by the backend.
            dynamic_reprate_enabled (bool): whether delay between programs can be set dynamically
                (ie via ``rep_delay``). Defaults to False.
            rep_delay_range (List[float]): 2d list defining supported range of repetition
                delays for backend in Î¼s. First entry is lower end of the range, second entry is
                higher end of the range. Optional, but will be specified when
                ``dynamic_reprate_enabled=True``.
            default_rep_delay (float): Value of ``rep_delay`` if not specified by user and
                ``dynamic_reprate_enabled=True``.
            max_experiments (int): The maximum number of experiments per job
            sample_name (str): Sample name for the backend
            n_registers (int): Number of register slots available for feedback
                (if conditional is True)
            register_map (list): An array of dimension n_qubits X
                n_registers that specifies whether a qubit can store a
                measurement in a certain register slot.
            configurable (bool): True if the backend is configurable, if the
                backend is a simulator
            credits_required (bool): True if backend requires credits to run a
                job.
            online_date (datetime.datetime): The date that the device went online
            display_name (str): Alternate name field for the backend
            description (str): A description for the backend
            tags (list): A list of string tags to describe the backend
            dt (float): Qubit drive channel timestep in nanoseconds.
            dtm (float): Measurement drive channel timestep in nanoseconds.
            processor_type (dict): Processor type for this backend. A dictionary of the
                form ``{"family": <str>, "revision": <str>, segment: <str>}`` such as
                ``{"family": "Canary", "revision": "1.0", segment: "A"}``.

                - family: Processor family of this backend.
                - revision: Revision version of this processor.
                - segment: Segment this processor belongs to within a larger chip.
            parametric_pulses (list): A list of pulse shapes which are supported on the backend.
                For example: ``['gaussian', 'constant']``

            **kwargs: optional fields
        """
        self._data = {}
        self.backend_name = backend_name
        self.backend_version = backend_version
        self.n_qubits = n_qubits
        self.basis_gates = basis_gates
        self.gates = gates
        self.local = local
        self.simulator = simulator
        self.conditional = conditional
        self.open_pulse = open_pulse
        self.memory = memory
        self.max_shots = max_shots
        self.coupling_map = coupling_map
        if supported_instructions:
            self.supported_instructions = supported_instructions
        self.dynamic_reprate_enabled = dynamic_reprate_enabled
        if rep_delay_range:
            self.rep_delay_range = [_rd * 1e-06 for _rd in rep_delay_range]
        if default_rep_delay is not None:
            self.default_rep_delay = default_rep_delay * 1e-06
        if max_experiments:
            self.max_experiments = max_experiments
        if sample_name is not None:
            self.sample_name = sample_name
        if n_registers:
            self.n_registers = 1
        if register_map:
            self.register_map = register_map
        if configurable is not None:
            self.configurable = configurable
        if credits_required is not None:
            self.credits_required = credits_required
        if online_date is not None:
            self.online_date = online_date
        if display_name is not None:
            self.display_name = display_name
        if description is not None:
            self.description = description
        if tags is not None:
            self.tags = tags
        if dt is not None:
            self.dt = dt * 1e-09
        if dtm is not None:
            self.dtm = dtm * 1e-09
        if processor_type is not None:
            self.processor_type = processor_type
        if parametric_pulses is not None:
            self.parametric_pulses = parametric_pulses
        if 'qubit_lo_range' in kwargs:
            kwargs['qubit_lo_range'] = [[min_range * 1000000000.0, max_range * 1000000000.0] for min_range, max_range in kwargs['qubit_lo_range']]
        if 'meas_lo_range' in kwargs:
            kwargs['meas_lo_range'] = [[min_range * 1000000000.0, max_range * 1000000000.0] for min_range, max_range in kwargs['meas_lo_range']]
        if 'rep_times' in kwargs:
            kwargs['rep_times'] = [_rt * 1e-06 for _rt in kwargs['rep_times']]
        self._data.update(kwargs)

    def __getattr__(self, name):
        try:
            return self._data[name]
        except KeyError as ex:
            raise AttributeError(f'Attribute {name} is not defined') from ex

    @classmethod
    def from_dict(cls, data):
        """Create a new GateConfig object from a dictionary.

        Args:
            data (dict): A dictionary representing the GateConfig to create.
                         It will be in the same format as output by
                         :func:`to_dict`.
        Returns:
            GateConfig: The GateConfig from the input dictionary.
        """
        in_data = copy.copy(data)
        gates = [GateConfig.from_dict(x) for x in in_data.pop('gates')]
        in_data['gates'] = gates
        return cls(**in_data)

    def to_dict(self):
        """Return a dictionary format representation of the GateConfig.

        Returns:
            dict: The dictionary form of the GateConfig.
        """
        out_dict = {'backend_name': self.backend_name, 'backend_version': self.backend_version, 'n_qubits': self.n_qubits, 'basis_gates': self.basis_gates, 'gates': [x.to_dict() for x in self.gates], 'local': self.local, 'simulator': self.simulator, 'conditional': self.conditional, 'open_pulse': self.open_pulse, 'memory': self.memory, 'max_shots': self.max_shots, 'coupling_map': self.coupling_map, 'dynamic_reprate_enabled': self.dynamic_reprate_enabled}
        if hasattr(self, 'supported_instructions'):
            out_dict['supported_instructions'] = self.supported_instructions
        if hasattr(self, 'rep_delay_range'):
            out_dict['rep_delay_range'] = [_rd * 1000000.0 for _rd in self.rep_delay_range]
        if hasattr(self, 'default_rep_delay'):
            out_dict['default_rep_delay'] = self.default_rep_delay * 1000000.0
        for kwarg in ['max_experiments', 'sample_name', 'n_registers', 'register_map', 'configurable', 'credits_required', 'online_date', 'display_name', 'description', 'tags', 'dt', 'dtm', 'processor_type', 'parametric_pulses']:
            if hasattr(self, kwarg):
                out_dict[kwarg] = getattr(self, kwarg)
        out_dict.update(self._data)
        if 'dt' in out_dict:
            out_dict['dt'] *= 1000000000.0
        if 'dtm' in out_dict:
            out_dict['dtm'] *= 1000000000.0
        if 'qubit_lo_range' in out_dict:
            out_dict['qubit_lo_range'] = [[min_range * 1e-09, max_range * 1e-09] for min_range, max_range in out_dict['qubit_lo_range']]
        if 'meas_lo_range' in out_dict:
            out_dict['meas_lo_range'] = [[min_range * 1e-09, max_range * 1e-09] for min_range, max_range in out_dict['meas_lo_range']]
        return out_dict

    @property
    def num_qubits(self):
        """Returns the number of qubits.

        In future, `n_qubits` should be replaced in favor of `num_qubits` for consistent use
        throughout Qiskit. Until this is properly refactored, this property serves as intermediate
        solution.
        """
        return self.n_qubits

    def __eq__(self, other):
        if isinstance(other, QasmBackendConfiguration):
            if self.to_dict() == other.to_dict():
                return True
        return False

    def __contains__(self, item):
        return item in self.__dict__