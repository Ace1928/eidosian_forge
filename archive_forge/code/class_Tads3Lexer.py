import re
from pygments.lexer import RegexLexer, include, bygroups, using, \
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
class Tads3Lexer(RegexLexer):
    """
    For `TADS 3 <http://www.tads.org/>`_ source code.
    """
    name = 'TADS 3'
    aliases = ['tads3']
    filenames = ['*.t']
    flags = re.DOTALL | re.MULTILINE
    _comment_single = '(?://(?:[^\\\\\\n]|\\\\+[\\w\\W])*$)'
    _comment_multiline = '(?:/\\*(?:[^*]|\\*(?!/))*\\*/)'
    _escape = '(?:\\\\(?:[\\n\\\\<>"\\\'^v bnrt]|u[\\da-fA-F]{,4}|x[\\da-fA-F]{,2}|[0-3]?[0-7]{1,2}))'
    _name = '(?:[_a-zA-Z]\\w*)'
    _no_quote = '(?=\\s|\\\\?>)'
    _operator = '(?:&&|\\|\\||\\+\\+|--|\\?\\?|::|[.,@\\[\\]~]|(?:[=+\\-*/%!&|^]|<<?|>>?>?)=?)'
    _ws = '(?:\\\\|\\s|%s|%s)' % (_comment_single, _comment_multiline)
    _ws_pp = '(?:\\\\\\n|[^\\S\\n]|%s|%s)' % (_comment_single, _comment_multiline)

    def _make_string_state(triple, double, verbatim=None, _escape=_escape):
        if verbatim:
            verbatim = ''.join(['(?:%s|%s)' % (re.escape(c.lower()), re.escape(c.upper())) for c in verbatim])
        char = '"' if double else "'"
        token = String.Double if double else String.Single
        escaped_quotes = '+|%s(?!%s{2})' % (char, char) if triple else ''
        prefix = '%s%s' % ('t' if triple else '', 'd' if double else 's')
        tag_state_name = '%sqt' % prefix
        state = []
        if triple:
            state += [('%s{3,}' % char, token, '#pop'), ('\\\\%s+' % char, String.Escape), (char, token)]
        else:
            state.append((char, token, '#pop'))
        state += [include('s/verbatim'), ('[^\\\\<&{}%s]+' % char, token)]
        if verbatim:
            state.append(('\\\\?<(/|\\\\\\\\|(?!%s)\\\\)%s(?=[\\s=>])' % (_escape, verbatim), Name.Tag, ('#pop', '%sqs' % prefix, tag_state_name)))
        else:
            state += [('\\\\?<!([^><\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)*>?' % (char, char, escaped_quotes, _escape), Comment.Multiline), ('(?i)\\\\?<listing(?=[\\s=>]|\\\\>)', Name.Tag, ('#pop', '%sqs/listing' % prefix, tag_state_name)), ('(?i)\\\\?<xmp(?=[\\s=>]|\\\\>)', Name.Tag, ('#pop', '%sqs/xmp' % prefix, tag_state_name)), ('\\\\?<([^\\s=><\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)*' % (char, char, escaped_quotes, _escape), Name.Tag, tag_state_name), include('s/entity')]
        state += [include('s/escape'), ('\\{([^}<\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)*\\}' % (char, char, escaped_quotes, _escape), String.Interpol), ('[\\\\&{}<]', token)]
        return state

    def _make_tag_state(triple, double, _escape=_escape):
        char = '"' if double else "'"
        quantifier = '{3,}' if triple else ''
        state_name = '%s%sqt' % ('t' if triple else '', 'd' if double else 's')
        token = String.Double if double else String.Single
        escaped_quotes = '+|%s(?!%s{2})' % (char, char) if triple else ''
        return [('%s%s' % (char, quantifier), token, '#pop:2'), ('(\\s|\\\\\\n)+', Text), ('(=)(\\\\?")', bygroups(Punctuation, String.Double), 'dqs/%s' % state_name), ("(=)(\\\\?')", bygroups(Punctuation, String.Single), 'sqs/%s' % state_name), ('=', Punctuation, 'uqs/%s' % state_name), ('\\\\?>', Name.Tag, '#pop'), ('\\{([^}<\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)*\\}' % (char, char, escaped_quotes, _escape), String.Interpol), ('([^\\s=><\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)+' % (char, char, escaped_quotes, _escape), Name.Attribute), include('s/escape'), include('s/verbatim'), include('s/entity'), ('[\\\\{}&]', Name.Attribute)]

    def _make_attribute_value_state(terminator, host_triple, host_double, _escape=_escape):
        token = String.Double if terminator == '"' else String.Single if terminator == "'" else String.Other
        host_char = '"' if host_double else "'"
        host_quantifier = '{3,}' if host_triple else ''
        host_token = String.Double if host_double else String.Single
        escaped_quotes = '+|%s(?!%s{2})' % (host_char, host_char) if host_triple else ''
        return [('%s%s' % (host_char, host_quantifier), host_token, '#pop:3'), ('%s%s' % ('' if token is String.Other else '\\\\?', terminator), token, '#pop'), include('s/verbatim'), include('s/entity'), ('\\{([^}<\\\\%s]|<(?!<)|\\\\%s%s|%s|\\\\.)*\\}' % (host_char, host_char, escaped_quotes, _escape), String.Interpol), ('([^\\s"\\\'<%s{}\\\\&])+' % ('>' if token is String.Other else ''), token), include('s/escape'), ('["\\\'\\s&{<}\\\\]', token)]
    tokens = {'root': [(u'\ufeff', Text), ('\\{', Punctuation, 'object-body'), (';+', Punctuation), ('(?=(argcount|break|case|catch|continue|default|definingobj|delegated|do|else|for|foreach|finally|goto|if|inherited|invokee|local|nil|new|operator|replaced|return|self|switch|targetobj|targetprop|throw|true|try|while)\\b)', Text, 'block'), ('(%s)(%s*)(\\()' % (_name, _ws), bygroups(Name.Function, using(this, state='whitespace'), Punctuation), ('block?/root', 'more/parameters', 'main/parameters')), include('whitespace'), ('\\++', Punctuation), ('[^\\s!"%-(*->@-_a-z{-~]+', Error), ('(?!\\Z)', Text, 'main/root')], 'main/root': [include('main/basic'), default(('#pop', 'object-body/no-braces', 'classes', 'class'))], 'object-body/no-braces': [(';', Punctuation, '#pop'), ('\\{', Punctuation, ('#pop', 'object-body')), include('object-body')], 'object-body': [(';', Punctuation), ('\\{', Punctuation, '#push'), ('\\}', Punctuation, '#pop'), (':', Punctuation, ('classes', 'class')), ('(%s?)(%s*)(\\()' % (_name, _ws), bygroups(Name.Function, using(this, state='whitespace'), Punctuation), ('block?', 'more/parameters', 'main/parameters')), ('(%s)(%s*)(\\{)' % (_name, _ws), bygroups(Name.Function, using(this, state='whitespace'), Punctuation), 'block'), ('(%s)(%s*)(:)' % (_name, _ws), bygroups(Name.Variable, using(this, state='whitespace'), Punctuation), ('object-body/no-braces', 'classes', 'class')), include('whitespace'), ('->|%s' % _operator, Punctuation, 'main'), default('main/object-body')], 'main/object-body': [include('main/basic'), ('(%s)(%s*)(=?)' % (_name, _ws), bygroups(Name.Variable, using(this, state='whitespace'), Punctuation), ('#pop', 'more', 'main')), default('#pop:2')], 'block?/root': [('\\{', Punctuation, ('#pop', 'block')), include('whitespace'), ('(?=[[\\\'"<(:])', Text, ('#pop', 'object-body/no-braces', 'grammar', 'grammar-rules')), default(('#pop', 'object-body/no-braces'))], 'block?': [('\\{', Punctuation, ('#pop', 'block')), include('whitespace'), default('#pop')], 'block/basic': [('[;:]+', Punctuation), ('\\{', Punctuation, '#push'), ('\\}', Punctuation, '#pop'), ('default\\b', Keyword.Reserved), ('(%s)(%s*)(:)' % (_name, _ws), bygroups(Name.Label, using(this, state='whitespace'), Punctuation)), include('whitespace')], 'block': [include('block/basic'), ('(?!\\Z)', Text, ('more', 'main'))], 'block/embed': [('>>', String.Interpol, '#pop'), include('block/basic'), ('(?!\\Z)', Text, ('more/embed', 'main'))], 'main/basic': [include('whitespace'), ('\\(', Punctuation, ('#pop', 'more', 'main')), ('\\[', Punctuation, ('#pop', 'more/list', 'main')), ('\\{', Punctuation, ('#pop', 'more/inner', 'main/inner', 'more/parameters', 'main/parameters')), ('\\*|\\.{3}', Punctuation, '#pop'), ('(?i)0x[\\da-f]+', Number.Hex, '#pop'), ('(\\d+\\.(?!\\.)\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+', Number.Float, '#pop'), ('0[0-7]+', Number.Oct, '#pop'), ('\\d+', Number.Integer, '#pop'), ('"""', String.Double, ('#pop', 'tdqs')), ("'''", String.Single, ('#pop', 'tsqs')), ('"', String.Double, ('#pop', 'dqs')), ("'", String.Single, ('#pop', 'sqs')), ('R"""', String.Regex, ('#pop', 'tdqr')), ("R'''", String.Regex, ('#pop', 'tsqr')), ('R"', String.Regex, ('#pop', 'dqr')), ("R'", String.Regex, ('#pop', 'sqr')), ('(extern)(%s+)(object\\b)' % _ws, bygroups(Keyword.Reserved, using(this, state='whitespace'), Keyword.Reserved)), ('(function|method)(%s*)(\\()' % _ws, bygroups(Keyword.Reserved, using(this, state='whitespace'), Punctuation), ('#pop', 'block?', 'more/parameters', 'main/parameters')), ('(modify)(%s+)(grammar\\b)' % _ws, bygroups(Keyword.Reserved, using(this, state='whitespace'), Keyword.Reserved), ('#pop', 'object-body/no-braces', ':', 'grammar')), ('(new)(%s+(?=(?:function|method)\\b))' % _ws, bygroups(Keyword.Reserved, using(this, state='whitespace'))), ('(object)(%s+)(template\\b)' % _ws, bygroups(Keyword.Reserved, using(this, state='whitespace'), Keyword.Reserved), ('#pop', 'template')), ('(string)(%s+)(template\\b)' % _ws, bygroups(Keyword, using(this, state='whitespace'), Keyword.Reserved), ('#pop', 'function-name')), ('(argcount|definingobj|invokee|replaced|targetobj|targetprop)\\b', Name.Builtin, '#pop'), ('(break|continue|goto)\\b', Keyword.Reserved, ('#pop', 'label')), ('(case|extern|if|intrinsic|return|static|while)\\b', Keyword.Reserved), ('catch\\b', Keyword.Reserved, ('#pop', 'catch')), ('class\\b', Keyword.Reserved, ('#pop', 'object-body/no-braces', 'class')), ('(default|do|else|finally|try)\\b', Keyword.Reserved, '#pop'), ('(dictionary|property)\\b', Keyword.Reserved, ('#pop', 'constants')), ('enum\\b', Keyword.Reserved, ('#pop', 'enum')), ('export\\b', Keyword.Reserved, ('#pop', 'main')), ('(for|foreach)\\b', Keyword.Reserved, ('#pop', 'more/inner', 'main/inner')), ('(function|method)\\b', Keyword.Reserved, ('#pop', 'block?', 'function-name')), ('grammar\\b', Keyword.Reserved, ('#pop', 'object-body/no-braces', 'grammar')), ('inherited\\b', Keyword.Reserved, ('#pop', 'inherited')), ('local\\b', Keyword.Reserved, ('#pop', 'more/local', 'main/local')), ('(modify|replace|switch|throw|transient)\\b', Keyword.Reserved, '#pop'), ('new\\b', Keyword.Reserved, ('#pop', 'class')), ('(nil|true)\\b', Keyword.Constant, '#pop'), ('object\\b', Keyword.Reserved, ('#pop', 'object-body/no-braces')), ('operator\\b', Keyword.Reserved, ('#pop', 'operator')), ('propertyset\\b', Keyword.Reserved, ('#pop', 'propertyset', 'main')), ('self\\b', Name.Builtin.Pseudo, '#pop'), ('template\\b', Keyword.Reserved, ('#pop', 'template')), ('(__objref|defined)(%s*)(\\()' % _ws, bygroups(Operator.Word, using(this, state='whitespace'), Operator), ('#pop', 'more/__objref', 'main')), ('delegated\\b', Operator.Word), ('(__DATE__|__DEBUG|__LINE__|__FILE__|__TADS_MACRO_FORMAT_VERSION|__TADS_SYS_\\w*|__TADS_SYSTEM_NAME|__TADS_VERSION_MAJOR|__TADS_VERSION_MINOR|__TADS3|__TIME__|construct|finalize|grammarInfo|grammarTag|lexicalParent|miscVocab|sourceTextGroup|sourceTextGroupName|sourceTextGroupOrder|sourceTextOrder)\\b', Name.Builtin, '#pop')], 'main': [include('main/basic'), (_name, Name, '#pop'), default('#pop')], 'more/basic': [('\\(', Punctuation, ('more/list', 'main')), ('\\[', Punctuation, ('more', 'main')), ('\\.{3}', Punctuation), ('->|\\.\\.', Punctuation, 'main'), ('(?=;)|[:)\\]]', Punctuation, '#pop'), include('whitespace'), (_operator, Operator, 'main'), ('\\?', Operator, ('main', 'more/conditional', 'main')), ('(is|not)(%s+)(in\\b)' % _ws, bygroups(Operator.Word, using(this, state='whitespace'), Operator.Word)), ('[^\\s!"%-_a-z{-~]+', Error)], 'more': [include('more/basic'), default('#pop')], 'more/conditional': [(':(?!:)', Operator, '#pop'), include('more')], 'more/embed': [('>>', String.Interpol, '#pop:2'), include('more')], 'main/inner': [('\\(', Punctuation, ('#pop', 'more/inner', 'main/inner')), ('local\\b', Keyword.Reserved, ('#pop', 'main/local')), include('main')], 'more/inner': [('\\}', Punctuation, '#pop'), (',', Punctuation, 'main/inner'), ('(in|step)\\b', Keyword, 'main/inner'), include('more')], 'main/local': [(_name, Name.Variable, '#pop'), include('whitespace')], 'more/local': [(',', Punctuation, 'main/local'), include('more')], 'more/list': [('[,:]', Punctuation, 'main'), include('more')], 'main/parameters': [('(%s)(%s*)(?=:)' % (_name, _ws), bygroups(Name.Variable, using(this, state='whitespace')), '#pop'), ('(%s)(%s+)(%s)' % (_name, _ws, _name), bygroups(Name.Class, using(this, state='whitespace'), Name.Variable), '#pop'), ('\\[+', Punctuation), include('main/basic'), (_name, Name.Variable, '#pop'), default('#pop')], 'more/parameters': [('(:)(%s*(?=[?=,:)]))' % _ws, bygroups(Punctuation, using(this, state='whitespace'))), ('[?\\]]+', Punctuation), ('[:)]', Punctuation, ('#pop', 'multimethod?')), (',', Punctuation, 'main/parameters'), ('=', Punctuation, ('more/parameter', 'main')), include('more')], 'more/parameter': [('(?=[,)])', Text, '#pop'), include('more')], 'multimethod?': [('multimethod\\b', Keyword, '#pop'), include('whitespace'), default('#pop')], 'more/__objref': [(',', Punctuation, 'mode'), ('\\)', Operator, '#pop'), include('more')], 'mode': [('(error|warn)\\b', Keyword, '#pop'), include('whitespace')], 'catch': [('\\(+', Punctuation), (_name, Name.Exception, ('#pop', 'variables')), include('whitespace')], 'enum': [include('whitespace'), ('token\\b', Keyword, ('#pop', 'constants')), default(('#pop', 'constants'))], 'grammar': [('\\)+', Punctuation), ('\\(', Punctuation, 'grammar-tag'), (':', Punctuation, 'grammar-rules'), (_name, Name.Class), include('whitespace')], 'grammar-tag': [include('whitespace'), ('"""([^\\\\"<]|""?(?!")|\\\\"+|\\\\.|<(?!<))+("{3,}|<<)|R"""([^\\\\"]|""?(?!")|\\\\"+|\\\\.)+"{3,}|\'\'\'([^\\\\\'<]|\'\'?(?!\')|\\\\\'+|\\\\.|<(?!<))+(\'{3,}|<<)|R\'\'\'([^\\\\\']|\'\'?(?!\')|\\\\\'+|\\\\.)+\'{3,}|"([^\\\\"<]|\\\\.|<(?!<))+("|<<)|R"([^\\\\"]|\\\\.)+"|\'([^\\\\\'<]|\\\\.|<(?!<))+(\'|<<)|R\'([^\\\\\']|\\\\.)+\'|([^)\\s\\\\/]|/(?![/*]))+|\\)', String.Other, '#pop')], 'grammar-rules': [include('string'), include('whitespace'), ('(\\[)(%s*)(badness)' % _ws, bygroups(Punctuation, using(this, state='whitespace'), Keyword), 'main'), ('->|%s|[()]' % _operator, Punctuation), (_name, Name.Constant), default('#pop:2')], ':': [(':', Punctuation, '#pop')], 'function-name': [('(<<([^>]|>>>|>(?!>))*>>)+', String.Interpol), ('(?=%s?%s*[({])' % (_name, _ws), Text, '#pop'), (_name, Name.Function, '#pop'), include('whitespace')], 'inherited': [('<', Punctuation, ('#pop', 'classes', 'class')), include('whitespace'), (_name, Name.Class, '#pop'), default('#pop')], 'operator': [('negate\\b', Operator.Word, '#pop'), include('whitespace'), (_operator, Operator), default('#pop')], 'propertyset': [('\\(', Punctuation, ('more/parameters', 'main/parameters')), ('\\{', Punctuation, ('#pop', 'object-body')), include('whitespace')], 'template': [('(?=;)', Text, '#pop'), include('string'), ('inherited\\b', Keyword.Reserved), include('whitespace'), ('->|\\?|%s' % _operator, Punctuation), (_name, Name.Variable)], 'class': [('\\*|\\.{3}', Punctuation, '#pop'), ('object\\b', Keyword.Reserved, '#pop'), ('transient\\b', Keyword.Reserved), (_name, Name.Class, '#pop'), include('whitespace'), default('#pop')], 'classes': [('[:,]', Punctuation, 'class'), include('whitespace'), ('>', Punctuation, '#pop'), default('#pop')], 'constants': [(',+', Punctuation), (';', Punctuation, '#pop'), ('property\\b', Keyword.Reserved), (_name, Name.Constant), include('whitespace')], 'label': [(_name, Name.Label, '#pop'), include('whitespace'), default('#pop')], 'variables': [(',+', Punctuation), ('\\)', Punctuation, '#pop'), include('whitespace'), (_name, Name.Variable)], 'whitespace': [('^%s*#(%s|[^\\n]|(?<=\\\\)\\n)*\\n?' % (_ws_pp, _comment_multiline), Comment.Preproc), (_comment_single, Comment.Single), (_comment_multiline, Comment.Multiline), ('\\\\+\\n+%s*#?|\\n+|([^\\S\\n]|\\\\)+' % _ws_pp, Text)], 'string': [('"""', String.Double, 'tdqs'), ("'''", String.Single, 'tsqs'), ('"', String.Double, 'dqs'), ("'", String.Single, 'sqs')], 's/escape': [('\\{\\{|\\}\\}|%s' % _escape, String.Escape)], 's/verbatim': [('<<\\s*(as\\s+decreasingly\\s+likely\\s+outcomes|cycling|else|end|first\\s+time|one\\s+of|only|or|otherwise|(sticky|(then\\s+)?(purely\\s+)?at)\\s+random|stopping|(then\\s+)?(half\\s+)?shuffled|\\|\\|)\\s*>>', String.Interpol), ('<<(%%(_(%s|\\\\?.)|[\\-+ ,#]|\\[\\d*\\]?)*\\d*\\.?\\d*(%s|\\\\?.)|\\s*((else|otherwise)\\s+)?(if|unless)\\b)?' % (_escape, _escape), String.Interpol, ('block/embed', 'more/embed', 'main'))], 's/entity': [('(?i)&(#(x[\\da-f]+|\\d+)|[a-z][\\da-z]*);?', Name.Entity)], 'tdqs': _make_string_state(True, True), 'tsqs': _make_string_state(True, False), 'dqs': _make_string_state(False, True), 'sqs': _make_string_state(False, False), 'tdqs/listing': _make_string_state(True, True, 'listing'), 'tsqs/listing': _make_string_state(True, False, 'listing'), 'dqs/listing': _make_string_state(False, True, 'listing'), 'sqs/listing': _make_string_state(False, False, 'listing'), 'tdqs/xmp': _make_string_state(True, True, 'xmp'), 'tsqs/xmp': _make_string_state(True, False, 'xmp'), 'dqs/xmp': _make_string_state(False, True, 'xmp'), 'sqs/xmp': _make_string_state(False, False, 'xmp'), 'tdqt': _make_tag_state(True, True), 'tsqt': _make_tag_state(True, False), 'dqt': _make_tag_state(False, True), 'sqt': _make_tag_state(False, False), 'dqs/tdqt': _make_attribute_value_state('"', True, True), 'dqs/tsqt': _make_attribute_value_state('"', True, False), 'dqs/dqt': _make_attribute_value_state('"', False, True), 'dqs/sqt': _make_attribute_value_state('"', False, False), 'sqs/tdqt': _make_attribute_value_state("'", True, True), 'sqs/tsqt': _make_attribute_value_state("'", True, False), 'sqs/dqt': _make_attribute_value_state("'", False, True), 'sqs/sqt': _make_attribute_value_state("'", False, False), 'uqs/tdqt': _make_attribute_value_state(_no_quote, True, True), 'uqs/tsqt': _make_attribute_value_state(_no_quote, True, False), 'uqs/dqt': _make_attribute_value_state(_no_quote, False, True), 'uqs/sqt': _make_attribute_value_state(_no_quote, False, False), 'tdqr': [('[^\\\\"]+', String.Regex), ('\\\\"*', String.Regex), ('"{3,}', String.Regex, '#pop'), ('"', String.Regex)], 'tsqr': [("[^\\\\']+", String.Regex), ("\\\\'*", String.Regex), ("'{3,}", String.Regex, '#pop'), ("'", String.Regex)], 'dqr': [('[^\\\\"]+', String.Regex), ('\\\\"?', String.Regex), ('"', String.Regex, '#pop')], 'sqr': [("[^\\\\']+", String.Regex), ("\\\\'?", String.Regex), ("'", String.Regex, '#pop')]}

    def get_tokens_unprocessed(self, text, **kwargs):
        pp = '^%s*#%s*' % (self._ws_pp, self._ws_pp)
        if_false_level = 0
        for index, token, value in RegexLexer.get_tokens_unprocessed(self, text, **kwargs):
            if if_false_level == 0:
                if token is Comment.Preproc and re.match('%sif%s+(0|nil)%s*$\\n?' % (pp, self._ws_pp, self._ws_pp), value):
                    if_false_level = 1
            elif token is Comment.Preproc:
                if if_false_level == 1 and re.match('%sel(if|se)\\b' % pp, value):
                    if_false_level = 0
                elif re.match('%sif' % pp, value):
                    if_false_level += 1
                elif re.match('%sendif\\b' % pp, value):
                    if_false_level -= 1
            else:
                token = Comment
            yield (index, token, value)