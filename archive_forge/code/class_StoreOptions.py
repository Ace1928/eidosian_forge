import difflib
import inspect
import pickle
import traceback
from collections import defaultdict
from contextlib import contextmanager
import numpy as np
import param
from .accessors import Opts  # noqa (clean up in 2.0)
from .pprint import InfoPrinter
from .tree import AttrTree
from .util import group_sanitizer, label_sanitizer, sanitize_identifier
class StoreOptions:
    """
    A collection of utilities for advanced users for creating and
    setting customized option trees on the Store. Designed for use by
    either advanced users or the %opts line and cell magics which use
    this machinery.

    This class also holds general classmethods for working with
    OptionTree instances: as OptionTrees are designed for attribute
    access it is best to minimize the number of methods implemented on
    that class and implement the necessary utilities on StoreOptions
    instead.

    Lastly this class offers a means to record all OptionErrors
    generated by an option specification. This is used for validation
    purposes.
    """
    _errors_recorded = None

    @classmethod
    def start_recording_skipped(cls):
        """
        Start collecting OptionErrors for all skipped options recorded
        with the record_skipped_option method
        """
        cls._errors_recorded = []

    @classmethod
    def stop_recording_skipped(cls):
        """
        Stop collecting OptionErrors recorded with the
        record_skipped_option method and return them
        """
        if cls._errors_recorded is None:
            raise Exception('Cannot stop recording before it is started')
        recorded = cls._errors_recorded[:]
        cls._errors_recorded = None
        return recorded

    @classmethod
    def record_skipped_option(cls, error):
        """
        Record the OptionError associated with a skipped option if
        currently recording
        """
        if cls._errors_recorded is not None:
            cls._errors_recorded.append(error)

    @classmethod
    def get_object_ids(cls, obj):
        return {el for el in obj.traverse(lambda x: getattr(x, 'id', None))}

    @classmethod
    def tree_to_dict(cls, tree):
        """
        Given an OptionTree, convert it into the equivalent dictionary format.
        """
        specs = {}
        for k in tree.keys():
            spec_key = '.'.join(k)
            specs[spec_key] = {}
            for grp in tree[k].groups:
                kwargs = tree[k].groups[grp].kwargs
                if kwargs:
                    specs[spec_key][grp] = kwargs
        return specs

    @classmethod
    def propagate_ids(cls, obj, match_id, new_id, applied_keys, backend=None):
        """
        Recursively propagate an id through an object for components
        matching the applied_keys. This method can only be called if
        there is a tree with a matching id in Store.custom_options
        """
        applied = []

        def propagate(o):
            if o.id == match_id or o.__class__.__name__ == 'DynamicMap':
                o.id = new_id
                applied.append(o)
        obj.traverse(propagate, specs=set(applied_keys) | {'DynamicMap'})
        if new_id not in Store.custom_options(backend=backend):
            raise AssertionError('New option id %d does not match any option trees in Store.custom_options.' % new_id)
        return applied

    @classmethod
    def capture_ids(cls, obj):
        """
        Given an list of ids, capture a list of ids that can be
        restored using the restore_ids.
        """
        return obj.traverse(lambda o: o.id)

    @classmethod
    def restore_ids(cls, obj, ids):
        """
        Given an list of ids as captured with capture_ids, restore the
        ids. Note the structure of an object must not change between
        the calls to capture_ids and restore_ids.
        """
        ids = iter(ids)
        obj.traverse(lambda o: setattr(o, 'id', next(ids)))

    @classmethod
    def apply_customizations(cls, spec, options):
        """
        Apply the given option specs to the supplied options tree.
        """
        for key in sorted(spec.keys()):
            if isinstance(spec[key], (list, tuple)):
                customization = {v.key: v for v in spec[key]}
            else:
                customization = {k: Options(**v) if isinstance(v, dict) else v for k, v in spec[key].items()}
            customization = {k: v.keywords_target(key.split('.')[0]) for k, v in customization.items()}
            options[str(key)] = customization
        return options

    @classmethod
    def validate_spec(cls, spec, backends=None):
        """
        Given a specification, validated it against the options tree for
        the specified backends by raising OptionError for invalid
        options. If backends is None, validates against all the
        currently loaded backend.

        Only useful when invalid keywords generate exceptions instead of
        skipping, i.e. Options.skip_invalid is False.
        """
        loaded_backends = Store.loaded_backends() if backends is None else backends
        error_info = {}
        backend_errors = defaultdict(set)
        for backend in loaded_backends:
            cls.start_recording_skipped()
            with options_policy(skip_invalid=True, warn_on_skip=False):
                options = OptionTree(items=Store.options(backend).data.items(), groups=Store.options(backend).groups, backend=backend)
                cls.apply_customizations(spec, options)
            for error in cls.stop_recording_skipped():
                error_key = (error.invalid_keyword, error.allowed_keywords.target, error.group_name)
                error_info[error_key + (backend,)] = error.allowed_keywords
                backend_errors[error_key].add(backend)
        for (keyword, target, group_name), backends in backend_errors.items():
            if set(backends) == set(loaded_backends):
                key = (keyword, target, group_name, Store.current_backend)
                raise OptionError(keyword, group_name=group_name, allowed_keywords=error_info[key])

    @classmethod
    def validation_error_message(cls, spec, backends=None):
        """
        Returns an options validation error message if there are any
        invalid keywords. Otherwise returns None.
        """
        try:
            cls.validate_spec(spec, backends=backends)
        except OptionError as e:
            return e.format_options_error()

    @classmethod
    def expand_compositor_keys(cls, spec):
        """
        Expands compositor definition keys into {type}.{group}
        keys. For instance a compositor operation returning a group
        string 'Image' of element type RGB expands to 'RGB.Image'.
        """
        expanded_spec = {}
        applied_keys = []
        compositor_defs = {el.group: el.output_type.__name__ for el in Compositor.definitions}
        for key, val in spec.items():
            if key not in compositor_defs:
                expanded_spec[key] = val
            else:
                applied_keys = ['Overlay']
                type_name = compositor_defs[key]
                expanded_spec[str(type_name + '.' + key)] = val
        return (expanded_spec, applied_keys)

    @classmethod
    def create_custom_trees(cls, obj, options=None, backend=None):
        """
        Returns the appropriate set of customized subtree clones for
        an object, suitable for merging with Store.custom_options (i.e
        with the ids appropriately offset). Note if an object has no
        integer ids a new OptionTree is built.

        The id_mapping return value is a list mapping the ids that
        need to be matched as set to their new values.
        """
        clones, id_mapping = ({}, [])
        obj_ids = cls.get_object_ids(obj)
        offset = cls.id_offset()
        obj_ids = [None] if len(obj_ids) == 0 else obj_ids
        used_obj_types = [(opt.split('.')[0],) for opt in options]
        backend = backend or Store.current_backend
        available_options = Store.options(backend=backend)
        used_options = {}
        for obj_type in available_options:
            if obj_type in used_obj_types:
                opts_groups = available_options[obj_type].groups
                used_options[obj_type] = {grp: Options(allowed_keywords=opt.allowed_keywords, backend=backend) for grp, opt in opts_groups.items()}
        custom_options = Store.custom_options(backend=backend)
        for tree_id in obj_ids:
            if tree_id is not None and tree_id in custom_options:
                original = custom_options[tree_id]
                clone = OptionTree(items=original.items(), groups=original.groups, backend=original.backend)
                clones[tree_id + offset + 1] = clone
                id_mapping.append((tree_id, tree_id + offset + 1))
            else:
                clone = OptionTree(groups=available_options.groups, backend=backend)
                clones[offset] = clone
                id_mapping.append((tree_id, offset))
            for obj_type, opts in used_options.items():
                clone[obj_type] = opts
        return ({k: cls.apply_customizations(options, t) if options else t for k, t in clones.items()}, id_mapping)

    @classmethod
    def merge_options(cls, groups, options=None, **kwargs):
        """
        Given a full options dictionary and options groups specified
        as a keywords, return the full set of merged options:

        >>> options={'Curve':{'style':dict(color='b')}}
        >>> style={'Curve':{'linewidth':10 }}
        >>> merged = StoreOptions.merge_options(['style'], options, style=style)
        >>> sorted(merged['Curve']['style'].items())
        [('color', 'b'), ('linewidth', 10)]
        """
        groups = set(groups)
        if options is not None and set(options.keys()) <= groups:
            kwargs, options = (options, None)
        elif options is not None and any((k in groups for k in options)):
            raise Exception(f'All keys must be a subset of {', '.join(groups)}.')
        options = {} if options is None else dict(**options)
        all_keys = {k for d in kwargs.values() for k in d}
        for spec_key in all_keys:
            additions = {}
            for k, d in kwargs.items():
                if spec_key in d:
                    kws = d[spec_key]
                    additions.update({k: kws})
            if spec_key not in options:
                options[spec_key] = {}
            for key in additions:
                if key in options[spec_key]:
                    options[spec_key][key].update(additions[key])
                else:
                    options[spec_key][key] = additions[key]
        return options

    @classmethod
    def state(cls, obj, state=None):
        """
        Method to capture and restore option state. When called
        without any state supplied, the current state is
        returned. Then if this state is supplied back in a later call
        using the same object, the original state is restored.
        """
        if state is None:
            ids = cls.capture_ids(obj)
            original_custom_keys = set(Store.custom_options().keys())
            return (ids, original_custom_keys)
        else:
            ids, original_custom_keys = state
            current_custom_keys = set(Store.custom_options().keys())
            for key in current_custom_keys.difference(original_custom_keys):
                del Store.custom_options()[key]
                cls.restore_ids(obj, ids)

    @classmethod
    @contextmanager
    def options(cls, obj, options=None, **kwargs):
        """
        Context-manager for temporarily setting options on an object
        (if options is None, no options will be set) . Once the
        context manager exits, both the object and the Store will be
        left in exactly the same state they were in before the context
        manager was used.

        See holoviews.core.options.set_options function for more
        information on the options specification format.
        """
        if options is not None or kwargs:
            Store._options_context = True
            optstate = cls.state(obj)
            groups = Store.options().groups.keys()
            options = cls.merge_options(groups, options, **kwargs)
            cls.set_options(obj, options)
        try:
            yield
        finally:
            if options is not None:
                Store._options_context = True
                cls.state(obj, state=optstate)

    @classmethod
    def id_offset(cls):
        """
        Compute an appropriate offset for future id values given the set
        of ids currently defined across backends.
        """
        max_ids = []
        for backend in Store.renderers.keys():
            store_ids = list(Store.custom_options(backend=backend).keys())
            max_id = max(store_ids) + 1 if len(store_ids) > 0 else 0
            max_ids.append(max_id)
        return max(max_ids) if len(max_ids) else 0

    @classmethod
    def update_backends(cls, id_mapping, custom_trees, backend=None):
        """
        Given the id_mapping from previous ids to new ids and the new
        custom tree dictionary, update the current backend with the
        supplied trees and update the keys in the remaining backends to
        stay linked with the current object.
        """
        backend = Store.current_backend if backend is None else backend
        Store.custom_options(backend=backend).update(custom_trees)
        Store._lookup_cache[backend] = {}
        for b in Store.loaded_backends():
            if b == backend:
                continue
            backend_trees = Store._custom_options[b]
            for old_id, new_id in id_mapping:
                tree = backend_trees.get(old_id, None)
                if tree is not None:
                    backend_trees[new_id] = tree

    @classmethod
    def set_options(cls, obj, options=None, backend=None, **kwargs):
        """
        Pure Python function for customize HoloViews objects in terms of
        their style, plot and normalization options.

        The options specification is a dictionary containing the target
        for customization as a {type}.{group}.{label} keys. An example of
        such a key is 'Image' which would customize all Image components
        in the object. The key 'Image.Channel' would only customize Images
        in the object that have the group 'Channel'.

        The corresponding value is then a list of Option objects specified
        with an appropriate category ('plot', 'style' or 'norm'). For
        instance, using the keys described above, the specs could be:

        {'Image:[Options('style', cmap='jet')]}

        Or setting two types of option at once:

        {'Image.Channel':[Options('plot', size=50),
                          Options('style', cmap='Blues')]}


        Relationship to the %%opts magic
        ----------------------------------

        This function matches the functionality supplied by the %%opts
        cell magic in the IPython extension. In fact, you can use the same
        syntax as the IPython cell magic to achieve the same customization
        as shown above:

        from holoviews.util.parser import OptsSpec
        set_options(my_image, OptsSpec.parse("Image (cmap='jet')"))

        Then setting both plot and style options:

        set_options(my_image, OptsSpec.parse("Image [size=50] (cmap='Blues')"))
        """
        groups = Store.options(backend=backend).groups.keys()
        options = cls.merge_options(groups, options, **kwargs)
        spec, compositor_applied = cls.expand_compositor_keys(options)
        custom_trees, id_mapping = cls.create_custom_trees(obj, spec, backend=backend)
        cls.update_backends(id_mapping, custom_trees, backend=backend)
        not_used = []
        for match_id, new_id in id_mapping:
            key = compositor_applied + list(spec.keys())
            applied = cls.propagate_ids(obj, match_id, new_id, key, backend=backend)
            if not applied:
                not_used.append(new_id)
        for new_id in set(not_used):
            cleanup_custom_options(new_id)
        return obj