import re
class JsLexer(Lexer):
    """
    A JavaScript lexer

    >>> lexer = JsLexer()
    >>> list(lexer.lex("a = 1"))
    [('id', 'a'), ('ws', ' '), ('punct', '='), ('ws', ' '), ('dnum', '1')]

    This doesn't properly handle non-ASCII characters in the JavaScript source.
    """
    both_before = [Tok('comment', '/\\*(.|\\n)*?\\*/'), Tok('linecomment', '//.*?$'), Tok('ws', '\\s+'), Tok('keyword', literals('\n                           break case catch class const continue debugger\n                           default delete do else enum export extends\n                           finally for function if import in instanceof\n                           new return super switch this throw try typeof\n                           var void while with\n                           ', suffix='\\b'), next='reg'), Tok('reserved', literals('null true false', suffix='\\b'), next='div'), Tok('id', '\n                  ([a-zA-Z_$   ]|\\\\u[0-9a-fA-Z]{4})   # first char\n                  ([a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*  # rest chars\n                  ', next='div'), Tok('hnum', '0[xX][0-9a-fA-F]+', next='div'), Tok('onum', '0[0-7]+'), Tok('dnum', '\n                    (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral\n                        \\.                  # dot\n                        [0-9]*              # DecimalDigits-opt\n                        ([eE][-+]?[0-9]+)?  # ExponentPart-opt\n                    |\n                        \\.                  # dot\n                        [0-9]+              # DecimalDigits\n                        ([eE][-+]?[0-9]+)?  # ExponentPart-opt\n                    |\n                        (0|[1-9][0-9]*)     # DecimalIntegerLiteral\n                        ([eE][-+]?[0-9]+)?  # ExponentPart-opt\n                    )\n                    ', next='div'), Tok('punct', literals('\n                         >>>= === !== >>> <<= >>= <= >= == != << >> &&\n                         || += -= *= %= &= |= ^=\n                         '), next='reg'), Tok('punct', literals('++ -- ) ]'), next='div'), Tok('punct', literals('{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : ='), next='reg'), Tok('string', '"([^"\\\\]|(\\\\(.|\\n)))*?"', next='div'), Tok('string', "'([^'\\\\]|(\\\\(.|\\n)))*?'", next='div')]
    both_after = [Tok('other', '.')]
    states = {'div': both_before + [Tok('punct', literals('/= /'), next='reg')] + both_after, 'reg': both_before + [Tok('regex', '\n                    /                       # opening slash\n                    # First character is..\n                    (   [^*\\\\/[]            # anything but * \\ / or [\n                    |   \\\\.                 # or an escape sequence\n                    |   \\[                  # or a class, which has\n                            (   [^\\]\\\\]     #   anything but \\ or ]\n                            |   \\\\.         #   or an escape sequence\n                            )*              #   many times\n                        \\]\n                    )\n                    # Following characters are same, except for excluding a star\n                    (   [^\\\\/[]             # anything but \\ / or [\n                    |   \\\\.                 # or an escape sequence\n                    |   \\[                  # or a class, which has\n                            (   [^\\]\\\\]     #   anything but \\ or ]\n                            |   \\\\.         #   or an escape sequence\n                            )*              #   many times\n                        \\]\n                    )*                      # many times\n                    /                       # closing slash\n                    [a-zA-Z0-9]*            # trailing flags\n                ', next='div')] + both_after}

    def __init__(self):
        super().__init__(self.states, 'reg')