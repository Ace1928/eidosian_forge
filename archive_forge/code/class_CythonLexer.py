import re
from pygments.lexer import Lexer, RegexLexer, include, bygroups, using, \
from pygments.util import get_bool_opt, shebang_matches
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
from pygments import unistring as uni
class CythonLexer(RegexLexer):
    """
    For Pyrex and `Cython <http://cython.org>`_ source code.

    .. versionadded:: 1.1
    """
    name = 'Cython'
    aliases = ['cython', 'pyx', 'pyrex']
    filenames = ['*.pyx', '*.pxd', '*.pxi']
    mimetypes = ['text/x-cython', 'application/x-cython']
    tokens = {'root': [('\\n', Text), ('^(\\s*)("""(?:.|\\n)*?""")', bygroups(Text, String.Doc)), ("^(\\s*)('''(?:.|\\n)*?''')", bygroups(Text, String.Doc)), ('[^\\S\\n]+', Text), ('#.*$', Comment), ('[]{}:(),;[]', Punctuation), ('\\\\\\n', Text), ('\\\\', Text), ('(in|is|and|or|not)\\b', Operator.Word), ('(<)([a-zA-Z0-9.?]+)(>)', bygroups(Punctuation, Keyword.Type, Punctuation)), ('!=|==|<<|>>|[-~+/*%=<>&^|.?]', Operator), ('(from)(\\d+)(<=)(\\s+)(<)(\\d+)(:)', bygroups(Keyword, Number.Integer, Operator, Name, Operator, Name, Punctuation)), include('keywords'), ('(def|property)(\\s+)', bygroups(Keyword, Text), 'funcname'), ('(cp?def)(\\s+)', bygroups(Keyword, Text), 'cdef'), ('(cdef)(:)', bygroups(Keyword, Punctuation)), ('(class|struct)(\\s+)', bygroups(Keyword, Text), 'classname'), ('(from)(\\s+)', bygroups(Keyword, Text), 'fromimport'), ('(c?import)(\\s+)', bygroups(Keyword, Text), 'import'), include('builtins'), include('backtick'), ('(?:[rR]|[uU][rR]|[rR][uU])"""', String, 'tdqs'), ("(?:[rR]|[uU][rR]|[rR][uU])'''", String, 'tsqs'), ('(?:[rR]|[uU][rR]|[rR][uU])"', String, 'dqs'), ("(?:[rR]|[uU][rR]|[rR][uU])'", String, 'sqs'), ('[uU]?"""', String, combined('stringescape', 'tdqs')), ("[uU]?'''", String, combined('stringescape', 'tsqs')), ('[uU]?"', String, combined('stringescape', 'dqs')), ("[uU]?'", String, combined('stringescape', 'sqs')), include('name'), include('numbers')], 'keywords': [(words(('assert', 'break', 'by', 'continue', 'ctypedef', 'del', 'elif', 'else', 'except', 'except?', 'exec', 'finally', 'for', 'fused', 'gil', 'global', 'if', 'include', 'lambda', 'nogil', 'pass', 'print', 'raise', 'return', 'try', 'while', 'yield', 'as', 'with'), suffix='\\b'), Keyword), ('(DEF|IF|ELIF|ELSE)\\b', Comment.Preproc)], 'builtins': [(words(('__import__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'list', 'locals', 'long', 'map', 'max', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'property', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'unsigned', 'vars', 'xrange', 'zip'), prefix='(?<!\\.)', suffix='\\b'), Name.Builtin), ('(?<!\\.)(self|None|Ellipsis|NotImplemented|False|True|NULL)\\b', Name.Builtin.Pseudo), (words(('ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'DeprecationWarning', 'EOFError', 'EnvironmentError', 'Exception', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError'), prefix='(?<!\\.)', suffix='\\b'), Name.Exception)], 'numbers': [('(\\d+\\.?\\d*|\\d*\\.\\d+)([eE][+-]?[0-9]+)?', Number.Float), ('0\\d+', Number.Oct), ('0[xX][a-fA-F0-9]+', Number.Hex), ('\\d+L', Number.Integer.Long), ('\\d+', Number.Integer)], 'backtick': [('`.*?`', String.Backtick)], 'name': [('@\\w+', Name.Decorator), ('[a-zA-Z_]\\w*', Name)], 'funcname': [('[a-zA-Z_]\\w*', Name.Function, '#pop')], 'cdef': [('(public|readonly|extern|api|inline)\\b', Keyword.Reserved), ('(struct|enum|union|class)\\b', Keyword), ('([a-zA-Z_]\\w*)(\\s*)(?=[(:#=]|$)', bygroups(Name.Function, Text), '#pop'), ('([a-zA-Z_]\\w*)(\\s*)(,)', bygroups(Name.Function, Text, Punctuation)), ('from\\b', Keyword, '#pop'), ('as\\b', Keyword), (':', Punctuation, '#pop'), ('(?=["\\\'])', Text, '#pop'), ('[a-zA-Z_]\\w*', Keyword.Type), ('.', Text)], 'classname': [('[a-zA-Z_]\\w*', Name.Class, '#pop')], 'import': [('(\\s+)(as)(\\s+)', bygroups(Text, Keyword, Text)), ('[a-zA-Z_][\\w.]*', Name.Namespace), ('(\\s*)(,)(\\s*)', bygroups(Text, Operator, Text)), default('#pop')], 'fromimport': [('(\\s+)(c?import)\\b', bygroups(Text, Keyword), '#pop'), ('[a-zA-Z_.][\\w.]*', Name.Namespace), default('#pop')], 'stringescape': [('\\\\([\\\\abfnrtv"\\\']|\\n|N\\{.*?\\}|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8}|x[a-fA-F0-9]{2}|[0-7]{1,3})', String.Escape)], 'strings': [('%(\\([a-zA-Z0-9]+\\))?[-#0 +]*([0-9]+|[*])?(\\.([0-9]+|[*]))?[hlL]?[E-GXc-giorsux%]', String.Interpol), ('[^\\\\\\\'"%\\n]+', String), ('[\\\'"\\\\]', String), ('%', String)], 'nl': [('\\n', String)], 'dqs': [('"', String, '#pop'), ('\\\\\\\\|\\\\"|\\\\\\n', String.Escape), include('strings')], 'sqs': [("'", String, '#pop'), ("\\\\\\\\|\\\\'|\\\\\\n", String.Escape), include('strings')], 'tdqs': [('"""', String, '#pop'), include('strings'), include('nl')], 'tsqs': [("'''", String, '#pop'), include('strings'), include('nl')]}