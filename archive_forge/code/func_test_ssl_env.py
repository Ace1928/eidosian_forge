import functools
import json
import os
import ssl
import subprocess
import sys
import threading
import time
import traceback
import http.client
import OpenSSL.SSL
import pytest
import requests
import trustme
from .._compat import bton, ntob, ntou
from .._compat import IS_ABOVE_OPENSSL10, IS_CI, IS_PYPY
from .._compat import IS_LINUX, IS_MACOS, IS_WINDOWS
from ..server import HTTPServer, get_ssl_adapter_class
from ..testing import (
from ..wsgi import Gateway_10
@pytest.mark.parametrize('adapter_type', (pytest.param('builtin', marks=pytest.mark.xfail(IS_MACOS and PY310_PLUS, reason='Unclosed TLS resource warnings happen on macOS under Python 3.10 (#508)', strict=False)), 'pyopenssl'))
@pytest.mark.parametrize(('tls_verify_mode', 'use_client_cert'), ((ssl.CERT_NONE, False), (ssl.CERT_NONE, True), (ssl.CERT_OPTIONAL, False), (ssl.CERT_OPTIONAL, True), (ssl.CERT_REQUIRED, True)))
def test_ssl_env(thread_exceptions, recwarn, mocker, http_request_timeout, tls_http_server, adapter_type, ca, tls_verify_mode, tls_certificate, tls_certificate_chain_pem_path, tls_certificate_private_key_pem_path, tls_ca_certificate_pem_path, use_client_cert):
    """Test the SSL environment generated by the SSL adapters."""
    interface, _host, port = _get_conn_data(ANY_INTERFACE_IPV4)
    with mocker.mock_module.patch('idna.core.ulabel', return_value=ntob('127.0.0.1')):
        client_cert = ca.issue_cert(ntou('127.0.0.1'))
    with client_cert.private_key_and_cert_chain_pem.tempfile() as cl_pem:
        tls_adapter_cls = get_ssl_adapter_class(name=adapter_type)
        tls_adapter = tls_adapter_cls(tls_certificate_chain_pem_path, tls_certificate_private_key_pem_path)
        if adapter_type == 'pyopenssl':
            tls_adapter.context = tls_adapter.get_context()
            tls_adapter.context.set_verify(_stdlib_to_openssl_verify[tls_verify_mode], lambda conn, cert, errno, depth, preverify_ok: preverify_ok)
        else:
            tls_adapter.context.verify_mode = tls_verify_mode
        ca.configure_trust(tls_adapter.context)
        tls_certificate.configure_cert(tls_adapter.context)
        tlswsgiserver = tls_http_server((interface, port), tls_adapter)
        interface, _host, port = _get_conn_data(tlswsgiserver.bind_addr)
        resp = requests.get('https://' + interface + ':' + str(port) + '/env', timeout=http_request_timeout, verify=tls_ca_certificate_pem_path, cert=cl_pem if use_client_cert else None)
        env = json.loads(resp.content.decode('utf-8'))
        assert env['wsgi.url_scheme'] == 'https'
        assert env['HTTPS'] == 'on'
        for key in {'SSL_VERSION_INTERFACE', 'SSL_VERSION_LIBRARY'}:
            assert key in env
        if adapter_type == 'pyopenssl':
            return
        for key in {'SSL_PROTOCOL', 'SSL_CIPHER'}:
            assert key in env
        if tls_verify_mode == ssl.CERT_NONE or not use_client_cert:
            assert env['SSL_CLIENT_VERIFY'] == 'NONE'
        else:
            assert env['SSL_CLIENT_VERIFY'] == 'SUCCESS'
            with open(cl_pem, 'rt') as f:
                assert env['SSL_CLIENT_CERT'] in f.read()
            for key in {'SSL_CLIENT_M_VERSION', 'SSL_CLIENT_M_SERIAL', 'SSL_CLIENT_I_DN', 'SSL_CLIENT_S_DN'}:
                assert key in env
    if IS_PYPY:
        return
    for warn in recwarn:
        if not issubclass(warn.category, ResourceWarning):
            continue
        msg = str(warn.message)
        if 'socket.socket' in msg:
            pytest.xfail('\n'.join(('Sometimes this test fails due to a socket.socket ResourceWarning:', msg)))
        pytest.fail(msg)
    for _, _, trace in thread_exceptions:
        print(trace, file=sys.stderr)
    assert not thread_exceptions, ': '.join((thread_exceptions[0][0].__name__, thread_exceptions[0][1]))