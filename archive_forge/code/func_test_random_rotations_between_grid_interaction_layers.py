import itertools
from typing import Callable, Dict, Iterable, List, Optional, Sequence, Set, Tuple, cast
import networkx as nx
import numpy as np
import pytest
import cirq
from cirq.experiments import (
from cirq.experiments.random_quantum_circuit_generation import (
@pytest.mark.parametrize('qubits, depth, two_qubit_op_factory, pattern, single_qubit_gates, add_final_single_qubit_layer, seed, expected_circuit_length, single_qubit_layers_slice, two_qubit_layers_slice', (((cirq.q(0, 0), cirq.q(0, 1), cirq.q(0, 2)), 4, lambda a, b, _: cirq.CZ(a, b), [[(cirq.q(0, 0), cirq.q(0, 1))], [(cirq.q(0, 1), cirq.q(0, 2))]], (cirq.X ** 0.5,), True, 1234, 9, slice(None, None, 2), slice(1, None, 2)), ((cirq.q(0, 0), cirq.q(0, 1), cirq.q(0, 2)), 4, lambda a, b, _: cirq.CZ(a, b), [[(cirq.q(0, 1), cirq.q(0, 0))], [(cirq.q(0, 1), cirq.q(0, 2))]], (cirq.X ** 0.5,), True, 1234, 9, slice(None, None, 2), slice(1, None, 2)), (cirq.GridQubit.rect(4, 3), 20, lambda a, b, _: cirq.CZ(a, b), cirq.experiments.GRID_STAGGERED_PATTERN, (cirq.X ** 0.5, cirq.Y ** 0.5, cirq.Z ** 0.5), True, 1234, 41, slice(None, None, 2), slice(1, None, 2)), (cirq.GridQubit.rect(4, 3), 20, lambda a, b, _: FakeSycamoreGate()(a, b), cirq.experiments.HALF_GRID_STAGGERED_PATTERN, (cirq.X ** 0.5, cirq.Y ** 0.5, cirq.Z ** 0.5), True, 1234, 41, slice(None, None, 2), slice(1, None, 2)), (cirq.GridQubit.rect(4, 5), 21, lambda a, b, _: cirq.CZ(a, b), cirq.experiments.GRID_ALIGNED_PATTERN, (cirq.X ** 0.5, cirq.Y ** 0.5, cirq.Z ** 0.5), True, 1234, 43, slice(None, None, 2), slice(1, None, 2)), (cirq.GridQubit.rect(5, 4), 22, _cz_with_adjacent_z_rotations, cirq.experiments.GRID_STAGGERED_PATTERN, (cirq.X ** 0.5, cirq.Y ** 0.5, cirq.Z ** 0.5), True, 1234, 89, slice(None, None, 4), slice(2, None, 4)), (cirq.GridQubit.rect(5, 5), 23, lambda a, b, _: cirq.CZ(a, b), cirq.experiments.GRID_ALIGNED_PATTERN, (cirq.X ** 0.5, cirq.Y ** 0.5, cirq.Z ** 0.5), False, 1234, 46, slice(None, None, 2), slice(1, None, 2)), (cirq.GridQubit.rect(5, 5), 24, lambda a, b, _: cirq.CZ(a, b), cirq.experiments.GRID_ALIGNED_PATTERN, (cirq.X ** 0.5, cirq.X ** 0.5), True, 1234, 49, slice(None, None, 2), slice(1, None, 2))))
def test_random_rotations_between_grid_interaction_layers(qubits: Iterable[cirq.GridQubit], depth: int, two_qubit_op_factory: Callable[[cirq.GridQubit, cirq.GridQubit, np.random.RandomState], cirq.OP_TREE], pattern: Sequence[GridInteractionLayer], single_qubit_gates: Sequence[cirq.Gate], add_final_single_qubit_layer: bool, seed: 'cirq.RANDOM_STATE_OR_SEED_LIKE', expected_circuit_length: int, single_qubit_layers_slice: slice, two_qubit_layers_slice: slice):
    qubits = set(qubits)
    circuit = random_rotations_between_grid_interaction_layers_circuit(qubits, depth, two_qubit_op_factory=two_qubit_op_factory, pattern=pattern, single_qubit_gates=single_qubit_gates, add_final_single_qubit_layer=add_final_single_qubit_layer, seed=seed)
    assert len(circuit) == expected_circuit_length
    _validate_single_qubit_layers(qubits, cast(Sequence[cirq.Moment], circuit[single_qubit_layers_slice]), non_repeating_layers=len(set(single_qubit_gates)) > 1)
    _validate_two_qubit_layers(qubits, cast(Sequence[cirq.Moment], circuit[two_qubit_layers_slice]), pattern)