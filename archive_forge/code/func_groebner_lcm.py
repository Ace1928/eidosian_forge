from sympy.core.symbol import Dummy
from sympy.polys.monomials import monomial_mul, monomial_lcm, monomial_divides, term_div
from sympy.polys.orderings import lex
from sympy.polys.polyerrors import DomainError
from sympy.polys.polyconfig import query
def groebner_lcm(f, g):
    """
    Computes LCM of two polynomials using Groebner bases.

    The LCM is computed as the unique generator of the intersection
    of the two ideals generated by `f` and `g`. The approach is to
    compute a Groebner basis with respect to lexicographic ordering
    of `t*f` and `(1 - t)*g`, where `t` is an unrelated variable and
    then filtering out the solution that does not contain `t`.

    References
    ==========

    .. [1] [Cox97]_

    """
    if f.ring != g.ring:
        raise ValueError('Values should be equal')
    ring = f.ring
    domain = ring.domain
    if not f or not g:
        return ring.zero
    if len(f) <= 1 and len(g) <= 1:
        monom = monomial_lcm(f.LM, g.LM)
        coeff = domain.lcm(f.LC, g.LC)
        return ring.term_new(monom, coeff)
    fc, f = f.primitive()
    gc, g = g.primitive()
    lcm = domain.lcm(fc, gc)
    f_terms = [((1,) + monom, coeff) for monom, coeff in f.terms()]
    g_terms = [((0,) + monom, coeff) for monom, coeff in g.terms()] + [((1,) + monom, -coeff) for monom, coeff in g.terms()]
    t = Dummy('t')
    t_ring = ring.clone(symbols=(t,) + ring.symbols, order=lex)
    F = t_ring.from_terms(f_terms)
    G = t_ring.from_terms(g_terms)
    basis = groebner([F, G], t_ring)

    def is_independent(h, j):
        return not any((monom[j] for monom in h.monoms()))
    H = [h for h in basis if is_independent(h, 0)]
    h_terms = [(monom[1:], coeff * lcm) for monom, coeff in H[0].terms()]
    h = ring.from_terms(h_terms)
    return h