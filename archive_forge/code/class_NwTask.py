from __future__ import annotations
import os
import re
import warnings
from string import Template
from typing import TYPE_CHECKING
import numpy as np
from monty.io import zopen
from monty.json import MSONable
from pymatgen.analysis.excitation import ExcitationSpectrum
from pymatgen.core.structure import Molecule, Structure
from pymatgen.core.units import Energy, FloatWithUnit
class NwTask(MSONable):
    """Base task for Nwchem."""
    theories = {'g3gn': 'some description', 'scf': 'Hartree-Fock', 'dft': 'DFT', 'esp': 'ESP', 'sodft': 'Spin-Orbit DFT', 'mp2': 'MP2 using a semi-direct algorithm', 'direct_mp2': 'MP2 using a full-direct algorithm', 'rimp2': 'MP2 using the RI approximation', 'ccsd': 'Coupled-cluster single and double excitations', 'ccsd(t)': 'Coupled-cluster linearized triples approximation', 'ccsd+t(ccsd)': 'Fourth order triples contribution', 'mcscf': 'Multiconfiguration SCF', 'selci': 'Selected CI with perturbation correction', 'md': 'Classical molecular dynamics simulation', 'pspw': 'Pseudopotential plane-wave DFT for molecules and insulating solids using NWPW', 'band': 'Pseudopotential plane-wave DFT for solids using NWPW', 'tce': 'Tensor Contraction Engine', 'tddft': 'Time Dependent DFT'}
    operations = {'energy': 'Evaluate the single point energy.', 'gradient': 'Evaluate the derivative of the energy with respect to nuclear coordinates.', 'optimize': 'Minimize the energy by varying the molecular structure.', 'saddle': 'Conduct a search for a transition state (or saddle point).', 'hessian': 'Compute second derivatives.', 'frequencies': 'Compute second derivatives and print out an analysis of molecular vibrations.', 'freq': 'Same as frequencies.', 'vscf': 'Compute anharmonic contributions to the vibrational modes.', 'property': 'Calculate the properties for the wave function.', 'dynamics': 'Perform classical molecular dynamics.', 'thermodynamics': 'Perform multi-configuration thermodynamic integration using classical MD.', '': 'dummy'}

    def __init__(self, charge, spin_multiplicity, basis_set, basis_set_option='cartesian', title=None, theory='dft', operation='optimize', theory_directives=None, alternate_directives=None):
        """
        Very flexible arguments to support many types of potential setups.
        Users should use more friendly static methods unless they need the
        flexibility.

        Args:
            charge: Charge of the molecule. If None, charge on molecule is
                used. Defaults to None. This allows the input file to be set a
                charge independently from the molecule itself.
            spin_multiplicity: Spin multiplicity of molecule. Defaults to None,
                which means that the spin multiplicity is set to 1 if the
                molecule has no unpaired electrons and to 2 if there are
                unpaired electrons.
            basis_set: The basis set used for the task as a dict. E.g.,
                {"C": "6-311++G**", "H": "6-31++G**"}.
            basis_set_option: cartesian (default) | spherical,
            title: Title for the task. Defaults to None, which means a title
                based on the theory and operation of the task is
                autogenerated.
            theory: The theory used for the task. Defaults to "dft".
            operation: The operation for the task. Defaults to "optimize".
            theory_directives: A dict of theory directives. For example,
                if you are running dft calculations, you may specify the
                exchange correlation functional using {"xc": "b3lyp"}.
            alternate_directives: A dict of alternate directives. For
                example, to perform cosmo calculations and dielectric
                constant of 78, you'd supply {'cosmo': {"dielectric": 78}}.
        """
        if theory.lower() not in NwTask.theories:
            raise NwInputError(f'Invalid theory={theory!r}')
        if operation.lower() not in NwTask.operations:
            raise NwInputError(f'Invalid operation={operation!r}')
        self.charge = charge
        self.spin_multiplicity = spin_multiplicity
        self.title = title if title is not None else f'{theory} {operation}'
        self.theory = theory
        self.basis_set = basis_set or {}
        if NWCHEM_BASIS_LIBRARY is not None:
            for b in set(self.basis_set.values()):
                if re.sub('\\*', 's', b.lower()) not in NWCHEM_BASIS_LIBRARY:
                    warnings.warn(f'Basis set {b} not in NWCHEM_BASIS_LIBRARY')
        self.basis_set_option = basis_set_option
        self.operation = operation
        self.theory_directives = theory_directives or {}
        self.alternate_directives = alternate_directives or {}

    def __str__(self):
        bset_spec = []
        for el, bset in sorted(self.basis_set.items(), key=lambda x: x[0]):
            bset_spec.append(f' {el} library "{bset}"')
        theory_spec = []
        if self.theory_directives:
            theory_spec.append(f'{self.theory}')
            for k in sorted(self.theory_directives):
                theory_spec.append(f' {k} {self.theory_directives[k]}')
            theory_spec.append('end')
        for k in sorted(self.alternate_directives):
            theory_spec.append(k)
            for k2 in sorted(self.alternate_directives[k]):
                theory_spec.append(f' {k2} {self.alternate_directives[k][k2]}')
            theory_spec.append('end')
        t = Template('title "$title"\ncharge $charge\nbasis $basis_set_option\n$bset_spec\nend\n$theory_spec\n')
        output = t.substitute(title=self.title, charge=int(self.charge), spinmult=self.spin_multiplicity, basis_set_option=self.basis_set_option, bset_spec='\n'.join(bset_spec), theory_spec='\n'.join(theory_spec), theory=self.theory)
        if self.operation is not None:
            output += f'task {self.theory} {self.operation}'
        return output

    def as_dict(self):
        """Returns: MSONable dict."""
        return {'@module': type(self).__module__, '@class': type(self).__name__, 'charge': self.charge, 'spin_multiplicity': self.spin_multiplicity, 'title': self.title, 'theory': self.theory, 'operation': self.operation, 'basis_set': self.basis_set, 'basis_set_option': self.basis_set_option, 'theory_directives': self.theory_directives, 'alternate_directives': self.alternate_directives}

    @classmethod
    def from_dict(cls, dct: dict) -> Self:
        """
        Args:
            dct (dict): Dict representation.

        Returns:
            NwTask
        """
        return cls(charge=dct['charge'], spin_multiplicity=dct['spin_multiplicity'], title=dct['title'], theory=dct['theory'], operation=dct['operation'], basis_set=dct['basis_set'], basis_set_option=dct['basis_set_option'], theory_directives=dct['theory_directives'], alternate_directives=dct['alternate_directives'])

    @classmethod
    def from_molecule(cls, mol, theory, charge=None, spin_multiplicity=None, basis_set='6-31g', basis_set_option='cartesian', title=None, operation='optimize', theory_directives=None, alternate_directives=None) -> Self:
        """
        Very flexible arguments to support many types of potential setups.
        Users should use more friendly static methods unless they need the
        flexibility.

        Args:
            mol: Input molecule
            charge: Charge of the molecule. If None, charge on molecule is
                used. Defaults to None. This allows the input file to be set a
                charge independently from the molecule itself.
            spin_multiplicity: Spin multiplicity of molecule. Defaults to None,
                which means that the spin multiplicity is set to 1 if the
                molecule has no unpaired electrons and to 2 if there are
                unpaired electrons.
            basis_set: The basis set to be used as string or a dict. E.g.,
                {"C": "6-311++G**", "H": "6-31++G**"} or "6-31G". If string,
                same basis set is used for all elements.
            basis_set_option: cartesian (default) | spherical,
            title: Title for the task. Defaults to None, which means a title
                based on the theory and operation of the task is
                autogenerated.
            theory: The theory used for the task. Defaults to "dft".
            operation: The operation for the task. Defaults to "optimize".
            theory_directives: A dict of theory directives. For example,
                if you are running dft calculations, you may specify the
                exchange correlation functional using {"xc": "b3lyp"}.
            alternate_directives: A dict of alternate directives. For
                example, to perform cosmo calculations with DFT, you'd supply
                {'cosmo': "cosmo"}.
        """
        formula = re.sub('\\s', '', mol.formula)
        title = title if title is not None else f'{formula} {theory} {operation}'
        charge = charge if charge is not None else mol.charge
        n_electrons = -charge + mol.charge + mol.nelectrons
        if spin_multiplicity is not None:
            if (n_electrons + spin_multiplicity) % 2 != 1:
                raise ValueError(f'charge={charge!r} and spin_multiplicity={spin_multiplicity!r} is not possible for this molecule')
        elif charge == mol.charge:
            spin_multiplicity = mol.spin_multiplicity
        else:
            spin_multiplicity = 1 if n_electrons % 2 == 0 else 2
        elements = set(mol.composition.get_el_amt_dict())
        if isinstance(basis_set, str):
            basis_set = dict.fromkeys(elements, basis_set)
        return cls(charge, spin_multiplicity, basis_set, basis_set_option=basis_set_option, title=title, theory=theory, operation=operation, theory_directives=theory_directives, alternate_directives=alternate_directives)

    @classmethod
    def dft_task(cls, mol, xc='b3lyp', **kwargs):
        """
        A class method for quickly creating DFT tasks with optional
        cosmo parameter .

        Args:
            mol: Input molecule
            xc: Exchange correlation to use.
            kwargs: Any of the other kwargs supported by NwTask. Note the
                theory is always "dft" for a dft task.
        """
        t = NwTask.from_molecule(mol, theory='dft', **kwargs)
        t.theory_directives.update({'xc': xc, 'mult': t.spin_multiplicity})
        return t

    @classmethod
    def esp_task(cls, mol, **kwargs):
        """
        A class method for quickly creating ESP tasks with RESP
        charge fitting.

        Args:
            mol: Input molecule
            kwargs: Any of the other kwargs supported by NwTask. Note the
                theory is always "dft" for a dft task.
        """
        return NwTask.from_molecule(mol, theory='esp', **kwargs)