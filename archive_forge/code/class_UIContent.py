from __future__ import unicode_literals
from abc import ABCMeta, abstractmethod
from collections import namedtuple
from six import with_metaclass
from six.moves import range
from prompt_toolkit.cache import SimpleCache
from prompt_toolkit.enums import DEFAULT_BUFFER, SEARCH_BUFFER
from prompt_toolkit.filters import to_cli_filter
from prompt_toolkit.mouse_events import MouseEventType
from prompt_toolkit.search_state import SearchState
from prompt_toolkit.selection import SelectionType
from prompt_toolkit.token import Token
from prompt_toolkit.utils import get_cwidth
from .lexers import Lexer, SimpleLexer
from .processors import Processor
from .screen import Char, Point
from .utils import token_list_width, split_lines, token_list_to_text
import six
import time
class UIContent(object):
    """
    Content generated by a user control. This content consists of a list of
    lines.

    :param get_line: Callable that returns the current line. This is a list of
        (Token, text) tuples.
    :param line_count: The number of lines.
    :param cursor_position: a :class:`.Point` for the cursor position.
    :param menu_position: a :class:`.Point` for the menu position.
    :param show_cursor: Make the cursor visible.
    :param default_char: The default :class:`.Char` for filling the background.
    """

    def __init__(self, get_line=None, line_count=0, cursor_position=None, menu_position=None, show_cursor=True, default_char=None):
        assert callable(get_line)
        assert isinstance(line_count, six.integer_types)
        assert cursor_position is None or isinstance(cursor_position, Point)
        assert menu_position is None or isinstance(menu_position, Point)
        assert default_char is None or isinstance(default_char, Char)
        self.get_line = get_line
        self.line_count = line_count
        self.cursor_position = cursor_position or Point(0, 0)
        self.menu_position = menu_position
        self.show_cursor = show_cursor
        self.default_char = default_char
        self._line_heights = {}

    def __getitem__(self, lineno):
        """ Make it iterable (iterate line by line). """
        if lineno < self.line_count:
            return self.get_line(lineno)
        else:
            raise IndexError

    def get_height_for_line(self, lineno, width):
        """
        Return the height that a given line would need if it is rendered in a
        space with the given width.
        """
        try:
            return self._line_heights[lineno, width]
        except KeyError:
            text = token_list_to_text(self.get_line(lineno))
            result = self.get_height_for_text(text, width)
            self._line_heights[lineno, width] = result
            return result

    @staticmethod
    def get_height_for_text(text, width):
        line_width = get_cwidth(text)
        try:
            quotient, remainder = divmod(line_width, width)
        except ZeroDivisionError:
            return 10 ** 10
        else:
            if remainder:
                quotient += 1
            return max(1, quotient)