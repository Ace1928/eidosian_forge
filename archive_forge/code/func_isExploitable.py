from winappdbg import win32
from winappdbg import compat
from winappdbg.system import System
from winappdbg.textio import HexDump, CrashDump
from winappdbg.util import StaticClass, MemoryAddresses, PathOperations
import sys
import os
import time
import zlib
import warnings
def isExploitable(self):
    """
        Guess how likely is it that the bug causing the crash can be leveraged
        into an exploitable vulnerability.

        @note: Don't take this as an equivalent of a real exploitability
            analysis, that can only be done by a human being! This is only
            a guideline, useful for example to sort crashes - placing the most
            interesting ones at the top.

        @see: The heuristics are similar to those of the B{!exploitable}
            extension for I{WinDBG}, which can be downloaded from here:

            U{http://www.codeplex.com/msecdbg}

        @rtype: tuple( str, str, str )
        @return: The first element of the tuple is the result of the analysis,
            being one of the following:

             - Not an exception
             - Not exploitable
             - Not likely exploitable
             - Unknown
             - Probably exploitable
             - Exploitable

            The second element of the tuple is a code to identify the matched
            heuristic rule.

            The third element of the tuple is a description string of the
            reason behind the result.
        """
    if self.eventCode != win32.EXCEPTION_DEBUG_EVENT:
        return ('Not an exception', 'NotAnException', 'The event is not an exception.')
    if self.stackRange and self.pc is not None and (self.stackRange[0] <= self.pc < self.stackRange[1]):
        return ('Exploitable', 'StackCodeExecution', 'Code execution from the stack is considered exploitable.')
    if self.stackRange and self.sp is not None and (not self.stackRange[0] <= self.sp < self.stackRange[1]):
        return ('Exploitable', 'StackPointerCorruption', 'Stack pointer corruption is considered exploitable.')
    if self.exceptionCode == win32.EXCEPTION_ILLEGAL_INSTRUCTION:
        return ('Exploitable', 'IllegalInstruction', 'An illegal instruction exception indicates that the attacker controls execution flow.')
    if self.exceptionCode == win32.EXCEPTION_PRIV_INSTRUCTION:
        return ('Exploitable', 'PrivilegedInstruction', 'A privileged instruction exception indicates that the attacker controls execution flow.')
    if self.exceptionCode == win32.EXCEPTION_GUARD_PAGE:
        return ('Exploitable', 'GuardPage', 'A guard page violation indicates a stack overflow has occured, and the stack of another thread was reached (possibly the overflow length is not controlled by the attacker).')
    if self.exceptionCode == win32.STATUS_STACK_BUFFER_OVERRUN:
        return ('Exploitable', 'GSViolation', 'An overrun of a protected stack buffer has been detected. This is considered exploitable, and must be fixed.')
    if self.exceptionCode == win32.STATUS_HEAP_CORRUPTION:
        return ('Exploitable', 'HeapCorruption', 'Heap Corruption has been detected. This is considered exploitable, and must be fixed.')
    if self.exceptionCode == win32.EXCEPTION_ACCESS_VIOLATION:
        nearNull = self.faultAddress is None or MemoryAddresses.align_address_to_page_start(self.faultAddress) == 0
        controlFlow = self.__is_control_flow()
        blockDataMove = self.__is_block_data_move()
        if self.faultType == win32.EXCEPTION_EXECUTE_FAULT:
            if nearNull:
                return ('Probably exploitable', 'DEPViolation', 'User mode DEP access violations are probably exploitable if near NULL.')
            else:
                return ('Exploitable', 'DEPViolation', 'User mode DEP access violations are exploitable.')
        elif self.faultType == win32.EXCEPTION_WRITE_FAULT:
            if nearNull:
                return ('Probably exploitable', 'WriteAV', 'User mode write access violations that are near NULL are probably exploitable.')
            else:
                return ('Exploitable', 'WriteAV', 'User mode write access violations that are not near NULL are exploitable.')
        elif self.faultType == win32.EXCEPTION_READ_FAULT:
            if self.faultAddress == self.pc:
                if nearNull:
                    return ('Probably exploitable', 'ReadAVonIP', 'Access violations at the instruction pointer are probably exploitable if near NULL.')
                else:
                    return ('Exploitable', 'ReadAVonIP', 'Access violations at the instruction pointer are exploitable if not near NULL.')
            if controlFlow:
                if nearNull:
                    return ('Probably exploitable', 'ReadAVonControlFlow', 'Access violations near null in control flow instructions are considered probably exploitable.')
                else:
                    return ('Exploitable', 'ReadAVonControlFlow', 'Access violations not near null in control flow instructions are considered exploitable.')
            if blockDataMove:
                return ('Probably exploitable', 'ReadAVonBlockMove', 'This is a read access violation in a block data move, and is therefore classified as probably exploitable.')
    result = ('Unknown', 'Unknown', 'Exploitability unknown.')
    if self.exceptionCode == win32.EXCEPTION_ACCESS_VIOLATION:
        if self.faultType == win32.EXCEPTION_READ_FAULT:
            if nearNull:
                result = ('Not likely exploitable', 'ReadAVNearNull', 'This is a user mode read access violation near null, and is probably not exploitable.')
    elif self.exceptionCode == win32.EXCEPTION_INT_DIVIDE_BY_ZERO:
        result = ('Not likely exploitable', 'DivideByZero', 'This is an integer divide by zero, and is probably not exploitable.')
    elif self.exceptionCode == win32.EXCEPTION_FLT_DIVIDE_BY_ZERO:
        result = ('Not likely exploitable', 'DivideByZero', 'This is a floating point divide by zero, and is probably not exploitable.')
    elif self.exceptionCode in (win32.EXCEPTION_BREAKPOINT, win32.STATUS_WX86_BREAKPOINT):
        result = ('Unknown', 'Breakpoint', 'While a breakpoint itself is probably not exploitable, it may also be an indication that an attacker is testing a target. In either case breakpoints should not exist in production code.')
    return result