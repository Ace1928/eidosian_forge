from itertools import product
import numpy as np
import random
import functools
import pytest
from numpy.testing import (assert_, assert_equal, assert_allclose,
from pytest import raises as assert_raises
import scipy.stats as stats
from scipy.stats import distributions
from scipy.stats._hypotests import (epps_singleton_2samp, cramervonmises,
from scipy.stats._mannwhitneyu import mannwhitneyu, _mwu_state
from .common_tests import check_named_results
from scipy._lib._testutils import _TestPythranFunc
class TestBarnardExact:
    """Some tests to show that barnard_exact() works correctly."""

    @pytest.mark.parametrize('input_sample,expected', [([[43, 40], [10, 39]], (3.555406779643, 0.000362832367)), ([[100, 2], [1000, 5]], (-1.776382925679, 0.135126970878)), ([[2, 7], [8, 2]], (-2.518474945157, 0.01921081543)), ([[5, 1], [10, 10]], (1.449486150679, 0.156277546306)), ([[5, 15], [20, 20]], (-1.851640199545, 0.066363501421)), ([[5, 16], [20, 25]], (-1.609639949352, 0.116984852192)), ([[10, 5], [10, 1]], (-1.449486150679, 0.177536588915)), ([[5, 0], [1, 4]], (2.581988897472, 0.013671875)), ([[0, 1], [3, 2]], (-1.09544511501, 0.509667991877)), ([[0, 2], [6, 4]], (-1.549193338483, 0.197019618792)), ([[2, 7], [8, 2]], (-2.518474945157, 0.01921081543))])
    def test_precise(self, input_sample, expected):
        """The expected values have been generated by R, using a resolution
        for the nuisance parameter of 1e-6 :
        ```R
        library(Barnard)
        options(digits=10)
        barnard.test(43, 40, 10, 39, dp=1e-6, pooled=TRUE)
        ```
        """
        res = barnard_exact(input_sample)
        statistic, pvalue = (res.statistic, res.pvalue)
        assert_allclose([statistic, pvalue], expected)

    @pytest.mark.parametrize('input_sample,expected', [([[43, 40], [10, 39]], (3.920362887717, 0.000289470662)), ([[100, 2], [1000, 5]], (-1.139432816087, 0.950272080594)), ([[2, 7], [8, 2]], (-3.079373904042, 0.020172119141)), ([[5, 1], [10, 10]], (1.622375939458, 0.150599922226)), ([[5, 15], [20, 20]], (-1.974771239528, 0.063038448651)), ([[5, 16], [20, 25]], (-1.722122973346, 0.133329494287)), ([[10, 5], [10, 1]], (-1.765469659009, 0.250566655215)), ([[5, 0], [1, 4]], (5.477225575052, 0.0078125)), ([[0, 1], [3, 2]], (-1.224744871392, 0.509667991877)), ([[0, 2], [6, 4]], (-1.732050807569, 0.197019618792)), ([[2, 7], [8, 2]], (-3.079373904042, 0.020172119141))])
    def test_pooled_param(self, input_sample, expected):
        """The expected values have been generated by R, using a resolution
        for the nuisance parameter of 1e-6 :
        ```R
        library(Barnard)
        options(digits=10)
        barnard.test(43, 40, 10, 39, dp=1e-6, pooled=FALSE)
        ```
        """
        res = barnard_exact(input_sample, pooled=False)
        statistic, pvalue = (res.statistic, res.pvalue)
        assert_allclose([statistic, pvalue], expected)

    def test_raises(self):
        error_msg = 'Number of points `n` must be strictly positive, found 0'
        with assert_raises(ValueError, match=error_msg):
            barnard_exact([[1, 2], [3, 4]], n=0)
        error_msg = 'The input `table` must be of shape \\(2, 2\\).'
        with assert_raises(ValueError, match=error_msg):
            barnard_exact(np.arange(6).reshape(2, 3))
        error_msg = 'All values in `table` must be nonnegative.'
        with assert_raises(ValueError, match=error_msg):
            barnard_exact([[-1, 2], [3, 4]])
        error_msg = "`alternative` should be one of {'two-sided', 'less', 'greater'}, found .*"
        with assert_raises(ValueError, match=error_msg):
            barnard_exact([[1, 2], [3, 4]], 'not-correct')

    @pytest.mark.parametrize('input_sample,expected', [([[0, 0], [4, 3]], (1.0, 0))])
    def test_edge_cases(self, input_sample, expected):
        res = barnard_exact(input_sample)
        statistic, pvalue = (res.statistic, res.pvalue)
        assert_equal(pvalue, expected[0])
        assert_equal(statistic, expected[1])

    @pytest.mark.parametrize('input_sample,expected', [([[0, 5], [0, 10]], (1.0, np.nan)), ([[5, 0], [10, 0]], (1.0, np.nan))])
    def test_row_or_col_zero(self, input_sample, expected):
        res = barnard_exact(input_sample)
        statistic, pvalue = (res.statistic, res.pvalue)
        assert_equal(pvalue, expected[0])
        assert_equal(statistic, expected[1])

    @pytest.mark.parametrize('input_sample,expected', [([[2, 7], [8, 2]], (-2.518474945157, 0.009886140845)), ([[7, 200], [300, 8]], (-21.32003669846, 0.0)), ([[21, 28], [1957, 6]], (-30.489638143953, 0.0))])
    @pytest.mark.parametrize('alternative', ['greater', 'less'])
    def test_less_greater(self, input_sample, expected, alternative):
        """
        "The expected values have been generated by R, using a resolution
        for the nuisance parameter of 1e-6 :
        ```R
        library(Barnard)
        options(digits=10)
        a = barnard.test(2, 7, 8, 2, dp=1e-6, pooled=TRUE)
        a$p.value[1]
        ```
        In this test, we are using the "one-sided" return value `a$p.value[1]`
        to test our pvalue.
        """
        expected_stat, less_pvalue_expect = expected
        if alternative == 'greater':
            input_sample = np.array(input_sample)[:, ::-1]
            expected_stat = -expected_stat
        res = barnard_exact(input_sample, alternative=alternative)
        statistic, pvalue = (res.statistic, res.pvalue)
        assert_allclose([statistic, pvalue], [expected_stat, less_pvalue_expect], atol=1e-07)