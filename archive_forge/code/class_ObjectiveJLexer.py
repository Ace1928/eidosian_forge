import re
from pygments.lexer import RegexLexer, include, bygroups, default, using, \
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
from pygments.util import get_bool_opt, iteritems
import pygments.unistring as uni
class ObjectiveJLexer(RegexLexer):
    """
    For Objective-J source code with preprocessor directives.

    .. versionadded:: 1.3
    """
    name = 'Objective-J'
    aliases = ['objective-j', 'objectivej', 'obj-j', 'objj']
    filenames = ['*.j']
    mimetypes = ['text/x-objective-j']
    _ws = '(?:\\s|//.*?\\n|/[*].*?[*]/)*'
    flags = re.DOTALL | re.MULTILINE
    tokens = {'root': [include('whitespace'), ('^(' + _ws + '[+-]' + _ws + ')([(a-zA-Z_].*?[^(])(' + _ws + '\\{)', bygroups(using(this), using(this, state='function_signature'), using(this))), ('(@interface|@implementation)(\\s+)', bygroups(Keyword, Text), 'classname'), ('(@class|@protocol)(\\s*)', bygroups(Keyword, Text), 'forward_classname'), ('(\\s*)(@end)(\\s*)', bygroups(Text, Keyword, Text)), include('statements'), ('[{()}]', Punctuation), (';', Punctuation)], 'whitespace': [('(@import)(\\s+)("(?:\\\\\\\\|\\\\"|[^"])*")', bygroups(Comment.Preproc, Text, String.Double)), ('(@import)(\\s+)(<(?:\\\\\\\\|\\\\>|[^>])*>)', bygroups(Comment.Preproc, Text, String.Double)), ('(#(?:include|import))(\\s+)("(?:\\\\\\\\|\\\\"|[^"])*")', bygroups(Comment.Preproc, Text, String.Double)), ('(#(?:include|import))(\\s+)(<(?:\\\\\\\\|\\\\>|[^>])*>)', bygroups(Comment.Preproc, Text, String.Double)), ('#if\\s+0', Comment.Preproc, 'if0'), ('#', Comment.Preproc, 'macro'), ('\\n', Text), ('\\s+', Text), ('\\\\\\n', Text), ('//(\\n|(.|\\n)*?[^\\\\]\\n)', Comment.Single), ('/(\\\\\\n)?[*](.|\\n)*?[*](\\\\\\n)?/', Comment.Multiline), ('<!--', Comment)], 'slashstartsregex': [include('whitespace'), ('/(\\\\.|[^[/\\\\\\n]|\\[(\\\\.|[^\\]\\\\\\n])*])+/([gim]+\\b|\\B)', String.Regex, '#pop'), ('(?=/)', Text, ('#pop', 'badregex')), default('#pop')], 'badregex': [('\\n', Text, '#pop')], 'statements': [('(L|@)?"', String, 'string'), ("(L|@)?'(\\\\.|\\\\[0-7]{1,3}|\\\\x[a-fA-F0-9]{1,2}|[^\\\\\\'\\n])'", String.Char), ('"(\\\\\\\\|\\\\"|[^"])*"', String.Double), ("'(\\\\\\\\|\\\\'|[^'])*'", String.Single), ('(\\d+\\.\\d*|\\.\\d+|\\d+)[eE][+-]?\\d+[lL]?', Number.Float), ('(\\d+\\.\\d*|\\.\\d+|\\d+[fF])[fF]?', Number.Float), ('0x[0-9a-fA-F]+[Ll]?', Number.Hex), ('0[0-7]+[Ll]?', Number.Oct), ('\\d+[Ll]?', Number.Integer), ('^(?=\\s|/|<!--)', Text, 'slashstartsregex'), ('\\+\\+|--|~|&&|\\?|:|\\|\\||\\\\(?=\\n)|(<<|>>>?|==?|!=?|[-<>+*%&|^/])=?', Operator, 'slashstartsregex'), ('[{(\\[;,]', Punctuation, 'slashstartsregex'), ('[})\\].]', Punctuation), ('(for|in|while|do|break|return|continue|switch|case|default|if|else|throw|try|catch|finally|new|delete|typeof|instanceof|void|prototype|__proto__)\\b', Keyword, 'slashstartsregex'), ('(var|with|function)\\b', Keyword.Declaration, 'slashstartsregex'), ('(@selector|@private|@protected|@public|@encode|@synchronized|@try|@throw|@catch|@finally|@end|@property|@synthesize|@dynamic|@for|@accessors|new)\\b', Keyword), ('(int|long|float|short|double|char|unsigned|signed|void|id|BOOL|bool|boolean|IBOutlet|IBAction|SEL|@outlet|@action)\\b', Keyword.Type), ('(self|super)\\b', Name.Builtin), ('(TRUE|YES|FALSE|NO|Nil|nil|NULL)\\b', Keyword.Constant), ('(true|false|null|NaN|Infinity|undefined)\\b', Keyword.Constant), ('(ABS|ASIN|ACOS|ATAN|ATAN2|SIN|COS|TAN|EXP|POW|CEIL|FLOOR|ROUND|MIN|MAX|RAND|SQRT|E|LN2|LN10|LOG2E|LOG10E|PI|PI2|PI_2|SQRT1_2|SQRT2)\\b', Keyword.Constant), ('(Array|Boolean|Date|Error|Function|Math|netscape|Number|Object|Packages|RegExp|String|sun|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|Error|eval|isFinite|isNaN|parseFloat|parseInt|document|this|window)\\b', Name.Builtin), ('([$a-zA-Z_]\\w*)(' + _ws + ')(?=\\()', bygroups(Name.Function, using(this))), ('[$a-zA-Z_]\\w*', Name)], 'classname': [('([a-zA-Z_]\\w*)(' + _ws + ':' + _ws + ')([a-zA-Z_]\\w*)?', bygroups(Name.Class, using(this), Name.Class), '#pop'), ('([a-zA-Z_]\\w*)(' + _ws + '\\()([a-zA-Z_]\\w*)(\\))', bygroups(Name.Class, using(this), Name.Label, Text), '#pop'), ('([a-zA-Z_]\\w*)', Name.Class, '#pop')], 'forward_classname': [('([a-zA-Z_]\\w*)(\\s*,\\s*)', bygroups(Name.Class, Text), '#push'), ('([a-zA-Z_]\\w*)(\\s*;?)', bygroups(Name.Class, Text), '#pop')], 'function_signature': [include('whitespace'), ('(\\(' + _ws + ')([a-zA-Z_]\\w+)(' + _ws + '\\)' + _ws + ')([$a-zA-Z_]\\w+' + _ws + ':)', bygroups(using(this), Keyword.Type, using(this), Name.Function), 'function_parameters'), ('(\\(' + _ws + ')([a-zA-Z_]\\w+)(' + _ws + '\\)' + _ws + ')([$a-zA-Z_]\\w+)', bygroups(using(this), Keyword.Type, using(this), Name.Function), '#pop'), ('([$a-zA-Z_]\\w+' + _ws + ':)', bygroups(Name.Function), 'function_parameters'), ('([$a-zA-Z_]\\w+)', bygroups(Name.Function), '#pop'), default('#pop')], 'function_parameters': [include('whitespace'), ('(\\(' + _ws + ')([^)]+)(' + _ws + '\\)' + _ws + ')([$a-zA-Z_]\\w+)', bygroups(using(this), Keyword.Type, using(this), Text)), ('([$a-zA-Z_]\\w+' + _ws + ':)', Name.Function), ('(:)', Name.Function), ('(,' + _ws + '\\.\\.\\.)', using(this)), ('([$a-zA-Z_]\\w+)', Text)], 'expression': [('([$a-zA-Z_]\\w*)(\\()', bygroups(Name.Function, Punctuation)), ('(\\))', Punctuation, '#pop')], 'string': [('"', String, '#pop'), ('\\\\([\\\\abfnrtv"\\\']|x[a-fA-F0-9]{2,4}|[0-7]{1,3})', String.Escape), ('[^\\\\"\\n]+', String), ('\\\\\\n', String), ('\\\\', String)], 'macro': [('[^/\\n]+', Comment.Preproc), ('/[*](.|\\n)*?[*]/', Comment.Multiline), ('//.*?\\n', Comment.Single, '#pop'), ('/', Comment.Preproc), ('(?<=\\\\)\\n', Comment.Preproc), ('\\n', Comment.Preproc, '#pop')], 'if0': [('^\\s*#if.*?(?<!\\\\)\\n', Comment.Preproc, '#push'), ('^\\s*#endif.*?(?<!\\\\)\\n', Comment.Preproc, '#pop'), ('.*?\\n', Comment)]}

    def analyse_text(text):
        if re.search('^\\s*@import\\s+[<"]', text, re.MULTILINE):
            return True
        return False