from __future__ import absolute_import, division, print_function
import os
import platform
import pwd
import re
import sys
import tempfile
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.common.text.converters import to_bytes, to_native
from ansible.module_utils.six.moves import shlex_quote
class CronTab(object):
    """
        CronTab object to write time based crontab file

        user      - the user of the crontab (defaults to current user)
        cron_file - a cron file under /etc/cron.d, or an absolute path
    """

    def __init__(self, module, user=None, cron_file=None):
        self.module = module
        self.user = user
        self.root = os.getuid() == 0
        self.lines = None
        self.ansible = '#Ansible: '
        self.n_existing = ''
        self.cron_cmd = self.module.get_bin_path('crontab', required=True)
        if cron_file:
            if os.path.isabs(cron_file):
                self.cron_file = cron_file
                self.b_cron_file = to_bytes(cron_file, errors='surrogate_or_strict')
            else:
                self.cron_file = os.path.join('/etc/cron.d', cron_file)
                self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict'))
        else:
            self.cron_file = None
        self.read()

    def read(self):
        self.lines = []
        if self.cron_file:
            try:
                f = open(self.b_cron_file, 'rb')
                self.n_existing = to_native(f.read(), errors='surrogate_or_strict')
                self.lines = self.n_existing.splitlines()
                f.close()
            except IOError:
                return
            except Exception:
                raise CronTabError('Unexpected error:', sys.exc_info()[0])
        else:
            rc, out, err = self.module.run_command(self._read_user_execute(), use_unsafe_shell=True)
            if rc != 0 and rc != 1:
                raise CronTabError('Unable to read crontab')
            self.n_existing = out
            lines = out.splitlines()
            count = 0
            for l in lines:
                if count > 2 or (not re.match('# DO NOT EDIT THIS FILE - edit the master and reinstall.', l) and (not re.match('# \\(/tmp/.*installed on.*\\)', l)) and (not re.match('# \\(.*version.*\\)', l))):
                    self.lines.append(l)
                else:
                    pattern = re.escape(l) + '[\r\n]?'
                    self.n_existing = re.sub(pattern, '', self.n_existing, 1)
                count += 1

    def is_empty(self):
        if len(self.lines) == 0:
            return True
        else:
            for line in self.lines:
                if line.strip():
                    return False
            return True

    def write(self, backup_file=None):
        """
        Write the crontab to the system. Saves all information.
        """
        if backup_file:
            fileh = open(backup_file, 'wb')
        elif self.cron_file:
            fileh = open(self.b_cron_file, 'wb')
        else:
            filed, path = tempfile.mkstemp(prefix='crontab')
            os.chmod(path, int('0644', 8))
            fileh = os.fdopen(filed, 'wb')
        fileh.write(to_bytes(self.render()))
        fileh.close()
        if backup_file:
            return
        if not self.cron_file:
            rc, out, err = self.module.run_command(self._write_execute(path), use_unsafe_shell=True)
            os.unlink(path)
            if rc != 0:
                self.module.fail_json(msg=err)
        if self.module.selinux_enabled() and self.cron_file:
            self.module.set_default_selinux_context(self.cron_file, False)

    def do_comment(self, name):
        return '%s%s' % (self.ansible, name)

    def add_job(self, name, job):
        self.lines.append(self.do_comment(name))
        self.lines.append('%s' % job)

    def update_job(self, name, job):
        return self._update_job(name, job, self.do_add_job)

    def do_add_job(self, lines, comment, job):
        lines.append(comment)
        lines.append('%s' % job)

    def remove_job(self, name):
        return self._update_job(name, '', self.do_remove_job)

    def do_remove_job(self, lines, comment, job):
        return None

    def add_env(self, decl, insertafter=None, insertbefore=None):
        if not (insertafter or insertbefore):
            self.lines.insert(0, decl)
            return
        if insertafter:
            other_name = insertafter
        elif insertbefore:
            other_name = insertbefore
        other_decl = self.find_env(other_name)
        if len(other_decl) > 0:
            if insertafter:
                index = other_decl[0] + 1
            elif insertbefore:
                index = other_decl[0]
            self.lines.insert(index, decl)
            return
        self.module.fail_json(msg="Variable named '%s' not found." % other_name)

    def update_env(self, name, decl):
        return self._update_env(name, decl, self.do_add_env)

    def do_add_env(self, lines, decl):
        lines.append(decl)

    def remove_env(self, name):
        return self._update_env(name, '', self.do_remove_env)

    def do_remove_env(self, lines, decl):
        return None

    def remove_job_file(self):
        try:
            os.unlink(self.cron_file)
            return True
        except OSError:
            return False
        except Exception:
            raise CronTabError('Unexpected error:', sys.exc_info()[0])

    def find_job(self, name, job=None):
        comment = None
        for l in self.lines:
            if comment is not None:
                if comment == name:
                    return [comment, l]
                else:
                    comment = None
            elif re.match('%s' % self.ansible, l):
                comment = re.sub('%s' % self.ansible, '', l)
        if job:
            for i, l in enumerate(self.lines):
                if l == job:
                    if not re.match('%s' % self.ansible, self.lines[i - 1]):
                        self.lines.insert(i, self.do_comment(name))
                        return [self.lines[i], l, True]
                    elif name and self.lines[i - 1] == self.do_comment(None):
                        self.lines[i - 1] = self.do_comment(name)
                        return [self.lines[i - 1], l, True]
        return []

    def find_env(self, name):
        for index, l in enumerate(self.lines):
            if re.match('^%s=' % name, l):
                return [index, l]
        return []

    def get_cron_job(self, minute, hour, day, month, weekday, job, special, disabled):
        job = job.strip('\r\n')
        if disabled:
            disable_prefix = '#'
        else:
            disable_prefix = ''
        if special:
            if self.cron_file:
                return '%s@%s %s %s' % (disable_prefix, special, self.user, job)
            else:
                return '%s@%s %s' % (disable_prefix, special, job)
        elif self.cron_file:
            return '%s%s %s %s %s %s %s %s' % (disable_prefix, minute, hour, day, month, weekday, self.user, job)
        else:
            return '%s%s %s %s %s %s %s' % (disable_prefix, minute, hour, day, month, weekday, job)

    def get_jobnames(self):
        jobnames = []
        for l in self.lines:
            if re.match('%s' % self.ansible, l):
                jobnames.append(re.sub('%s' % self.ansible, '', l))
        return jobnames

    def get_envnames(self):
        envnames = []
        for l in self.lines:
            if re.match('^\\S+=', l):
                envnames.append(l.split('=')[0])
        return envnames

    def _update_job(self, name, job, addlinesfunction):
        ansiblename = self.do_comment(name)
        newlines = []
        comment = None
        for l in self.lines:
            if comment is not None:
                addlinesfunction(newlines, comment, job)
                comment = None
            elif l == ansiblename:
                comment = l
            else:
                newlines.append(l)
        self.lines = newlines
        if len(newlines) == 0:
            return True
        else:
            return False

    def _update_env(self, name, decl, addenvfunction):
        newlines = []
        for l in self.lines:
            if re.match('^%s=' % name, l):
                addenvfunction(newlines, decl)
            else:
                newlines.append(l)
        self.lines = newlines

    def render(self):
        """
        Render this crontab as it would be in the crontab.
        """
        crons = []
        for cron in self.lines:
            crons.append(cron)
        result = '\n'.join(crons)
        if result:
            result = result.rstrip('\r\n') + '\n'
        return result

    def _read_user_execute(self):
        """
        Returns the command line for reading a crontab
        """
        user = ''
        if self.user:
            if platform.system() == 'SunOS':
                return "su %s -c '%s -l'" % (shlex_quote(self.user), shlex_quote(self.cron_cmd))
            elif platform.system() == 'AIX':
                return '%s -l %s' % (shlex_quote(self.cron_cmd), shlex_quote(self.user))
            elif platform.system() == 'HP-UX':
                return '%s %s %s' % (self.cron_cmd, '-l', shlex_quote(self.user))
            elif pwd.getpwuid(os.getuid())[0] != self.user:
                user = '-u %s' % shlex_quote(self.user)
        return '%s %s %s' % (self.cron_cmd, user, '-l')

    def _write_execute(self, path):
        """
        Return the command line for writing a crontab
        """
        user = ''
        if self.user:
            if platform.system() in ['SunOS', 'HP-UX', 'AIX']:
                return "chown %s %s ; su '%s' -c '%s %s'" % (shlex_quote(self.user), shlex_quote(path), shlex_quote(self.user), self.cron_cmd, shlex_quote(path))
            elif pwd.getpwuid(os.getuid())[0] != self.user:
                user = '-u %s' % shlex_quote(self.user)
        return '%s %s %s' % (self.cron_cmd, user, shlex_quote(path))