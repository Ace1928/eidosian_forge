import collections.abc
import configparser
import enum
import getpass
import json
import logging
import multiprocessing
import os
import platform
import re
import shutil
import socket
import sys
import tempfile
import time
from dataclasses import dataclass
from datetime import datetime
from distutils.util import strtobool
from functools import reduce
from typing import (
from urllib.parse import quote, unquote, urlencode, urlparse, urlsplit
from google.protobuf.wrappers_pb2 import BoolValue, DoubleValue, Int32Value, StringValue
import wandb
import wandb.env
from wandb import util
from wandb.apis.internal import Api
from wandb.errors import UsageError
from wandb.proto import wandb_settings_pb2
from wandb.sdk.internal.system.env_probe_helpers import is_aws_lambda
from wandb.sdk.lib import filesystem
from wandb.sdk.lib._settings_toposort_generated import SETTINGS_TOPOLOGICALLY_SORTED
from wandb.sdk.wandb_setup import _EarlyLogger
from .lib import apikey
from .lib.gitlib import GitRepo
from .lib.ipython import _get_python_type
from .lib.runid import generate_id
def _default_props(self) -> Dict[str, Dict[str, Any]]:
    """Initialize instance attributes (individual settings) as Property objects.

        Helper method that is used in `__init__` together with the class attributes.
        Note that key names must be the same as the class attribute names.
        """
    props: Dict[str, Dict[str, Any]] = dict(_async_upload_concurrency_limit={'preprocessor': int, 'validator': self._validate__async_upload_concurrency_limit}, _aws_lambda={'hook': lambda _: is_aws_lambda(), 'auto_hook': True}, _code_path_local={'hook': lambda _: _get_program_relpath(self.program), 'auto_hook': True}, _colab={'hook': lambda _: 'google.colab' in sys.modules, 'auto_hook': True}, _disable_machine_info={'value': False, 'preprocessor': _str_as_bool}, _disable_meta={'value': False, 'preprocessor': _str_as_bool, 'hook': lambda x: self._disable_machine_info or x}, _disable_service={'value': False, 'preprocessor': _str_as_bool, 'is_policy': True}, _disable_setproctitle={'value': False, 'preprocessor': _str_as_bool}, _disable_stats={'value': False, 'preprocessor': _str_as_bool, 'hook': lambda x: self._disable_machine_info or x}, _disable_viewer={'preprocessor': _str_as_bool}, _extra_http_headers={'preprocessor': _str_as_json}, _file_stream_retry_max={'value': 125, 'preprocessor': int}, _file_stream_retry_wait_min_seconds={'value': 2, 'preprocessor': float}, _file_stream_retry_wait_max_seconds={'value': 60, 'preprocessor': float}, _file_stream_timeout_seconds={'value': 180, 'preprocessor': float}, _file_transfer_retry_max={'value': 20, 'preprocessor': int}, _file_transfer_retry_wait_min_seconds={'value': 2, 'preprocessor': float}, _file_transfer_retry_wait_max_seconds={'value': 60, 'preprocessor': float}, _file_transfer_timeout_seconds={'value': 0, 'preprocessor': float}, _flow_control_disabled={'hook': lambda _: self._network_buffer == 0, 'auto_hook': True}, _flow_control_custom={'hook': lambda _: bool(self._network_buffer), 'auto_hook': True}, _graphql_retry_max={'value': 20, 'preprocessor': int}, _graphql_retry_wait_min_seconds={'value': 2, 'preprocessor': float}, _graphql_retry_wait_max_seconds={'value': 60, 'preprocessor': float}, _graphql_timeout_seconds={'value': 30.0, 'preprocessor': float}, _internal_check_process={'value': 8, 'preprocessor': float}, _internal_queue_timeout={'value': 2, 'preprocessor': float}, _ipython={'hook': lambda _: _get_python_type() == 'ipython', 'auto_hook': True}, _jupyter={'hook': lambda _: _get_python_type() == 'jupyter', 'auto_hook': True}, _kaggle={'hook': lambda _: util._is_likely_kaggle(), 'auto_hook': True}, _log_level={'value': logging.DEBUG}, _network_buffer={'preprocessor': int}, _noop={'hook': lambda _: self.mode == 'disabled', 'auto_hook': True}, _notebook={'hook': lambda _: self._ipython or self._jupyter or self._colab or self._kaggle, 'auto_hook': True}, _offline={'hook': lambda _: True if self.disabled or self.mode in ('dryrun', 'offline') else False, 'auto_hook': True}, _platform={'value': util.get_platform_name()}, _proxies={'preprocessor': _str_as_json}, _require_core={'value': False, 'preprocessor': _str_as_bool}, _save_requirements={'value': True, 'preprocessor': _str_as_bool}, _service_wait={'value': 30, 'preprocessor': float, 'validator': self._validate__service_wait}, _shared={'hook': lambda _: self.mode == 'shared', 'auto_hook': True}, _start_datetime={'preprocessor': _datetime_as_str}, _stats_sample_rate_seconds={'value': 2.0, 'preprocessor': float, 'validator': self._validate__stats_sample_rate_seconds}, _stats_samples_to_average={'value': 15, 'preprocessor': int, 'validator': self._validate__stats_samples_to_average}, _stats_join_assets={'value': True, 'preprocessor': _str_as_bool}, _stats_neuron_monitor_config_path={'hook': lambda x: self._path_convert(x)}, _stats_open_metrics_endpoints={'preprocessor': _str_as_json}, _stats_open_metrics_filters={'value': ('.*',), 'preprocessor': _str_as_json}, _stats_disk_paths={'value': ('/',), 'preprocessor': _str_as_json}, _stats_buffer_size={'value': 0, 'preprocessor': int}, _sync={'value': False}, _tmp_code_dir={'value': 'code', 'hook': lambda x: self._path_convert(self.tmp_dir, x)}, _windows={'hook': lambda _: platform.system() == 'Windows', 'auto_hook': True}, anonymous={'validator': self._validate_anonymous}, api_key={'validator': self._validate_api_key}, base_url={'value': 'https://api.wandb.ai', 'preprocessor': lambda x: str(x).strip().rstrip('/'), 'validator': self._validate_base_url}, colab_url={'hook': lambda _: self._get_colab_url(), 'auto_hook': True}, config_paths={'preprocessor': _str_as_tuple}, console={'value': 'auto', 'validator': self._validate_console, 'hook': lambda x: self._convert_console(x), 'auto_hook': True}, deployment={'hook': lambda _: 'local' if self.is_local else 'cloud', 'auto_hook': True}, disable_code={'value': False, 'preprocessor': _str_as_bool, 'hook': lambda x: self._disable_machine_info or x}, disable_hints={'preprocessor': _str_as_bool}, disable_git={'value': False, 'preprocessor': _str_as_bool, 'hook': lambda x: self._disable_machine_info or x}, disable_job_creation={'value': False, 'preprocessor': _str_as_bool, 'hook': lambda x: self._disable_machine_info or x}, disabled={'value': False, 'preprocessor': _str_as_bool}, files_dir={'value': 'files', 'hook': lambda x: self._path_convert(self.wandb_dir, f'{self.run_mode}-{self.timespec}-{self.run_id}', x)}, force={'preprocessor': _str_as_bool}, git_remote={'value': 'origin'}, heartbeat_seconds={'value': 30}, ignore_globs={'value': tuple(), 'preprocessor': lambda x: tuple(x) if not isinstance(x, tuple) else x}, init_timeout={'value': 90, 'preprocessor': lambda x: float(x)}, is_local={'hook': lambda _: self.base_url != 'https://api.wandb.ai' if self.base_url is not None else False, 'auto_hook': True}, job_name={'preprocessor': str}, job_source={'validator': self._validate_job_source}, label_disable={'preprocessor': _str_as_bool}, launch={'preprocessor': _str_as_bool}, log_dir={'value': 'logs', 'hook': lambda x: self._path_convert(self.wandb_dir, f'{self.run_mode}-{self.timespec}-{self.run_id}', x)}, log_internal={'value': 'debug-internal.log', 'hook': lambda x: self._path_convert(self.log_dir, x)}, log_symlink_internal={'value': 'debug-internal.log', 'hook': lambda x: self._path_convert(self.wandb_dir, x)}, log_symlink_user={'value': 'debug.log', 'hook': lambda x: self._path_convert(self.wandb_dir, x)}, log_user={'value': 'debug.log', 'hook': lambda x: self._path_convert(self.log_dir, x)}, login_timeout={'preprocessor': lambda x: float(x)}, mode={'value': 'online', 'validator': self._validate_mode}, problem={'value': 'fatal', 'validator': self._validate_problem}, program={'hook': lambda x: self._get_program(x)}, project={'validator': self._validate_project}, project_url={'hook': lambda _: self._project_url(), 'auto_hook': True}, quiet={'preprocessor': _str_as_bool}, reinit={'preprocessor': _str_as_bool}, relogin={'preprocessor': _str_as_bool}, resume={'preprocessor': lambda x: None if x is False else x}, resume_fname={'value': 'wandb-resume.json', 'hook': lambda x: self._path_convert(self.wandb_dir, x)}, resumed={'value': 'False', 'preprocessor': _str_as_bool}, root_dir={'preprocessor': lambda x: str(x), 'value': os.path.abspath(os.getcwd())}, run_id={'validator': self._validate_run_id}, run_mode={'hook': lambda _: 'offline-run' if self._offline else 'run', 'auto_hook': True}, run_tags={'preprocessor': lambda x: tuple(x) if not isinstance(x, tuple) else x}, run_url={'hook': lambda _: self._run_url(), 'auto_hook': True}, sagemaker_disable={'preprocessor': _str_as_bool}, save_code={'preprocessor': _str_as_bool}, settings_system={'value': os.path.join('~', '.config', 'wandb', 'settings'), 'hook': lambda x: self._path_convert(x)}, settings_workspace={'value': 'settings', 'hook': lambda x: self._path_convert(self.wandb_dir, x)}, show_colors={'preprocessor': _str_as_bool}, show_emoji={'preprocessor': _str_as_bool}, show_errors={'value': 'True', 'preprocessor': _str_as_bool}, show_info={'value': 'True', 'preprocessor': _str_as_bool}, show_warnings={'value': 'True', 'preprocessor': _str_as_bool}, silent={'value': 'False', 'preprocessor': _str_as_bool}, start_method={'validator': self._validate_start_method}, strict={'preprocessor': _str_as_bool}, summary_timeout={'value': 60, 'preprocessor': lambda x: int(x)}, summary_warnings={'value': 5, 'preprocessor': lambda x: int(x), 'is_policy': True}, sweep_url={'hook': lambda _: self._sweep_url(), 'auto_hook': True}, symlink={'preprocessor': _str_as_bool}, sync_dir={'hook': [lambda _: self._path_convert(self.wandb_dir, f'{self.run_mode}-{self.timespec}-{self.run_id}')], 'auto_hook': True}, sync_file={'hook': lambda _: self._path_convert(self.sync_dir, f'run-{self.run_id}.wandb'), 'auto_hook': True}, sync_symlink_latest={'value': 'latest-run', 'hook': lambda x: self._path_convert(self.wandb_dir, x)}, system_sample={'value': 15}, system_sample_seconds={'value': 2}, table_raise_on_max_row_limit_exceeded={'value': False, 'preprocessor': _str_as_bool}, timespec={'hook': lambda _: self._start_datetime, 'auto_hook': True}, tmp_dir={'value': 'tmp', 'hook': lambda x: self._path_convert(self.wandb_dir, f'{self.run_mode}-{self.timespec}-{self.run_id}', x) or tempfile.gettempdir()}, wandb_dir={'hook': lambda _: _get_wandb_dir(self.root_dir or ''), 'auto_hook': True})
    return props