import collections
import enum
import weakref
import astunparse
import gast
from tensorflow.python.autograph.pyct import anno
class GraphBuilder(object):
    """Builder that constructs a CFG from a given AST.

  This GraphBuilder facilitates constructing the DAG that forms the CFG when
  nodes
  are supplied in lexical order (i.e., top-down, depth first). Under these
  conditions, it supports building patterns found in typical structured
  programs.

  This builder ignores the flow generated by exceptions, which are assumed to
  always be catastrophic and present purely for diagnostic purposes (e.g. to
  print debug information). Statements like raise and try/catch sections are
  allowed and will generate control flow edges, but ordinary statements are
  assumed not to raise exceptions.

  Finally sections are also correctly interleaved between break/continue/return
  nodes and their subsequent statements.

  Important concepts:
   * nodes - nodes refer to CFG nodes; AST nodes are qualified explicitly
   * leaf set - since the graph is constructed gradually, a leaf set maintains
     the CFG nodes that will precede the node that the builder expects to
     receive next; when an ordinary node is added, it is connected to the
     existing leaves and it in turn becomes the new leaf
   * jump nodes - nodes that should generate edges other than what
     ordinary nodes would; these correspond to break, continue and return
     statements
   * sections - logical delimiters for subgraphs that require special
     edges; there are various types of nodes, each admitting various
     types of jump nodes; sections are identified by their corresponding AST
     node
  """

    def __init__(self, parent_ast_node):
        self.reset()
        self.parent = parent_ast_node

    def reset(self):
        """Resets the state of this factory."""
        self.head = None
        self.errors = set()
        self.node_index = {}
        self.leaves = set()
        self.active_stmts = set()
        self.owners = {}
        self.forward_edges = set()
        self.finally_sections = {}
        self.finally_section_subgraphs = {}
        self.finally_section_has_direct_flow = {}
        self.pending_finally_sections = set()
        self.exits = {}
        self.section_entry = {}
        self.continues = {}
        self.raises = {}
        self.cond_entry = {}
        self.cond_leaves = {}

    def _connect_nodes(self, first, second):
        """Connects nodes to signify that control flows from first to second.

    Args:
      first: Union[Set[Node, ...], Node]
      second: Node
    """
        if isinstance(first, Node):
            first.next.add(second)
            second.prev.add(first)
            self.forward_edges.add((first, second))
        else:
            for node in first:
                self._connect_nodes(node, second)

    def _add_new_node(self, ast_node):
        """Grows the graph by adding a CFG node following the current leaves."""
        if ast_node in self.node_index:
            raise ValueError('%s added twice' % ast_node)
        node = Node(next_=set(), prev=weakref.WeakSet(), ast_node=ast_node)
        self.node_index[ast_node] = node
        self.owners[node] = frozenset(self.active_stmts)
        if self.head is None:
            self.head = node
        for leaf in self.leaves:
            self._connect_nodes(leaf, node)
        for section_id in self.pending_finally_sections:
            self.finally_section_subgraphs[section_id][0] = node
        self.pending_finally_sections = set()
        return node

    def begin_statement(self, stmt):
        """Marks the beginning of a statement.

    Args:
      stmt: Hashable, a key by which the statement can be identified in the
        CFG's stmt_prev and stmt_next attributes
    """
        self.active_stmts.add(stmt)

    def end_statement(self, stmt):
        """Marks the end of a statement.

    Args:
      stmt: Hashable, a key by which the statement can be identified in the
        CFG's stmt_prev and stmt_next attributes; must match a key previously
        passed to begin_statement.
    """
        self.active_stmts.remove(stmt)

    def add_ordinary_node(self, ast_node):
        """Grows the graph by adding an ordinary CFG node.

    Ordinary nodes are followed by the next node, in lexical order, that is,
    they become the new leaf set.

    Args:
      ast_node: ast.AST

    Returns:
      Node
    """
        node = self._add_new_node(ast_node)
        self.leaves = set((node,))
        return node

    def _add_jump_node(self, ast_node, guards):
        """Grows the graph by adding a jump node.

    Jump nodes are added to the current leaf set, and the leaf set becomes
    empty. If the jump node is the last in a cond section, then it may be added
    back to the leaf set by a separate mechanism.

    Args:
      ast_node: ast.AST
      guards: Tuple[ast.AST, ...], the finally sections active for this node

    Returns:
      Node
    """
        node = self._add_new_node(ast_node)
        self.leaves = set()
        self.finally_sections[node] = guards
        return node

    def _connect_jump_to_finally_sections(self, node):
        """Connects a jump node to the finally sections protecting it."""
        cursor = set((node,))
        if node not in self.finally_sections:
            return cursor
        for guard_section_id in self.finally_sections[node]:
            guard_begin, guard_ends = self.finally_section_subgraphs[guard_section_id]
            self._connect_nodes(cursor, guard_begin)
            cursor = guard_ends
        del self.finally_sections[node]
        return cursor

    def add_exit_node(self, ast_node, section_id, guards):
        """Grows the graph by adding an exit node.

    This node becomes an exit for the current section.

    Args:
      ast_node: ast.AST
      section_id: Hashable, the node for which ast_node should be considered to
        be an exit node
      guards: Tuple[ast.AST, ...], the finally sections that guard ast_node

    Returns:
      Node
    """
        node = self._add_jump_node(ast_node, guards)
        self.exits[section_id].add(node)
        return node

    def add_continue_node(self, ast_node, section_id, guards):
        """Grows the graph by adding a reentry node.

    This node causes control flow to go back to the loop section's entry.

    Args:
      ast_node: ast.AST
      section_id: Hashable, the node for which ast_node should be considered to
        be an exit node
      guards: Tuple[ast.AST, ...], the finally sections that guard ast_node
    """
        node = self._add_jump_node(ast_node, guards)
        self.continues[section_id].add(node)

    def connect_raise_node(self, node, except_guards):
        """Adds extra connection between a raise node and containing except guards.

    The node is a graph node, not an ast node.

    Args:
      node: Node
      except_guards: Tuple[ast.AST, ...], the except sections that guard node
    """
        for guard in except_guards:
            if guard in self.raises:
                self.raises[guard].append(node)
            else:
                self.raises[guard] = [node]

    def enter_section(self, section_id):
        """Enters a regular section.

    Regular sections admit exit jumps, which end the section.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        ast_node arg passed to add_exit_node
    """
        assert section_id not in self.exits
        self.exits[section_id] = set()

    def exit_section(self, section_id):
        """Exits a regular section."""
        for exit_ in self.exits[section_id]:
            self.leaves |= self._connect_jump_to_finally_sections(exit_)
        del self.exits[section_id]

    def enter_loop_section(self, section_id, entry_node):
        """Enters a loop section.

    Loop sections define an entry node. The end of the section always flows back
    to the entry node. These admit continue jump nodes which also flow to the
    entry node.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        ast_node arg passed to add_continue_node
      entry_node: ast.AST, the entry node into the loop (e.g. the test node for
        while loops)
    """
        assert section_id not in self.section_entry
        assert section_id not in self.continues
        self.continues[section_id] = set()
        node = self.add_ordinary_node(entry_node)
        self.section_entry[section_id] = node

    def exit_loop_section(self, section_id):
        """Exits a loop section."""
        self._connect_nodes(self.leaves, self.section_entry[section_id])
        for reentry in self.continues[section_id]:
            guard_ends = self._connect_jump_to_finally_sections(reentry)
            self._connect_nodes(guard_ends, self.section_entry[section_id])
        self.leaves = set((self.section_entry[section_id],))
        del self.continues[section_id]
        del self.section_entry[section_id]

    def enter_cond_section(self, section_id):
        """Enters a conditional section.

    Conditional sections define an entry node, and one or more branches.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        section_id arg passed to new_cond_branch
    """
        assert section_id not in self.cond_entry
        assert section_id not in self.cond_leaves
        self.cond_leaves[section_id] = []

    def new_cond_branch(self, section_id):
        """Begins a new branch in a cond section."""
        assert section_id in self.cond_leaves
        if section_id in self.cond_entry:
            self.cond_leaves[section_id].append(self.leaves)
            self.leaves = self.cond_entry[section_id]
        else:
            self.cond_entry[section_id] = self.leaves

    def exit_cond_section(self, section_id):
        """Exits a conditional section."""
        for split in self.cond_leaves[section_id]:
            self.leaves |= split
        del self.cond_entry[section_id]
        del self.cond_leaves[section_id]

    def enter_except_section(self, section_id):
        """Enters an except section."""
        if section_id in self.raises:
            self.leaves.update(self.raises[section_id])

    def enter_finally_section(self, section_id):
        """Enters a finally section."""
        self.finally_section_subgraphs[section_id] = [None, None]
        if self.leaves:
            self.finally_section_has_direct_flow[section_id] = True
        else:
            self.finally_section_has_direct_flow[section_id] = False
        self.pending_finally_sections.add(section_id)

    def exit_finally_section(self, section_id):
        """Exits a finally section."""
        assert section_id not in self.pending_finally_sections, 'Empty finally?'
        self.finally_section_subgraphs[section_id][1] = self.leaves
        if not self.finally_section_has_direct_flow[section_id]:
            self.leaves = set()
        del self.finally_section_has_direct_flow[section_id]

    def build(self):
        """Returns the CFG accumulated so far and resets the builder.

    Returns:
      Graph
    """
        for node in self.node_index.values():
            node.freeze()
        stmt_next = {}
        stmt_prev = {}
        for node in self.node_index.values():
            for stmt in self.owners[node]:
                if stmt not in stmt_prev:
                    stmt_prev[stmt] = set()
                if stmt not in stmt_next:
                    stmt_next[stmt] = set()
        for first, second in self.forward_edges:
            stmts_exited = self.owners[first] - self.owners[second]
            for stmt in stmts_exited:
                stmt_next[stmt].add(second)
            stmts_entered = self.owners[second] - self.owners[first]
            for stmt in stmts_entered:
                stmt_prev[stmt].add(first)
        for stmt in stmt_next:
            stmt_next[stmt] = frozenset(stmt_next[stmt])
        for stmt in stmt_prev:
            stmt_prev[stmt] = frozenset(stmt_prev[stmt])
        result = Graph(entry=self.head, exit=self.leaves, error=self.errors, index=self.node_index, stmt_prev=stmt_prev, stmt_next=stmt_next)
        self.reset()
        return result