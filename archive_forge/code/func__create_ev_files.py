import os
from glob import glob
from shutil import rmtree
from string import Template
import numpy as np
from nibabel import load
from ... import LooseVersion
from ...utils.filemanip import simplify_list, ensure_list
from ...utils.misc import human_order_sorted
from ...external.due import BibTeX
from ..base import (
from .base import FSLCommand, FSLCommandInputSpec, Info
def _create_ev_files(self, cwd, runinfo, runidx, ev_parameters, orthogonalization, contrasts, do_tempfilter, basis_key):
    """Creates EV files from condition and regressor information.

        Parameters:
        -----------

        runinfo : dict
            Generated by `SpecifyModel` and contains information
            about events and other regressors.
        runidx  : int
            Index to run number
        ev_parameters : dict
            A dictionary containing the model parameters for the
            given design type.
        orthogonalization : dict
            A dictionary of dictionaries specifying orthogonal EVs.
        contrasts : list of lists
            Information on contrasts to be evaluated
        """
    conds = {}
    evname = []
    if basis_key == 'dgamma':
        basis_key = 'hrf'
    elif basis_key == 'gamma':
        try:
            _ = ev_parameters['gammasigma']
        except KeyError:
            ev_parameters['gammasigma'] = 3
        try:
            _ = ev_parameters['gammadelay']
        except KeyError:
            ev_parameters['gammadelay'] = 6
    ev_template = load_template('feat_ev_' + basis_key + '.tcl')
    ev_none = load_template('feat_ev_none.tcl')
    ev_ortho = load_template('feat_ev_ortho.tcl')
    ev_txt = ''
    num_evs = [0, 0]
    for field in ['cond', 'regress']:
        for i, cond in enumerate(runinfo[field]):
            name = cond['name']
            evname.append(name)
            evfname = os.path.join(cwd, 'ev_%s_%d_%d.txt' % (name, runidx, len(evname)))
            evinfo = []
            num_evs[0] += 1
            num_evs[1] += 1
            if field == 'cond':
                for j, onset in enumerate(cond['onset']):
                    try:
                        amplitudes = cond['amplitudes']
                        if len(amplitudes) > 1:
                            amp = amplitudes[j]
                        else:
                            amp = amplitudes[0]
                    except KeyError:
                        amp = 1
                    if len(cond['duration']) > 1:
                        evinfo.insert(j, [onset, cond['duration'][j], amp])
                    else:
                        evinfo.insert(j, [onset, cond['duration'][0], amp])
                ev_parameters['cond_file'] = evfname
                ev_parameters['ev_num'] = num_evs[0]
                ev_parameters['ev_name'] = name
                ev_parameters['tempfilt_yn'] = do_tempfilter
                if 'basisorth' not in ev_parameters:
                    ev_parameters['basisorth'] = 1
                if 'basisfnum' not in ev_parameters:
                    ev_parameters['basisfnum'] = 1
                try:
                    ev_parameters['fsldir'] = os.environ['FSLDIR']
                except KeyError:
                    if basis_key == 'flobs':
                        raise Exception('FSL environment variables not set')
                    else:
                        ev_parameters['fsldir'] = '/usr/share/fsl'
                ev_parameters['temporalderiv'] = int(bool(ev_parameters.get('derivs', False)))
                if ev_parameters['temporalderiv']:
                    evname.append(name + 'TD')
                    num_evs[1] += 1
                ev_txt += ev_template.substitute(ev_parameters)
            elif field == 'regress':
                evinfo = [[j] for j in cond['val']]
                ev_txt += ev_none.substitute(ev_num=num_evs[0], ev_name=name, tempfilt_yn=do_tempfilter, cond_file=evfname)
            ev_txt += '\n'
            conds[name] = evfname
            self._create_ev_file(evfname, evinfo)
    for i in range(1, num_evs[0] + 1):
        initial = ev_ortho.substitute(c0=i, c1=0, orthogonal=1)
        for j in range(0, num_evs[0] + 1):
            try:
                orthogonal = int(orthogonalization[i][j])
            except (KeyError, TypeError, ValueError, IndexError):
                orthogonal = 0
            if orthogonal == 1 and initial not in ev_txt:
                ev_txt += initial + '\n'
            ev_txt += ev_ortho.substitute(c0=i, c1=j, orthogonal=orthogonal)
            ev_txt += '\n'
    if isdefined(contrasts):
        contrast_header = load_template('feat_contrast_header.tcl')
        contrast_prolog = load_template('feat_contrast_prolog.tcl')
        contrast_element = load_template('feat_contrast_element.tcl')
        contrast_ftest_element = load_template('feat_contrast_ftest_element.tcl')
        contrastmask_header = load_template('feat_contrastmask_header.tcl')
        contrastmask_footer = load_template('feat_contrastmask_footer.tcl')
        contrastmask_element = load_template('feat_contrastmask_element.tcl')
        ev_txt += contrast_header.substitute()
        con_names = []
        for j, con in enumerate(contrasts):
            con_names.append(con[0])
        con_map = {}
        ftest_idx = []
        ttest_idx = []
        for j, con in enumerate(contrasts):
            if con[1] == 'F':
                ftest_idx.append(j)
                for c in con[2]:
                    if c[0] not in list(con_map.keys()):
                        con_map[c[0]] = []
                    con_map[c[0]].append(j)
            else:
                ttest_idx.append(j)
        for ctype in ['real', 'orig']:
            for j, con in enumerate(contrasts):
                if con[1] == 'F':
                    continue
                tidx = ttest_idx.index(j) + 1
                ev_txt += contrast_prolog.substitute(cnum=tidx, ctype=ctype, cname=con[0])
                count = 0
                for c in range(1, len(evname) + 1):
                    if evname[c - 1].endswith('TD') and ctype == 'orig':
                        continue
                    count = count + 1
                    if evname[c - 1] in con[2]:
                        val = con[3][con[2].index(evname[c - 1])]
                    else:
                        val = 0.0
                    ev_txt += contrast_element.substitute(cnum=tidx, element=count, ctype=ctype, val=val)
                    ev_txt += '\n'
                for fconidx in ftest_idx:
                    fval = 0
                    if con[0] in con_map.keys() and fconidx in con_map[con[0]]:
                        fval = 1
                    ev_txt += contrast_ftest_element.substitute(cnum=ftest_idx.index(fconidx) + 1, element=tidx, ctype=ctype, val=fval)
                    ev_txt += '\n'
        ev_txt += contrastmask_header.substitute()
        for j, _ in enumerate(contrasts):
            for k, _ in enumerate(contrasts):
                if j != k:
                    ev_txt += contrastmask_element.substitute(c1=j + 1, c2=k + 1)
        ev_txt += contrastmask_footer.substitute()
    return (num_evs, ev_txt)