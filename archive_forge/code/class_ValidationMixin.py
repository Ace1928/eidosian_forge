import re
from typing import TYPE_CHECKING, cast, Any, Dict, Generic, List, Iterator, Optional, \
from xml.etree import ElementTree
from elementpath import select
from elementpath.etree import is_etree_element, etree_tostring
from ..exceptions import XMLSchemaValueError, XMLSchemaTypeError
from ..names import XSD_ANNOTATION, XSD_APPINFO, XSD_DOCUMENTATION, \
from ..aliases import ElementType, NamespacesType, SchemaType, BaseXsdType, \
from ..translation import gettext as _
from ..helpers import get_qname, local_name, get_prefixed_qname
from ..resources import XMLResource
from .exceptions import XMLSchemaParseError, XMLSchemaValidationError
class ValidationMixin(Generic[ST, DT]):
    """
    Mixin for implementing XML data validators/decoders on XSD components.
    A derived class must implement the methods `iter_decode` and `iter_encode`.
    """

    def validate(self, obj: ST, use_defaults: bool=True, namespaces: Optional[NamespacesType]=None, max_depth: Optional[int]=None, extra_validator: Optional[ExtraValidatorType]=None) -> None:
        """
        Validates XML data against the XSD schema/component instance.

        :param obj: the XML data. Can be a string for an attribute or a simple type         validators, or an ElementTree's Element otherwise.
        :param use_defaults: indicates whether to use default values for filling missing data.
        :param namespaces: is an optional mapping from namespace prefix to URI.
        :param max_depth: maximum level of validation, for default there is no limit.
        :param extra_validator: an optional function for performing non-standard         validations on XML data. The provided function is called for each traversed         element, with the XML element as 1st argument and the corresponding XSD         element as 2nd argument. It can be also a generator function and has to         raise/yield :exc:`xmlschema.XMLSchemaValidationError` exceptions.
        :raises: :exc:`xmlschema.XMLSchemaValidationError` if the XML data instance is invalid.
        """
        for error in self.iter_errors(obj, use_defaults, namespaces, max_depth, extra_validator):
            raise error

    def is_valid(self, obj: ST, use_defaults: bool=True, namespaces: Optional[NamespacesType]=None, max_depth: Optional[int]=None, extra_validator: Optional[ExtraValidatorType]=None) -> bool:
        """
        Like :meth:`validate` except that does not raise an exception but returns
        ``True`` if the XML data instance is valid, ``False`` if it is invalid.
        """
        error = next(self.iter_errors(obj, use_defaults, namespaces, max_depth, extra_validator), None)
        return error is None

    def iter_errors(self, obj: ST, use_defaults: bool=True, namespaces: Optional[NamespacesType]=None, max_depth: Optional[int]=None, extra_validator: Optional[ExtraValidatorType]=None) -> Iterator[XMLSchemaValidationError]:
        """
        Creates an iterator for the errors generated by the validation of an XML data against
        the XSD schema/component instance. Accepts the same arguments of :meth:`validate`.
        """
        kwargs: Dict[str, Any] = {'use_defaults': use_defaults, 'namespaces': namespaces}
        if max_depth is not None:
            kwargs['max_depth'] = max_depth
        if extra_validator is not None:
            kwargs['extra_validator'] = extra_validator
        for result in self.iter_decode(obj, **kwargs):
            if isinstance(result, XMLSchemaValidationError):
                yield result
            else:
                del result

    def decode(self, obj: ST, validation: str='strict', **kwargs: Any) -> DecodeType[DT]:
        """
        Decodes XML data.

        :param obj: the XML data. Can be a string for an attribute or for simple type         components or a dictionary for an attribute group or an ElementTree's         Element for other components.
        :param validation: the validation mode. Can be 'lax', 'strict' or 'skip.
        :param kwargs: optional keyword arguments for the method :func:`iter_decode`.
        :return: a dictionary like object if the XSD component is an element, a         group or a complex type; a list if the XSD component is an attribute group;         a simple data type object otherwise. If *validation* argument is 'lax' a 2-items         tuple is returned, where the first item is the decoded object and the second item         is a list containing the errors.
        :raises: :exc:`xmlschema.XMLSchemaValidationError` if the object is not decodable by         the XSD component, or also if it's invalid when ``validation='strict'`` is provided.
        """
        check_validation_mode(validation)
        result: Union[DT, XMLSchemaValidationError]
        errors: List[XMLSchemaValidationError] = []
        for result in self.iter_decode(obj, validation, **kwargs):
            if not isinstance(result, XMLSchemaValidationError):
                return (result, errors) if validation == 'lax' else result
            elif validation == 'strict':
                raise result
            else:
                errors.append(result)
        return (None, errors) if validation == 'lax' else None

    def encode(self, obj: Any, validation: str='strict', **kwargs: Any) -> EncodeType[Any]:
        """
        Encodes data to XML.

        :param obj: the data to be encoded to XML.
        :param validation: the validation mode. Can be 'lax', 'strict' or 'skip.
        :param kwargs: optional keyword arguments for the method :func:`iter_encode`.
        :return: An element tree's Element if the original data is a structured data or         a string if it's simple type datum. If *validation* argument is 'lax' a 2-items         tuple is returned, where the first item is the encoded object and the second item         is a list containing the errors.
        :raises: :exc:`xmlschema.XMLSchemaValidationError` if the object is not encodable by         the XSD component, or also if it's invalid when ``validation='strict'`` is provided.
        """
        check_validation_mode(validation)
        result, errors = (None, [])
        for result in self.iter_encode(obj, validation=validation, **kwargs):
            if not isinstance(result, XMLSchemaValidationError):
                break
            elif validation == 'strict':
                raise result
            else:
                errors.append(result)
        return (result, errors) if validation == 'lax' else result

    def iter_decode(self, obj: ST, validation: str='lax', **kwargs: Any) -> IterDecodeType[DT]:
        """
        Creates an iterator for decoding an XML source to a Python object.

        :param obj: the XML data.
        :param validation: the validation mode. Can be 'lax', 'strict' or 'skip.
        :param kwargs: keyword arguments for the decoder API.
        :return: Yields a decoded object, eventually preceded by a sequence of         validation or decoding errors.
        """
        raise NotImplementedError()

    def iter_encode(self, obj: Any, validation: str='lax', **kwargs: Any) -> IterEncodeType[Any]:
        """
        Creates an iterator for encoding data to an Element tree.

        :param obj: The data that has to be encoded.
        :param validation: The validation mode. Can be 'lax', 'strict' or 'skip'.
        :param kwargs: keyword arguments for the encoder API.
        :return: Yields an Element, eventually preceded by a sequence of validation         or encoding errors.
        """
        raise NotImplementedError()