from pygments.lexer import RegexLexer, include, using, this, bygroups, words
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
class KuinLexer(RegexLexer):
    """
    For Kuin source code.

    .. versionadded:: 2.9
    """
    name = 'Kuin'
    url = 'https://github.com/kuina/Kuin'
    aliases = ['kuin']
    filenames = ['*.kn']
    tokens = {'root': [include('statement')], 'statement': [include('whitespace'), ('(\\+?)([ \\t]*)(\\*?)([ \\t]*)(\\bfunc)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*)', bygroups(Keyword, Whitespace, Keyword, Whitespace, Keyword, using(this), Name.Function), 'func_'), ('\\b(class)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*)', bygroups(Keyword, using(this), Name.Class), 'class_'), ('\\b(enum)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*)', bygroups(Keyword, using(this), Name.Constant), 'enum_'), ('\\b(block)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'block_'), ('\\b(ifdef)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'ifdef_'), ('\\b(if)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'if_'), ('\\b(switch)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'switch_'), ('\\b(while)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'while_'), ('\\b(for)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'for_'), ('\\b(foreach)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'foreach_'), ('\\b(try)\\b(?:([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)([a-zA-Z_][0-9a-zA-Z_]*))?', bygroups(Keyword, using(this), Name.Other), 'try_'), ('\\b(do)\\b', Keyword, 'do'), ('(\\+?[ \\t]*\\bvar)\\b', Keyword, 'var'), ('\\b(const)\\b', Keyword, 'const'), ('\\b(ret)\\b', Keyword, 'ret'), ('\\b(throw)\\b', Keyword, 'throw'), ('\\b(alias)\\b', Keyword, 'alias'), ('\\b(assert)\\b', Keyword, 'assert'), ('\\|', Text, 'continued_line'), ('[ \\t]*\\n', Whitespace)], 'whitespace': [('^([ \\t]*)(;.*)', bygroups(Comment.Single, Whitespace)), ('[ \\t]+(?![; \\t])', Whitespace), ('\\{', Comment.Multiline, 'multiline_comment')], 'multiline_comment': [('\\{', Comment.Multiline, 'multiline_comment'), ('(?:\\s*;.*|[^{}\\n]+)', Comment.Multiline), ('\\n', Comment.Multiline), ('\\}', Comment.Multiline, '#pop')], 'func_': [include('expr'), ('\\n', Whitespace, 'func')], 'func': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(func)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement')], 'class_': [include('expr'), ('\\n', Whitespace, 'class')], 'class': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(class)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement')], 'enum_': [include('expr'), ('\\n', Whitespace, 'enum')], 'enum': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(enum)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('expr'), ('\\n', Whitespace)], 'block_': [include('expr'), ('\\n', Whitespace, 'block')], 'block': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(block)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement'), include('break'), include('skip')], 'ifdef_': [include('expr'), ('\\n', Whitespace, 'ifdef')], 'ifdef': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(ifdef)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), (words(('rls', 'dbg'), prefix='\\b', suffix='\\b'), Keyword.Constant, 'ifdef_sp'), include('statement'), include('break'), include('skip')], 'ifdef_sp': [include('expr'), ('\\n', Whitespace, '#pop')], 'if_': [include('expr'), ('\\n', Whitespace, 'if')], 'if': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(if)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), (words(('elif', 'else'), prefix='\\b', suffix='\\b'), Keyword, 'if_sp'), include('statement'), include('break'), include('skip')], 'if_sp': [include('expr'), ('\\n', Whitespace, '#pop')], 'switch_': [include('expr'), ('\\n', Whitespace, 'switch')], 'switch': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(switch)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), (words(('case', 'default', 'to'), prefix='\\b', suffix='\\b'), Keyword, 'switch_sp'), include('statement'), include('break'), include('skip')], 'switch_sp': [include('expr'), ('\\n', Whitespace, '#pop')], 'while_': [include('expr'), ('\\n', Whitespace, 'while')], 'while': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(while)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement'), include('break'), include('skip')], 'for_': [include('expr'), ('\\n', Whitespace, 'for')], 'for': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(for)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement'), include('break'), include('skip')], 'foreach_': [include('expr'), ('\\n', Whitespace, 'foreach')], 'foreach': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(foreach)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), include('statement'), include('break'), include('skip')], 'try_': [include('expr'), ('\\n', Whitespace, 'try')], 'try': [('\\b(end)([ \\t]+(?:\\n\\s*\\|)*[ \\t]*)(try)\\b', bygroups(Keyword, using(this), Keyword), '#pop:2'), (words(('catch', 'finally', 'to'), prefix='\\b', suffix='\\b'), Keyword, 'try_sp'), include('statement'), include('break'), include('skip')], 'try_sp': [include('expr'), ('\\n', Whitespace, '#pop')], 'break': [('\\b(break)\\b([ \\t]+)([a-zA-Z_][0-9a-zA-Z_]*)', bygroups(Keyword, using(this), Name.Other))], 'skip': [('\\b(skip)\\b([ \\t]+)([a-zA-Z_][0-9a-zA-Z_]*)', bygroups(Keyword, using(this), Name.Other))], 'alias': [include('expr'), ('\\n', Whitespace, '#pop')], 'assert': [include('expr'), ('\\n', Whitespace, '#pop')], 'const': [include('expr'), ('\\n', Whitespace, '#pop')], 'do': [include('expr'), ('\\n', Whitespace, '#pop')], 'ret': [include('expr'), ('\\n', Whitespace, '#pop')], 'throw': [include('expr'), ('\\n', Whitespace, '#pop')], 'var': [include('expr'), ('\\n', Whitespace, '#pop')], 'continued_line': [include('expr'), ('\\n', Whitespace, '#pop')], 'expr': [include('whitespace'), ('\\(', Punctuation), ('\\)', Punctuation), ('\\[', Punctuation), ('\\]', Punctuation), (',', Punctuation), (words(('true', 'false', 'null', 'inf'), prefix='\\b', suffix='\\b'), Keyword.Constant), (words('me', prefix='\\b', suffix='\\b'), Keyword), (words(('bit16', 'bit32', 'bit64', 'bit8', 'bool', 'char', 'class', 'dict', 'enum', 'float', 'func', 'int', 'list', 'queue', 'stack'), prefix='\\b', suffix='\\b'), Keyword.Type), ('\\b[0-9]\\.[0-9]+(?!\\.)(:?e[\\+-][0-9]+)?\\b', Number.Float), ('\\b2#[01]+(?:b(?:8|16|32|64))?\\b', Number.Bin), ('\\b8#[0-7]+(?:b(?:8|16|32|64))?\\b', Number.Oct), ('\\b16#[0-9A-F]+(?:b(?:8|16|32|64))?\\b', Number.Hex), ('\\b[0-9]+(?:b(?:8|16|32|64))?\\b', Number.Decimal), ('"', String.Double, 'string'), ("'(?:\\\\.|.)+?'", String.Char), ('(?:\\.|\\$(?:>|<)?)', Operator), ('(?:\\^)', Operator), ('(?:\\+|-|!|##?)', Operator), ('(?:\\*|/|%)', Operator), ('(?:~)', Operator), ('(?:(?:=|<>)(?:&|\\$)?|<=?|>=?)', Operator), ('(?:&)', Operator), ('(?:\\|)', Operator), ('(?:\\?)', Operator), ('(?::(?::|\\+|-|\\*|/|%|\\^|~)?)', Operator), ('\\b([a-zA-Z_][0-9a-zA-Z_]*)(?=@)\\b', Name), ('(@)?\\b([a-zA-Z_][0-9a-zA-Z_]*)\\b', bygroups(Name.Other, Name.Variable))], 'string': [('(?:\\\\[^{\\n]|[^"\\\\])+', String.Double), ('\\\\\\{', String.Double, 'toStrInString'), ('"', String.Double, '#pop')], 'toStrInString': [include('expr'), ('\\}', String.Double, '#pop')]}