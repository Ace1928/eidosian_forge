from pyomo.common.dependencies import numpy as np, numpy_available
import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pickle
from itertools import permutations, product
import logging
from enum import Enum
from pyomo.common.timing import TicTocTimer
from pyomo.contrib.sensitivity_toolbox.sens import get_dsdp
from pyomo.contrib.doe.scenario import ScenarioGenerator, FiniteDifferenceStep
from pyomo.contrib.doe.result import FisherResults, GridSearchResult
def _finite_calculation(self, output_record):
    """
        Calculate Jacobian for sequential_finite mode

        Parameters
        ----------
        output_record: a dict of outputs, keys are scenario names, values are a list of measurements values
        scena_gen: an object generated by Scenario_creator class

        Returns
        -------
        jac: Jacobian matrix, a dictionary, keys are parameter names, values are a list of jacobian values with respect to this parameter
        """
    jac = {}
    for para in self.param.keys():
        involved_s = self.scenario_data.scena_num[para]
        s1 = involved_s[0]
        s2 = involved_s[1]
        list_jac = []
        for i in range(len(output_record[s1])):
            sensi = (output_record[s1][i] - output_record[s2][i]) / self.scenario_data.eps_abs[para] * self.scale_constant_value
            if self.scale_nominal_param_value:
                sensi *= self.param[para]
            list_jac.append(sensi)
        jac[para] = list_jac
    return jac