import re
from collections import deque, namedtuple
import copy
from numbers import Integral
import numpy as np  # type: ignore
from Bio.PDB.Atom import Atom, DisorderedAtom
from Bio.Data.PDBData import protein_letters_3to1
from Bio.PDB.vectors import multi_coord_space, multi_rot_Z
from Bio.PDB.vectors import coord_space
from Bio.PDB.ic_data import ic_data_backbone, ic_data_sidechains
from Bio.PDB.ic_data import primary_angles
from Bio.PDB.ic_data import ic_data_sidechain_extras, residue_atom_bond_state
from Bio.PDB.ic_data import dihedra_primary_defaults, hedra_defaults
from typing import (
class IC_Chain:
    """Class to extend Biopython Chain with internal coordinate data.

    Attributes
    ----------
    chain: object reference
        The Biopython :class:`Bio.PDB.Chain.Chain` object this extends

    MaxPeptideBond: float
        **Class** attribute to detect chain breaks.
        Override for fully contiguous chains with some very long bonds - e.g.
        for 3D printing (OpenSCAD output) a structure with missing residues.
        :data:`MaxPeptideBond`

    ParallelAssembleResidues: bool
        **Class** attribute affecting internal_to_atom_coords.
        Short (50 residue and less) chains are faster to assemble without the
        overhead of creating numpy arrays, and the algorithm is easier to
        understand and trace processing a single residue at a time.  Clearing
        (set to False) this flag will switch to the serial algorithm

    ordered_aa_ic_list: list
        IC_Residue objects internal_coords algorithms can process (e.g. no
        waters)

    initNCaC: List of N, Ca, C AtomKey tuples (NCaCKeys).
        NCaCKeys start chain segments (first residue or after chain break).
        These 3 atoms define the coordinate space for a contiguous chain
        segment, as initially specified by PDB or mmCIF file.

    AAsiz = int
        AtomArray size, number of atoms in this chain

    atomArray: numpy array
        homogeneous atom coords ([x,, y, z, 1.0]) for every atom in chain

    atomArrayIndex: dict
        maps AtomKeys to atomArray indexes

    hedra: dict
        Hedra forming residues in this chain; indexed by 3-tuples of AtomKeys.

    hedraLen: int
        length of hedra dict

    hedraNdx: dict
        maps hedra AtomKeys to numeric index into hedra data arrays e.g.
        hedraL12 below

    a2ha_map: [hedraLen x 3]
        atom indexes in hedraNdx order

    dihedra: dict
        Dihedra forming residues in this chain; indexed by 4-tuples of AtomKeys.

    dihedraLen: int
        length of dihedra dict

    dihedraNdx: dict
        maps dihedra AtomKeys to dihedra data arrays e.g. dihedraAngle

    a2da_map : [dihedraLen x 4]
        AtomNdx's in dihedraNdx order

    d2a_map : [dihedraLen x [4]]
        AtomNdx's for each dihedron (reshaped a2da_map)

    Numpy arrays for vector processing of chain di/hedra:

    hedraL12: numpy array
        bond length between hedron 1st and 2nd atom
    hedraAngle: numpy array
        bond angle for each hedron, in degrees
    hedraL23: numpy array
        bond length between hedron 2nd and 3rd atom

    id3_dh_index: dict
        maps hedron key to list of dihedra starting with hedron, used by
        assemble and bond_rotate to find dihedra with h1 key

    id32_dh_index: dict
        like id3_dh_index, find dihedra from h2 key

    hAtoms: numpy array
        homogeneous atom coordinates (3x4) of hedra, central atom at origin

    hAtomsR: numpy array
        hAtoms in reverse orientation

    hAtoms_needs_update: numpy array of bool
        indicates whether hAtoms represent hedraL12/A/L23

    dihedraAngle: numpy array
        dihedral angles (degrees) for each dihedron

    dAtoms: numpy array
        homogeneous atom coordinates (4x4) of dihedra, second atom at origin

    dAtoms_needs_update: numpy array of bool
        indicates whether dAtoms represent dihedraAngle

    dCoordSpace: numpy array
        forward and reverse transform matrices standardising positions of first
        hedron.  See :data:`dCoordSpace`.

    dcsValid: bool
        indicates dCoordSpace up to date

    See also attributes generated by :meth:`build_edraArrays` for indexing
    di/hedra data elements.

    Methods
    -------
    internal_to_atom_coordinates:
        Process ic data to Residue/Atom coordinates; calls assemble_residues()
    assemble_residues:
        Generate IC_Chain atom coords from internal coordinates (parallel)
    assemble_residues_ser:
        Generate IC_Residue atom coords from internal coordinates (serial)
    atom_to_internal_coordinates:
        Calculate dihedrals, angles, bond lengths (internal coordinates) for
        Atom data
    write_SCAD:
        Write OpenSCAD matrices for internal coordinate data comprising chain;
        this is a support routine, see :func:`.SCADIO.write_SCAD` to generate
        OpenSCAD description of a protein chain.
    distance_plot:
        Generate 2D plot of interatomic distances with optional filter
    distance_to_internal_coordinates:
        Compute internal coordinates from distance plot and array of dihedral
        angle signs.
    make_extended:
        Arbitrarily sets all psi and phi backbone angles to 123 and -104 degrees.

    """
    MaxPeptideBond = 1.4
    'Larger C-N distance than this will be chain break'
    ParallelAssembleResidues = True
    'Enable parallel internal_to_atom algorithm, is slower for short chains'
    AAsiz = 0
    'Number of atoms in this chain (size of atomArray)'
    atomArray: np.array = None
    'AAsiz x [4] of float np.float64 homogeneous atom coordinates, all atoms\n    in chain.'
    dCoordSpace = None
    '[2][dihedraLen][4][4] : 2 arrays of 4x4 coordinate space transforms for\n    each dihedron.  The first [0] converts TO standard space with first atom on\n    the XZ plane, the second atom at the origin, the third on the +Z axis, and\n    the fourth placed according to the dihedral angle.  The second [1] transform\n    returns FROM the standard space to world coordinates (PDB file input or\n    whatever is current).  Also accessible as .cst (forward\n    transform) and .rcst (reverse transform) in :class:`Dihedron`.'
    dcsValid = None
    'True if dCoordSpace is up to date.  Use :meth:`.update_dCoordSpace`\n    if needed.'
    _dihedraSelect = np.array([True, True, True, False])
    _dihedraOK = np.array([True, True, True, True])

    def __init__(self, parent: 'Chain', verbose: bool=False) -> None:
        """Initialize IC_Chain object, with or without residue/Atom data.

        :param Bio.PDB.Chain parent: Biopython Chain object
            Chain object this extends
        """
        self.chain = parent
        self.ordered_aa_ic_list: List[IC_Residue] = []
        self.initNCaCs = []
        self.sqMaxPeptideBond = np.square(IC_Chain.MaxPeptideBond)
        self.hedra = {}
        self.dihedra = {}
        self.atomArrayIndex: Dict['AtomKey', int] = {}
        self.bpAtomArray: List['Atom'] = []
        self._set_residues(verbose)

    def __deepcopy__(self, memo) -> 'IC_Chain':
        """Implement deepcopy for IC_Chain."""
        existing = memo.get(id(self), False)
        if existing:
            return existing
        dup = type(self).__new__(self.__class__)
        memo[id(self)] = dup
        dup.chain = memo[id(self.chain)]
        dup.chain.child_dict = copy.deepcopy(self.chain.child_dict, memo)
        dup.chain.child_list = copy.deepcopy(self.chain.child_list, memo)
        dup.akset = copy.deepcopy(self.akset, memo)
        dup.aktuple = copy.deepcopy(self.aktuple, memo)
        dup.ordered_aa_ic_list = copy.deepcopy(self.ordered_aa_ic_list, memo)
        dup.atomArrayIndex = self.atomArrayIndex.copy()
        dup.atomArrayValid = self.atomArrayValid.copy()
        dup.atomArray = self.atomArray.copy()
        dup.hedra = copy.deepcopy(self.hedra, memo)
        dup.dihedra = copy.deepcopy(self.dihedra, memo)
        dup.id3_dh_index = copy.deepcopy(self.id3_dh_index, memo)
        dup.id32_dh_index = copy.deepcopy(self.id32_dh_index, memo)
        dup.AAsiz = self.AAsiz
        dup.bpAtomArray = [None] * dup.AAsiz

        def setAtomVw(res, atm):
            ak = AtomKey(res.internal_coord, atm)
            ndx = dup.atomArrayIndex[ak]
            atm.coord = dup.atomArray[ndx, 0:3]
            dup.bpAtomArray[ndx] = atm

        def setResAtmVws(res):
            for atm in res.get_atoms():
                if atm.is_disordered():
                    for altAtom in atm.child_dict.values():
                        setAtomVw(res, altAtom)
                else:
                    setAtomVw(res, atm)
        for ric in dup.ordered_aa_ic_list:
            setResAtmVws(ric.residue)
            ric.rprev = copy.deepcopy(ric.rprev, memo)
            ric.rnext = copy.deepcopy(ric.rnext, memo)
            ric.ak_set = copy.deepcopy(ric.ak_set, memo)
            ric.akc = copy.deepcopy(ric.akc, memo)
            ric.dihedra = copy.deepcopy(ric.dihedra, memo)
            ric.hedra = copy.deepcopy(ric.hedra, memo)
        dup.sqMaxPeptideBond = self.sqMaxPeptideBond
        dup.initNCaCs = copy.deepcopy(self.initNCaCs, memo)
        dup.hedraLen = self.hedraLen
        dup.hedraL12 = self.hedraL12.copy()
        dup.hedraAngle = self.hedraAngle.copy()
        dup.hedraL23 = self.hedraL23.copy()
        dup.hedraNdx = copy.deepcopy(self.hedraNdx, memo)
        dup.dihedraLen = self.dihedraLen
        dup.dihedraAngle = self.dihedraAngle.copy()
        dup.dihedraAngleRads = self.dihedraAngleRads.copy()
        dup.dihedraNdx = copy.deepcopy(self.dihedraNdx, memo)
        dup.a2da_map = self.a2da_map.copy()
        dup.a2d_map = self.a2d_map.copy()
        dup.d2a_map = self.d2a_map.copy()
        dup.dH1ndx = self.dH1ndx.copy()
        dup.dH2ndx = self.dH2ndx.copy()
        dup.hAtoms = self.hAtoms.copy()
        dup.hAtomsR = self.hAtomsR.copy()
        dup.hAtoms_needs_update = self.hAtoms_needs_update.copy()
        dup.dRev = self.dRev.copy()
        dup.dFwd = self.dFwd.copy()
        dup.dAtoms_needs_update = self.dAtoms_needs_update.copy()
        dup.dAtoms = self.dAtoms.copy()
        dup.a4_pre_rotation = self.a4_pre_rotation.copy()
        dup.dCoordSpace = self.dCoordSpace.copy()
        dup.dcsValid = self.dcsValid.copy()
        for d in dup.dihedra.values():
            d.cst = dup.dCoordSpace[0][d.ndx]
            d.rcst = dup.dCoordSpace[1][d.ndx]
        return dup

    def _atm_dist_chk(self, a0: Atom, a1: Atom, cutoff: float, sqCutoff: float) -> bool:
        return sqCutoff > np.sum(np.square(a0.coord - a1.coord))

    def _peptide_check(self, prev: 'Residue', curr: 'Residue') -> Optional[str]:
        if 0 == len(curr.child_dict):
            return None
        if 0 != len(curr.child_dict) and 0 == len(prev.child_dict):
            return 'PIC data missing atoms'
        if not prev.internal_coord.isAccept:
            return 'previous residue not standard/accepted amino acid'
        Natom = curr.child_dict.get('N', None)
        pCatom = prev.child_dict.get('C', None)
        if Natom is None or pCatom is None:
            return f'missing {('previous C' if pCatom is None else 'N')} atom'
        pCAatom = prev.child_dict.get('CA', None)
        pNatom = prev.child_dict.get('N', None)
        if pNatom is None or pCAatom is None:
            return 'previous residue missing N or Ca'
        if IC_Residue.no_altloc:
            if Natom.is_disordered():
                Natom = Natom.selected_child
            if pCatom.is_disordered():
                pCatom = pCatom.selected_child
        if IC_Residue.no_altloc or (not Natom.is_disordered() and (not pCatom.is_disordered())):
            dc = self._atm_dist_chk(Natom, pCatom, IC_Chain.MaxPeptideBond, self.sqMaxPeptideBond)
            if dc:
                return None
            else:
                return f'MaxPeptideBond ({IC_Chain.MaxPeptideBond} angstroms) exceeded'
        Nlist: List[Atom] = []
        pClist: List[Atom] = []
        if Natom.is_disordered():
            Nlist.extend(Natom.child_dict.values())
        else:
            Nlist = [Natom]
        if pCatom.is_disordered():
            pClist.extend(pCatom.child_dict.values())
        else:
            pClist = [pCatom]
        for n in Nlist:
            for c in pClist:
                if self._atm_dist_chk(n, c, IC_Chain.MaxPeptideBond, self.sqMaxPeptideBond):
                    return None
        return f'MaxPeptideBond ({IC_Chain.MaxPeptideBond} angstroms) exceeded'

    def clear_ic(self):
        """Clear residue internal_coord settings for this chain."""
        for res in self.chain.get_residues():
            res.internal_coord = None

    def _add_residue(self, res: 'Residue', last_res: List, last_ord_res: List, verbose: bool=False) -> bool:
        """Set rprev, rnext, manage chain break.

        Returns True for no chain break or residue has sufficient data to
        restart at this position after a chain break (sets initNCaC AtomKeys
        in this case).  False return means insufficient data to extend chain
        with this residue.
        """
        res.internal_coord = IC_Residue(res)
        res.internal_coord.cic = self
        ric = res.internal_coord
        if 0 < len(last_res) and last_ord_res == last_res and (self._peptide_check(last_ord_res[0].residue, res) is None):
            for prev in last_ord_res:
                prev.rnext.append(res.internal_coord)
                ric.rprev.append(prev)
            return True
        elif all((atm in res.child_dict for atm in ('N', 'CA', 'C'))):
            if verbose and len(last_res) != 0:
                if last_ord_res != last_res:
                    reason = f'disordered residues after {last_ord_res.pretty_str()}'
                else:
                    reason = cast(str, self._peptide_check(last_ord_res[0].residue, res))
                print(f'chain break at {ric.pretty_str()} due to {reason}')
            iNCaC = ric.split_akl((AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C')))
            self.initNCaCs.extend(iNCaC)
            return True
        return False

    def _set_residues(self, verbose: bool=False) -> None:
        """Initialize .internal_coord for loaded Biopython Residue objects.

        Add IC_Residue as .internal_coord attribute for each :class:`.Residue`
        in parent :class:`Bio.PDB.Chain.Chain`; populate ordered_aa_ic_list with
        :class:`IC_Residue` references for residues which can be built (amino
        acids and some hetatms); set rprev and rnext on each sequential
        IC_Residue, populate initNCaC at start and after chain breaks.

        Generates:
            self.akset : set of :class:`.AtomKey` s in this chain
        """
        last_res: List['IC_Residue'] = []
        last_ord_res: List['IC_Residue'] = []
        akset = set()
        for res in self.chain.get_residues():
            if res.id[0] == ' ' or res.id[0] in IC_Residue.accept_resnames:
                this_res: List['IC_Residue'] = []
                if 2 == res.is_disordered() and (not IC_Residue.no_altloc):
                    for r in res.child_dict.values():
                        if self._add_residue(r, last_res, last_ord_res, verbose):
                            this_res.append(r.internal_coord)
                            akset.update(r.internal_coord.ak_set)
                elif self._add_residue(res, last_res, last_ord_res, verbose):
                    this_res.append(res.internal_coord)
                    akset.update(res.internal_coord.ak_set)
                if 0 < len(this_res):
                    self.ordered_aa_ic_list.extend(this_res)
                    last_ord_res = this_res
                last_res = this_res
        self.akset = akset
        self.initNCaCs = sorted(self.initNCaCs)

    def build_atomArray(self) -> None:
        """Build :class:`IC_Chain` numpy coordinate array from biopython atoms.

        See also :meth:`.init_edra` for more complete initialization of IC_Chain.

        Inputs:
            self.akset : set
                :class:`AtomKey` s in this chain

        Generates:
            self.AAsiz : int
                number of atoms in chain (len(akset))
            self.aktuple : AAsiz x AtomKeys
                sorted akset AtomKeys
            self.atomArrayIndex : [AAsiz] of int
                numerical index for each AtomKey in aktuple
            self.atomArrayValid : AAsiz x bool
                atomArray coordinates current with internal coordinates if True
            self.atomArray : AAsiz x np.float64[4]
                homogeneous atom coordinates; Biopython :class:`.Atom`
                coordinates are view into this array after execution
            rak_cache : dict
                lookup cache for AtomKeys for each residue

        """

        def setAtom(res, atm):
            ak = AtomKey(res.internal_coord, atm)
            try:
                ndx = self.atomArrayIndex[ak]
            except KeyError:
                return
            self.atomArray[ndx, 0:3] = atm.coord
            atm.coord = self.atomArray[ndx, 0:3]
            self.atomArrayValid[ndx] = True
            self.bpAtomArray[ndx] = atm

        def setResAtms(res):
            for atm in res.get_atoms():
                if atm.is_disordered():
                    if IC_Residue.no_altloc:
                        setAtom(res, atm.selected_child)
                    else:
                        for altAtom in atm.child_dict.values():
                            setAtom(res, altAtom)
                else:
                    setAtom(res, atm)
        self.AAsiz = len(self.akset)
        self.aktuple = tuple(sorted(self.akset))
        self.atomArrayIndex = dict(zip(self.aktuple, range(self.AAsiz)))
        self.atomArrayValid = np.zeros(self.AAsiz, dtype=bool)
        self.atomArray = np.zeros((self.AAsiz, 4), dtype=np.float64)
        self.atomArray[:, 3] = 1.0
        self.bpAtomArray = [None] * self.AAsiz
        for ric in self.ordered_aa_ic_list:
            setResAtms(ric.residue)
            if ric.akc == {}:
                ric._build_rak_cache()

    def build_edraArrays(self) -> None:
        """Build chain level hedra and dihedra arrays.

        Used by :meth:`init_edra` and :meth:`_hedraDict2chain`.  Should be
        private method but exposed for documentation.

        Inputs:
            self.dihedraLen : int
                number of dihedra needed
            self.hedraLen : int
                number of hedra needed
            self.AAsiz : int
                length of atomArray
            self.hedraNdx : dict
                maps hedron keys to range(hedraLen)
            self.dihedraNdx : dict
                maps dihedron keys to range(dihedraLen)
            self.hedra : dict
                maps Hedra keys to Hedra for chain
            self.atomArray : AAsiz x np.float64[4]
                homogeneous atom coordinates for chain
            self.atomArrayIndex : dict
                maps AtomKeys to atomArray
            self.atomArrayValid : AAsiz x bool
                indicates coord is up-to-date

        Generates:
            self.dCoordSpace : [2][dihedraLen][4][4]
                transforms to/from dihedron coordinate space
            self.dcsValid : dihedraLen x bool
                indicates dCoordSpace is current
            self.hAtoms : hedraLen x 3 x np.float64[4]
                atom coordinates in hCoordSpace
            self.hAtomsR : hedraLen x 3 x np.float64[4]
                hAtoms in reverse order (trading space for time)
            self.hAtoms_needs_update : hedraLen x bool
                indicates hAtoms, hAtoms current
            self.a2h_map : AAsiz x [int ...]
                maps atomArrayIndex to hedraNdx's with that atom
            self.a2ha_map : [hedraLen x 3]
                AtomNdx's in hedraNdx order
            self.h2aa : hedraLen x [int ...]
                maps hedraNdx to atomNdx's in hedron (reshaped later)
            Hedron.ndx : int
                self.hedraNdx value stored inside Hedron object
            self.dRev : dihedraLen x bool
                dihedron reversed if true
            self.dH1ndx, dH2ndx : [dihedraLen]
                hedraNdx's for 1st and 2nd hedra
            self.h1d_map : hedraLen x []
                hedraNdx -> [dihedra using hedron]
            Dihedron.h1key, h2key : [AtomKey ...]
                hedron keys for dihedron, reversed as needed
            Dihedron.hedron1, hedron2 : Hedron
                references inside dihedron to hedra
            Dihedron.ndx : int
                self.dihedraNdx info inside Dihedron object
            Dihedron.cst, rcst : np.float64p4][4]
                dCoordSpace references inside Dihedron
            self.a2da_map : [dihedraLen x 4]
                AtomNdx's in dihedraNdx order
            self.d2a_map : [dihedraLen x [4]]
                AtomNdx's for each dihedron (reshaped a2da_map)
            self.dFwd : bool
                dihedron is not Reversed if True
            self.a2d_map : AAsiz x [[dihedraNdx]
                [atom ndx 0-3 of atom in dihedron]], maps atom indexes to
                dihedra and atoms in them
            self.dAtoms_needs_update : dihedraLen x bool
                atoms in h1, h2 are current if False

        """
        self.dCoordSpace: np.ndarray = np.empty((2, self.dihedraLen, 4, 4), dtype=np.float64)
        self.dcsValid: np.ndarray = np.zeros(self.dihedraLen, dtype=bool)
        self.hAtoms: np.ndarray = np.zeros((self.hedraLen, 3, 4), dtype=np.float64)
        self.hAtoms[:, :, 3] = 1.0
        self.hAtomsR: np.ndarray = np.copy(self.hAtoms)
        self.hAtoms_needs_update = np.full(self.hedraLen, True)
        a2ha_map = {}
        self.a2h_map = [[] for _ in range(self.AAsiz)]
        h2aa = [[] for _ in range(self.hedraLen)]
        for hk, hndx in self.hedraNdx.items():
            hstep = hndx * 3
            for i in range(3):
                ndx = self.atomArrayIndex[hk[i]]
                a2ha_map[hstep + i] = ndx
            self.hedra[hk].ndx = hndx
            for ak in self.hedra[hk].atomkeys:
                akndx = self.atomArrayIndex[ak]
                h2aa[hndx].append(akndx)
                self.a2h_map[akndx].append(hndx)
        self.a2ha_map = np.array(tuple(a2ha_map.values()))
        self.h2aa = np.array(h2aa)
        self.dAtoms: np.ndarray = np.empty((self.dihedraLen, 4, 4), dtype=np.float64)
        self.dAtoms[:, :, 3] = 1.0
        self.a4_pre_rotation = np.empty((self.dihedraLen, 4))
        a2da_map = {}
        a2d_map = [[[], []] for _ in range(self.AAsiz)]
        self.dRev: np.ndarray = np.zeros(self.dihedraLen, dtype=bool)
        self.dH1ndx = np.empty(self.dihedraLen, dtype=np.int64)
        self.dH2ndx = np.empty(self.dihedraLen, dtype=np.int64)
        self.h1d_map = [[] for _ in range(self.hedraLen)]
        self.id3_dh_index = {k[0:3]: [] for k in self.dihedraNdx.keys()}
        self.id32_dh_index = {k[1:4]: [] for k in self.dihedraNdx.keys()}
        for dk, dndx in self.dihedraNdx.items():
            dstep = dndx * 4
            did3 = dk[0:3]
            did32 = dk[1:4]
            d = self.dihedra[dk]
            for i in range(4):
                ndx = self.atomArrayIndex[dk[i]]
                a2da_map[dstep + i] = ndx
                a2d_map[ndx][0].append(dndx)
                a2d_map[ndx][1].append(i)
            try:
                d.h1key = did3
                d.h2key = did32
                h1ndx = self.hedraNdx[d.h1key]
            except KeyError:
                d.h1key = dk[2::-1]
                d.h2key = dk[3:0:-1]
                h1ndx = self.hedraNdx[d.h1key]
                self.dRev[dndx] = True
                d.reverse = True
            h2ndx = self.hedraNdx[d.h2key]
            d.hedron1 = self.hedra[d.h1key]
            d.hedron2 = self.hedra[d.h2key]
            self.dH1ndx[dndx] = h1ndx
            self.dH2ndx[dndx] = h2ndx
            self.h1d_map[h1ndx].append(dndx)
            d.ndx = dndx
            d.cst = self.dCoordSpace[0][dndx]
            d.rcst = self.dCoordSpace[1][dndx]
            self.id3_dh_index[did3].append(dk)
            self.id32_dh_index[did32].append(dk)
        self.a2da_map = np.array(tuple(a2da_map.values()))
        self.d2a_map = self.a2da_map.reshape(-1, 4)
        self.dFwd = self.dRev != True
        self.a2d_map = [(np.array(xi[0]), np.array(xi[1])) for xi in a2d_map]
        self.dAtoms_needs_update = np.full(self.dihedraLen, True)

    def _hedraDict2chain(self, hl12: Dict[str, float], ha: Dict[str, float], hl23: Dict[str, float], da: Dict[str, float], bfacs: Dict[str, float]) -> None:
        """Generate chain numpy arrays from :func:`.read_PIC` dicts.

        On entry:
            * chain internal_coord has ordered_aa_ic_list built, akset;
            * residues have rnext, rprev, ak_set and di/hedra dicts initialised
            * Chain, residues do NOT have NCaC info, id3_dh_index
            * Di/hedra have cic, atomkeys set
            * Dihedra do NOT have valid reverse flag, h1/2 info

        """
        for ric in self.ordered_aa_ic_list:
            initNCaC = []
            for atm in ric.residue.get_atoms():
                if 2 == atm.is_disordered():
                    if IC_Residue.no_altloc:
                        initNCaC.append(AtomKey(ric, atm.selected_child))
                    else:
                        for altAtom in atm.child_dict.values():
                            if altAtom.coord is not None:
                                initNCaC.append(AtomKey(ric, altAtom))
                elif atm.coord is not None:
                    initNCaC.append(AtomKey(ric, atm))
            if initNCaC != []:
                self.initNCaCs.append(tuple(initNCaC))
            ric.NCaCKey = []
            ric.NCaCKey.extend(ric.split_akl((AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))))
            ric._link_dihedra()
        if self.initNCaCs == []:
            ric = self.ordered_aa_ic_list[0]
            iNCaC = ric.split_akl((AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C')))
            self.initNCaCs.extend(iNCaC)
        self.build_atomArray()
        self.initNCaCs = sorted(self.initNCaCs)
        spNdx, icNdx, resnNdx, atmNdx, altlocNdx, occNdx = AtomKey.fields
        sn = None
        for ak, ndx in self.atomArrayIndex.items():
            res = ak.ric.residue
            atm, altloc = (ak.akl[atmNdx], ak.akl[altlocNdx])
            occ = 1.0 if ak.akl[occNdx] is None else float(ak.akl[occNdx])
            bfac = bfacs.get(ak.id, 0.0)
            sn = sn + 1 if sn is not None else ndx + 1
            bpAtm = None
            if res.has_id(atm):
                bpAtm = res[atm]
            if bpAtm is None or (2 == bpAtm.is_disordered() and (not bpAtm.disordered_has_id(altloc))):
                newAtom = Atom(atm, self.atomArray[ndx][0:3], bfac, occ, ' ' if altloc is None else altloc, atm, sn, atm[0])
                if bpAtm is None:
                    if altloc is None:
                        res.add(newAtom)
                    else:
                        disordered_atom = DisorderedAtom(atm)
                        res.add(disordered_atom)
                        disordered_atom.disordered_add(newAtom)
                        res.flag_disordered()
                else:
                    bpAtm.disordered_add(newAtom)
            else:
                if 2 == bpAtm.is_disordered() and bpAtm.disordered_has_id(altloc):
                    bpAtm.disordered_select(altloc)
                bpAtm.set_bfactor(bfac)
                bpAtm.set_occupancy(occ)
                sn = bpAtm.get_serial_number()
        self.hedraLen = len(ha)
        self.hedraL12 = np.fromiter(hl12.values(), dtype=np.float64)
        self.hedraAngle = np.fromiter(ha.values(), dtype=np.float64)
        self.hedraL23 = np.fromiter(hl23.values(), dtype=np.float64)
        self.hedraNdx = dict(zip(sorted(ha.keys()), range(self.hedraLen)))
        self.dihedraLen = len(da)
        self.dihedraAngle = np.fromiter(da.values(), dtype=np.float64)
        self.dihedraAngleRads = np.deg2rad(self.dihedraAngle)
        self.dihedraNdx = dict(zip(sorted(da.keys()), range(self.dihedraLen)))
        self.build_edraArrays()

    def assemble_residues(self, verbose: bool=False) -> None:
        """Generate atom coords from internal coords (vectorised).

        This is the 'Numpy parallel' version of :meth:`.assemble_residues_ser`.

        Starting with dihedra already formed by :meth:`.init_atom_coords`, transform
        each from dihedron local coordinate space into protein chain coordinate
        space.  Iterate until all dependencies satisfied.

        Does not update :data:`dCoordSpace` as :meth:`assemble_residues_ser`
        does.  Call :meth:`.update_dCoordSpace` if needed.  Faster to do in
        single operation once all atom coordinates finished.

        :param bool verbose: default False.
            Report number of iterations to compute changed dihedra

        generates:
            self.dSet: AAsiz x dihedraLen x 4
                maps atoms in dihedra to atomArray
            self.dSetValid : [dihedraLen][4] of bool
                map of valid atoms into dihedra to detect 3 or 4 atoms valid

        Output coordinates written to :data:`atomArray`.  Biopython
        :class:`Bio.PDB.Atom` coordinates are a view on this data.
        """
        a2da_map = self.a2da_map
        a2d_map = self.a2d_map
        d2a_map = self.d2a_map
        atomArray = self.atomArray
        atomArrayValid = self.atomArrayValid
        dAtoms = self.dAtoms
        dCoordSpace1 = self.dCoordSpace[1]
        dcsValid = self.dcsValid
        self.dSet = atomArray[a2da_map].reshape(-1, 4, 4)
        dSet = self.dSet
        self.dSetValid = atomArrayValid[a2da_map].reshape(-1, 4)
        dSetValid = self.dSetValid
        workSelector = (dSetValid == self._dihedraOK).all(axis=1)
        self.dcsValid[np.logical_not(workSelector)] = False
        dihedraWrk = None
        if verbose:
            dihedraWrk = workSelector.size - workSelector.sum()
        targ = IC_Chain._dihedraSelect
        workSelector = (dSetValid == targ).all(axis=1)
        loopCount = 0
        while np.any(workSelector):
            workNdxs = np.where(workSelector)
            workSet = dSet[workSelector]
            updateMap = d2a_map[workNdxs, 3][0]
            if np.all(dcsValid[workSelector]):
                cspace = dCoordSpace1[workSelector]
            else:
                cspace = multi_coord_space(workSet, np.sum(workSelector), True)[1]
            initCoords = dAtoms[workSelector].reshape(-1, 4, 4)
            atomArray[updateMap] = np.einsum('ijk,ik->ij', cspace, initCoords[:, 3])
            atomArrayValid[updateMap] = True
            workSelector[:] = False
            for a in updateMap:
                dSet[a2d_map[a]] = atomArray[a]
                adlist = a2d_map[a]
                for d in adlist[0]:
                    dvalid = atomArrayValid[d2a_map[d]]
                    workSelector[d] = (dvalid == targ).all()
            loopCount += 1
        if verbose:
            cid = self.chain.full_id
            print(f'{cid[0]} {cid[2]} coordinates for {dihedraWrk} dihedra updated in {loopCount} iterations')

    def assemble_residues_ser(self, verbose: bool=False, start: Optional[int]=None, fin: Optional[int]=None) -> None:
        """Generate IC_Residue atom coords from internal coordinates (serial).

        See :meth:`.assemble_residues` for 'numpy parallel' version.

        Filter positions between start and fin if set, find appropriate start
        coordinates for each residue and pass to :meth:`.assemble`

        :param bool verbose: default False.
            Describe runtime problems
        :param int start,fin: default None.
            Sequence position for begin, end of subregion to generate coords
            for.
        """
        self.dcsValid[:] = False
        for ric in self.ordered_aa_ic_list:
            if fin and fin < ric.residue.id[1] or (start and start > ric.residue.id[1]):
                ric.ak_set = None
                ric.akc = None
                ric.residue.child_dict = {}
                ric.residue.child_list = []
                continue
            atom_coords = ric.assemble(verbose=verbose)
            if atom_coords:
                ric.ak_set = set(atom_coords.keys())

    def init_edra(self, verbose: bool=False) -> None:
        """Create chain and residue di/hedra structures, arrays, atomArray.

        Inputs:
            self.ordered_aa_ic_list : list of IC_Residue
        Generates:
            * edra objects, self.di/hedra (executes :meth:`._create_edra`)
            * atomArray and support (executes :meth:`.build_atomArray`)
            * self.hedraLen : number of hedra in structure
            * hedraL12 : numpy arrays for lengths, angles (empty)
            * hedraAngle ..
            * hedraL23 ..
            * self.hedraNdx : dict mapping hedrakeys to hedraL12 etc
            * self.dihedraLen : number of dihedra in structure
            * dihedraAngle ..
            * dihedraAngleRads : np arrays for angles (empty)
            * self.dihedraNdx : dict mapping dihedrakeys to dihedraAngle
        """
        if self.ordered_aa_ic_list[0].hedra == {}:
            for ric in self.ordered_aa_ic_list:
                ric._create_edra(verbose=verbose)
        if not hasattr(self, 'atomArrayValid'):
            self.build_atomArray()
        if not hasattr(self, 'hedraLen'):
            self.hedraLen = len(self.hedra)
            self.hedraL12 = np.empty(self.hedraLen, dtype=np.float64)
            self.hedraAngle = np.empty(self.hedraLen, dtype=np.float64)
            self.hedraL23 = np.empty(self.hedraLen, dtype=np.float64)
            self.hedraNdx = dict(zip(sorted(self.hedra.keys()), range(len(self.hedra))))
            self.dihedraLen = len(self.dihedra)
            self.dihedraAngle = np.empty(self.dihedraLen)
            self.dihedraAngleRads = np.empty(self.dihedraLen)
            self.dihedraNdx = dict(zip(sorted(self.dihedra.keys()), range(self.dihedraLen)))
        if not hasattr(self, 'hAtoms_needs_update'):
            self.build_edraArrays()

    def init_atom_coords(self) -> None:
        """Set chain level di/hedra initial coords from angles and distances.

        Initializes atom coordinates in local coordinate space for hedra and
        dihedra, will be transformed appropriately later by :data:`dCoordSpace`
        matrices for assembly.
        """
        if not np.all(self.dAtoms_needs_update):
            self.dAtoms_needs_update |= self.hAtoms_needs_update[self.dH1ndx] | self.hAtoms_needs_update[self.dH2ndx]
            self.dcsValid &= np.logical_not(self.dAtoms_needs_update)
        mdFwd = self.dFwd & self.dAtoms_needs_update
        mdRev = self.dRev & self.dAtoms_needs_update
        udFwd = self.dFwd[self.dAtoms_needs_update]
        udRev = self.dRev[self.dAtoms_needs_update]
        '\n        if dbg:\n            print("mdFwd", mdFwd[0:10])\n            print("mdRev", mdRev[0:10])\n            print("udFwd", udFwd[0:10])\n            print("udRev", udRev[0:10])\n        '
        if np.any(self.hAtoms_needs_update):
            sar = np.deg2rad(180.0 - self.hedraAngle[self.hAtoms_needs_update])
            sinSar = np.sin(sar)
            cosSarN = np.cos(sar) * -1
            '\n            if dbg:\n                print("sar", sar[0:10])\n            '
            self.hAtoms[:, 2, 2][self.hAtoms_needs_update] = self.hedraL23[self.hAtoms_needs_update]
            self.hAtoms[:, 0, 0][self.hAtoms_needs_update] = sinSar * self.hedraL12[self.hAtoms_needs_update]
            self.hAtoms[:, 0, 2][self.hAtoms_needs_update] = cosSarN * self.hedraL12[self.hAtoms_needs_update]
            '\n            if dbg:\n                print("hAtoms_needs_update", self.hAtoms_needs_update[0:10])\n                print("self.hAtoms", self.hAtoms[0:10])\n            '
            self.hAtomsR[:, 0, 2][self.hAtoms_needs_update] = self.hedraL12[self.hAtoms_needs_update]
            self.hAtomsR[:, 2, 0][self.hAtoms_needs_update] = sinSar * self.hedraL23[self.hAtoms_needs_update]
            self.hAtomsR[:, 2, 2][self.hAtoms_needs_update] = cosSarN * self.hedraL23[self.hAtoms_needs_update]
            '\n            if dbg:\n                print("self.hAtomsR", self.hAtomsR[0:10])\n            '
            self.hAtoms_needs_update[...] = False
            dhlen = np.sum(self.dAtoms_needs_update)
            self.a4_pre_rotation[mdRev] = self.hAtoms[self.dH2ndx, 0][mdRev]
            self.a4_pre_rotation[mdFwd] = self.hAtomsR[self.dH2ndx, 2][mdFwd]
            self.a4_pre_rotation[:, 2][self.dAtoms_needs_update] = np.multiply(self.a4_pre_rotation[:, 2][self.dAtoms_needs_update], -1)
            a4shift = np.empty(dhlen)
            a4shift[udRev] = self.hedraL23[self.dH2ndx][mdRev]
            a4shift[udFwd] = self.hedraL12[self.dH2ndx][mdFwd]
            self.a4_pre_rotation[:, 2][self.dAtoms_needs_update] = np.add(self.a4_pre_rotation[:, 2][self.dAtoms_needs_update], a4shift)
            '\n            if dbg:\n                print("dhlen", dhlen)\n                print("a4shift", a4shift[0:10])\n                print("a4_pre_rotation", self.a4_pre_rotation[0:10])\n            '
            dH1atoms = self.hAtoms[self.dH1ndx]
            dH1atomsR = self.hAtomsR[self.dH1ndx]
            self.dAtoms[:, :3][mdFwd] = dH1atoms[mdFwd]
            self.dAtoms[:, :3][mdRev] = dH1atomsR[:, 2::-1][mdRev]
            '\n            if dbg:\n                print("dH1atoms", dH1atoms[0:10])\n                print("dH1atosR", dH1atomsR[0:10])\n                print("dAtoms", self.dAtoms[0:10])\n            '
        '\n        if dbg:\n            print("dangle-rads", self.dihedraAngleRads[0:10])\n        '
        rz = multi_rot_Z(self.dihedraAngleRads[self.dAtoms_needs_update])
        a4rot = np.matmul(rz, self.a4_pre_rotation[self.dAtoms_needs_update][:].reshape(-1, 4, 1)).reshape(-1, 4)
        self.dAtoms[:, 3][mdFwd] = a4rot[udFwd]
        self.dAtoms[:, 3][mdRev] = a4rot[udRev]
        '\n        if dbg:\n            print("rz", rz[0:3])\n            print("dAtoms", self.dAtoms[0:10])\n        '
        self.dAtoms_needs_update[...] = False
        '\n        if dbg:\n            print("initNCaCs", self.initNCaCs)\n        '
        for iNCaC in self.initNCaCs:
            invalid = True
            if np.all(self.atomArrayValid[[self.atomArrayIndex[ak] for ak in iNCaC]]):
                invalid = False
            if invalid:
                hatoms = self.hAtoms[self.hedraNdx[iNCaC]]
                for i in range(3):
                    andx = self.atomArrayIndex[iNCaC[i]]
                    self.atomArray[andx] = hatoms[i]
                    self.atomArrayValid[andx] = True
            '\n            if dbg:\n                hatoms = self.hAtoms[self.hedraNdx[iNCaC]]\n                print("hedraNdx iNCaC", self.hedraNdx[iNCaC])\n                print("hatoms", hatoms)\n            '

    def update_dCoordSpace(self, workSelector: Optional[np.ndarray]=None) -> None:
        """Compute/update coordinate space transforms for chain dihedra.

        Requires all atoms updated so calls :meth:`.assemble_residues`
        (returns immediately if all atoms already assembled).

        :param [bool] workSelector:
            Optional mask to select dihedra for update
        """
        if workSelector is None:
            self.assemble_residues()
            workSelector = np.logical_not(self.dcsValid)
        workSet = self.dSet[workSelector]
        self.dCoordSpace[:, workSelector] = multi_coord_space(workSet, np.sum(workSelector), True)
        self.dcsValid[workSelector] = True

    def propagate_changes(self) -> None:
        """Track through di/hedra to invalidate dependent atoms."""
        csNdx = 0
        csLen = len(self.initNCaCs)
        atmNdx = AtomKey.fields.atm
        posNdx = AtomKey.fields.respos
        done = set()
        while csNdx < csLen:
            startAK = self.initNCaCs[csNdx][0]
            csStart = self.atomArrayIndex[startAK]
            csnTry = csNdx + 1
            if csLen == csnTry:
                csNext = self.AAsiz
            else:
                finAK = self.initNCaCs[csnTry][0]
                csNext = self.atomArrayIndex[finAK]
            for andx in range(csStart, csNext):
                if not self.atomArrayValid[andx]:
                    ak = self.aktuple[andx]
                    atm = ak.akl[atmNdx]
                    pos = ak.akl[posNdx]
                    if atm in ('N', 'CA', 'C'):
                        self.atomArrayValid[andx:csNext] = False
                        break
                    elif pos not in done and atm != 'H':
                        for i in range(andx, csNext):
                            if self.aktuple[i].akl[posNdx] == pos:
                                self.atomArrayValid[i] = False
                            else:
                                break
                        done.add(pos)
            csNdx += 1

    def internal_to_atom_coordinates(self, verbose: bool=False, start: Optional[int]=None, fin: Optional[int]=None) -> None:
        """Process IC data to Residue/Atom coords.

        :param bool verbose: default False.
            Describe runtime problems
        :param int start,fin:
            Optional sequence positions for begin, end of subregion
            to process.

        .. note::
            Setting start or fin activates serial :meth:`.assemble_residues_ser`
            instead of (Numpy parallel) :meth:`.assemble_residues`.
            Start C-alpha will be at origin.

        .. seealso::
            :data:`ParallelAssembleResidues`

        """
        if not hasattr(self, 'dAtoms_needs_update'):
            return
        if IC_Chain.ParallelAssembleResidues and (not (start or fin)):
            self.propagate_changes()
            self.init_atom_coords()
            self.assemble_residues(verbose=verbose)
            if verbose and (not np.all(self.atomArrayValid)):
                dSetValid = self.atomArrayValid[self.a2da_map].reshape(-1, 4)
                for ric in self.ordered_aa_ic_list:
                    for d in ric.dihedra.values():
                        if not dSetValid[d.ndx].all():
                            print(f'missing coordinates for chain {ric.cic.chain.id} {ric.pretty_str()} dihedral: {d.id}')
        else:
            if start:
                for ric in self.ordered_aa_ic_list:
                    if start != ric.residue.id[1]:
                        continue
                    iNCaC = ric.split_akl((AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C')))
                    self.initNCaCs.extend(iNCaC)
            self.init_atom_coords()
            self.assemble_residues_ser(verbose=verbose, start=start, fin=fin)

    def atom_to_internal_coordinates(self, verbose: bool=False) -> None:
        """Calculate dihedrals, angles, bond lengths for Atom data.

        Generates atomArray (through init_edra), value arrays for hedra and
        dihedra, and coordinate space transforms for dihedra.

        Generates Gly C-beta if specified, see :data:`IC_Residue.gly_Cbeta`

        :param bool verbose: default False.
            describe runtime problems
        """
        if self.ordered_aa_ic_list == []:
            return
        self.init_edra(verbose=verbose)
        if self.dihedra == {}:
            return
        ha = self.atomArray[self.a2ha_map].reshape(-1, 3, 4)
        self.hedraL12 = np.linalg.norm(ha[:, 0] - ha[:, 1], axis=1)
        self.hedraL23 = np.linalg.norm(ha[:, 1] - ha[:, 2], axis=1)
        h_a0a2 = np.linalg.norm(ha[:, 0] - ha[:, 2], axis=1)
        np.rad2deg(np.arccos((np.square(self.hedraL12) + np.square(self.hedraL23) - np.square(h_a0a2)) / (2 * self.hedraL12 * self.hedraL23)), out=self.hedraAngle)
        dha = self.atomArray[self.a2da_map].reshape(-1, 4, 4)
        self.dCoordSpace[...] = multi_coord_space(dha, self.dihedraLen, True)
        self.dcsValid[:] = True
        do4 = np.matmul(self.dCoordSpace[0], dha[:, 3].reshape(-1, 4, 1)).reshape(-1, 4)
        np.arctan2(do4[:, 1], do4[:, 0], out=self.dihedraAngleRads)
        np.rad2deg(self.dihedraAngleRads, out=self.dihedraAngle)
        if hasattr(self, 'gcb'):
            self._spec_glyCB()

    def _spec_glyCB(self) -> None:
        """Populate values for Gly C-beta."""
        Ca_Cb_Len = 1.53363
        if hasattr(self, 'scale'):
            Ca_Cb_Len *= self.scale
        for gcbd in self.gcb.values():
            cbak = gcbd[3]
            self.atomArrayValid[self.atomArrayIndex[cbak]] = False
            ric = cbak.ric
            rN, rCA, rC, rO = (ric.rak('N'), ric.rak('CA'), ric.rak('C'), ric.rak('O'))
            gCBd = self.dihedra[gcbd]
            dndx = gCBd.ndx
            h2ndx = gCBd.hedron2.ndx
            self.hedraL12[h2ndx] = Ca_Cb_Len
            self.hedraAngle[h2ndx] = 110.17513
            self.hedraL23[h2ndx] = self.hedraL12[self.hedraNdx[rCA, rC, rO]]
            self.hAtoms_needs_update[gCBd.hedron2.ndx] = True
            for ak in gCBd.hedron2.atomkeys:
                self.atomArrayValid[self.atomArrayIndex[ak]] = False
            refval = self.dihedra.get((rN, rCA, rC, rO), None)
            if refval:
                angl = 122.68219 + self.dihedraAngle[refval.ndx]
                self.dihedraAngle[dndx] = angl if angl <= 180.0 else angl - 360.0
            else:
                self.dihedraAngle[dndx] = 120

    @staticmethod
    def _write_mtx(fp: TextIO, mtx: np.array) -> None:
        fp.write('[ ')
        rowsStarted = False
        for row in mtx:
            if rowsStarted:
                fp.write(', [ ')
            else:
                fp.write('[ ')
                rowsStarted = True
            colsStarted = False
            for col in row:
                if colsStarted:
                    fp.write(', ' + str(col))
                else:
                    fp.write(str(col))
                    colsStarted = True
            fp.write(' ]')
        fp.write(' ]')

    @staticmethod
    def _writeSCAD_dihed(fp: TextIO, d: 'Dihedron', hedraNdx: Dict, hedraSet: Set[EKT]) -> None:
        fp.write('[ {:9.5f}, {}, {}, {}, '.format(d.angle, hedraNdx[d.h1key], hedraNdx[d.h2key], 1 if d.reverse else 0))
        fp.write(f'{(0 if d.h1key in hedraSet else 1)}, {(0 if d.h2key in hedraSet else 1)}, ')
        fp.write('    // {} [ {} -- {} ] {}\n'.format(d.id, d.hedron1.id, d.hedron2.id, 'reversed' if d.reverse else ''))
        fp.write('        ')
        IC_Chain._write_mtx(fp, d.rcst)
        fp.write(' ]')

    def _write_SCAD(self, fp: TextIO, backboneOnly: bool, start=None, fin=None) -> None:
        """Write self to file fp as OpenSCAD data matrices.

        See `OpenSCAD <https://www.openscad.org>`_.
        Works with :func:`.write_SCAD` and embedded OpenSCAD routines therein.
        """
        fp.write(f'   "{self.chain.id}", // chain id\n')
        hedra = {}
        for ric in self.ordered_aa_ic_list:
            respos = ric.residue.id[1]
            if start is not None and respos < start - 1:
                continue
            if fin is not None and respos > fin:
                continue
            for k, h in ric.hedra.items():
                hedra[k] = h
        atomSet: Set[AtomKey] = set()
        bondDict: Dict = {}
        hedraSet: Set[EKT] = set()
        ndx = 0
        hedraNdx = {}
        for hk in sorted(hedra):
            hedraNdx[hk] = ndx
            ndx += 1
        fp.write('   [  // residue array of dihedra')
        resNdx = {}
        dihedraNdx = {}
        ndx = 0
        chnStarted = False
        for ric in self.ordered_aa_ic_list:
            respos = ric.residue.id[1]
            if start is not None and respos < start:
                continue
            if fin is not None and respos > fin:
                continue
            if 'O' not in ric.akc:
                if ric.lc != 'G' and ric.lc != 'A':
                    print(f'Unable to generate complete sidechain for {ric} {ric.lc} missing O atom')
            resNdx[ric] = ndx
            if chnStarted:
                fp.write('\n     ],')
            else:
                chnStarted = True
            fp.write('\n     [ // ' + str(ndx) + ' : ' + str(ric.residue.id) + ' ' + ric.lc + ' backbone\n')
            ndx += 1
            ric.clear_transforms()
            ric.assemble(resetLocation=True)
            ndx2 = 0
            started = False
            for i in range(1 if backboneOnly else 2):
                if i == 1:
                    cma = ',' if started else ''
                    fp.write(f'{cma}\n       // {ric.residue.id!s} {ric.lc} sidechain\n')
                started = False
                for dk, d in sorted(ric.dihedra.items()):
                    if d.h2key in hedraNdx and (i == 0 and d.is_backbone() or (i == 1 and (not d.is_backbone()))):
                        if d.cic.dcsValid[d.ndx]:
                            if started:
                                fp.write(',\n')
                            else:
                                started = True
                            fp.write('      ')
                            IC_Chain._writeSCAD_dihed(fp, d, hedraNdx, hedraSet)
                            dihedraNdx[dk] = ndx2
                            hedraSet.add(d.h1key)
                            hedraSet.add(d.h2key)
                            ndx2 += 1
                        else:
                            print(f'Atom missing for {d.id3}-{d.id32}, OpenSCAD chain may be discontiguous')
        fp.write('   ],')
        fp.write('\n  ],\n')
        fp.write('   [  //hedra\n')
        for hk in sorted(hedra):
            hed = hedra[hk]
            fp.write('     [ ')
            fp.write('{:9.5f}, {:9.5f}, {:9.5f}'.format(set_accuracy_95(hed.len12), set_accuracy_95(hed.angle), set_accuracy_95(hed.len23)))
            atom_str = ''
            atom_done_str = ''
            akndx = 0
            for ak in hed.atomkeys:
                atm = ak.akl[AtomKey.fields.atm]
                res = ak.akl[AtomKey.fields.resname]
                ab_state_res = residue_atom_bond_state['X']
                ab_state = ab_state_res.get(atm, None)
                if 'H' == atm[0]:
                    ab_state = 'Hsb'
                if ab_state is None:
                    ab_state_res = residue_atom_bond_state.get(res, None)
                    if ab_state_res is not None:
                        ab_state = ab_state_res.get(atm, '')
                    else:
                        ab_state = ''
                atom_str += ', "' + ab_state + '"'
                if ak in atomSet:
                    atom_done_str += ', 0'
                elif hk in hedraSet:
                    if (hasattr(hed, 'flex_female_1') or hasattr(hed, 'flex_male_1')) and akndx != 2:
                        if akndx == 0:
                            atom_done_str += ', 0'
                        elif akndx == 1:
                            atom_done_str += ', 1'
                            atomSet.add(ak)
                    elif (hasattr(hed, 'flex_female_2') or hasattr(hed, 'flex_male_2')) and akndx != 0:
                        if akndx == 2:
                            atom_done_str += ', 0'
                        elif akndx == 1:
                            atom_done_str += ', 1'
                            atomSet.add(ak)
                    else:
                        atom_done_str += ', 1'
                        atomSet.add(ak)
                else:
                    atom_done_str += ', 0'
                akndx += 1
            fp.write(atom_str)
            fp.write(atom_done_str)
            bond = []
            bond.append(hed.atomkeys[0].id + '-' + hed.atomkeys[1].id)
            bond.append(hed.atomkeys[1].id + '-' + hed.atomkeys[2].id)
            b0 = True
            for b in bond:
                wstr = ''
                if b in bondDict and bondDict[b] == 'StdBond':
                    wstr = ', 0'
                elif hk in hedraSet:
                    bondType = 'StdBond'
                    if b0:
                        if hasattr(hed, 'flex_female_1'):
                            bondType = 'FemaleJoinBond'
                        elif hasattr(hed, 'flex_male_1'):
                            bondType = 'MaleJoinBond'
                        elif hasattr(hed, 'skinny_1'):
                            bondType = 'SkinnyBond'
                        elif hasattr(hed, 'hbond_1'):
                            bondType = 'HBond'
                    elif hasattr(hed, 'flex_female_2'):
                        bondType = 'FemaleJoinBond'
                    elif hasattr(hed, 'flex_male_2'):
                        bondType = 'MaleJoinBond'
                    elif hasattr(hed, 'hbond_2'):
                        bondType = 'HBond'
                    if b in bondDict:
                        bondDict[b] = 'StdBond'
                    else:
                        bondDict[b] = bondType
                    wstr = ', ' + str(bondType)
                else:
                    wstr = ', 0'
                fp.write(wstr)
                b0 = False
            akl = hed.atomkeys[0].akl
            fp.write(', "' + akl[AtomKey.fields.resname] + '", ' + akl[AtomKey.fields.respos] + ', "' + hed.e_class + '"')
            fp.write(' ], // ' + str(hk) + '\n')
        fp.write('   ],\n')
        self.atomArrayValid[:] = False
        self.internal_to_atom_coordinates()
        fp.write('\n[  // chain - world transform for each residue\n')
        chnStarted = False
        for ric in self.ordered_aa_ic_list:
            respos = ric.residue.id[1]
            if start is not None and respos < start:
                continue
            if fin is not None and respos > fin:
                continue
            for k, h in ric.hedra.items():
                hedra[k] = h
            for NCaCKey in sorted(ric.NCaCKey):
                mtr = None
                if 0 < len(ric.rprev):
                    acl = [self.atomArray[self.atomArrayIndex[ak]] for ak in NCaCKey]
                    mt, mtr = coord_space(acl[0], acl[1], acl[2], True)
                else:
                    mtr = np.identity(4, dtype=np.float64)
                if chnStarted:
                    fp.write(',\n')
                else:
                    chnStarted = True
                fp.write('     [ ' + str(resNdx[ric]) + ', "' + str(ric.residue.id[1]))
                fp.write(ric.lc + '", //' + str(NCaCKey) + '\n')
                IC_Chain._write_mtx(fp, mtr)
                fp.write(' ]')
        fp.write('\n   ]\n')

    def distance_plot(self, filter: Optional[Union[np.ndarray, None]]=None) -> np.ndarray:
        """Generate 2D distance plot from atomArray.

        Default is to calculate distances for all atoms.  To generate the
        classic C-alpha distance plot, pass a boolean mask array like::

            atmNameNdx = internal_coords.AtomKey.fields.atm
            CaSelect = [
                atomArrayIndex.get(k)
                for k in atomArrayIndex.keys()
                if k.akl[atmNameNdx] == "CA"
            ]
            plot = cic.distance_plot(CaSelect)

        Alternatively, this will select all backbone atoms::

            backboneSelect = [
                atomArrayIndex.get(k)
                for k in atomArrayIndex.keys()
                if k.is_backbone()
            ]

        :param [bool] filter: restrict atoms for calculation

        .. seealso::
            :meth:`.distance_to_internal_coordinates`, which requires the
            default all atom distance plot.

        """
        if filter is None:
            atomSet = self.atomArray
        else:
            atomSet = self.atomArray[filter]
        return np.linalg.norm(atomSet[:, None, :] - atomSet[None, :, :], axis=-1)

    def dihedral_signs(self) -> np.ndarray:
        """Get sign array (+1/-1) for each element of chain dihedraAngle array.

        Required for :meth:`.distance_to_internal_coordinates`
        """
        return np.sign(self.dihedraAngle)

    def distplot_to_dh_arrays(self, distplot: np.ndarray, dihedra_signs: np.ndarray) -> None:
        """Load di/hedra distance arays from distplot.

        Fill :class:`IC_Chain` arrays hedraL12, L23, L13 and dihedraL14
        distance value arrays from input distplot, dihedra_signs array from
        input dihedra_signs.  Distplot and di/hedra distance arrays must index
        according to AtomKey mappings in :class:`IC_Chain` .hedraNdx and .dihedraNdx
        (created in :meth:`IC_Chain.init_edra`)

        Call :meth:`atom_to_internal_coordinates` (or at least :meth:`init_edra`)
        to generate a2ha_map and d2a_map before running this.

        Explcitly removed from :meth:`.distance_to_internal_coordinates` so
        user may populate these chain di/hedra arrays by other
        methods.
        """
        ha = self.a2ha_map.reshape(-1, 3)
        self.hedraL12 = distplot[ha[:, 0], ha[:, 1]]
        self.hedraL23 = distplot[ha[:, 1], ha[:, 2]]
        self.hedraL13 = distplot[ha[:, 0], ha[:, 2]]
        da = self.d2a_map
        self.dihedraL14 = distplot[da[:, 0], da[:, 3]]
        self.dihedra_signs = dihedra_signs

    def distance_to_internal_coordinates(self, resetAtoms: Optional[Union[bool, None]]=True) -> None:
        """Compute chain di/hedra from from distance and chirality data.

        Distance properties on hedra L12, L23, L13 and dihedra L14 configured
        by :meth:`.distplot_to_dh_arrays` or alternative loader.

        dihedraAngles result is multiplied by dihedra_signs at final step
        recover chirality information lost in distance plot (mirror image of
        structure has same distances but opposite sign dihedral angles).

        Note that chain breaks will cause errors in rebuilt structure, use
        :meth:`.copy_initNCaCs` to avoid this

        Based on Blue, the Hedronometer's answer to `The dihedral angles of a tetrahedron
        in terms of its edge lengths <https://math.stackexchange.com/a/49340/972353>`_
        on `math.stackexchange.com <https://math.stackexchange.com/>`_.  See also:
        `"Heron-like Hedronometric Results for Tetrahedral Volume"
        <http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf>`_.

        Other values from that analysis included here as comments for
        completeness:

        * oa = hedron1 L12 if reverse else hedron1 L23
        * ob = hedron1 L23 if reverse else hedron1 L12
        * ac = hedron2 L12 if reverse else hedron2 L23
        * ab = hedron1 L13 = law of cosines on OA, OB (hedron1 L12, L23)
        * oc = hedron2 L13 = law of cosines on OA, AC (hedron2 L12, L23)
        * bc = dihedron L14

        target is OA, the dihedral angle along edge oa.

        :param bool resetAtoms: default True.
            Mark all atoms in di/hedra and atomArray for updating by
            :meth:`.internal_to_atom_coordinates`.  Alternatvely set this to
            False and manipulate `atomArrayValid`, `dAtoms_needs_update` and
            `hAtoms_needs_update` directly to reduce computation.
        """
        oa = self.hedraL12[self.dH1ndx]
        oa[self.dFwd] = self.hedraL23[self.dH1ndx][self.dFwd]
        ob = self.hedraL23[self.dH1ndx]
        ob[self.dFwd] = self.hedraL12[self.dH1ndx][self.dFwd]
        ac = self.hedraL12[self.dH2ndx]
        ac[self.dFwd] = self.hedraL23[self.dH2ndx][self.dFwd]
        ab = self.hedraL13[self.dH1ndx]
        oc = self.hedraL13[self.dH2ndx]
        bc = self.dihedraL14
        Ys = (oa + ac + oc) / 2
        Zs = (oa + ob + ab) / 2
        Ysqr = Ys * (Ys - oa) * (Ys - ac) * (Ys - oc)
        Zsqr = Zs * (Zs - oa) * (Zs - ob) * (Zs - ab)
        Hsqr = (4 * oa * oa * bc * bc - np.square(ob * ob + ac * ac - (oc * oc + ab * ab))) / 16
        '\n        Jsqr = (\n            4 * ob * ob * ac * ac\n            - np.square((oc * oc + ab * ab) - (oa * oa + bc * bc))\n        ) / 16\n        Ksqr = (\n            4 * oc * oc * ab * ab\n            - np.square((oa * oa + bc * bc) - (ob * ob + ac * ac))\n        ) / 16\n        '
        Y = np.sqrt(Ysqr)
        Z = np.sqrt(Zsqr)
        cosOA = (Ysqr + Zsqr - Hsqr) / (2 * Y * Z)
        cosOA[cosOA < -1.0] = -1.0
        cosOA[cosOA > 1.0] = 1.0
        np.arccos(cosOA, out=self.dihedraAngleRads, dtype=np.longdouble)
        self.dihedraAngleRads *= self.dihedra_signs
        np.rad2deg(self.dihedraAngleRads, out=self.dihedraAngle)
        np.rad2deg(np.arccos((np.square(self.hedraL12) + np.square(self.hedraL23) - np.square(self.hedraL13)) / (2 * self.hedraL12 * self.hedraL23)), out=self.hedraAngle)
        if resetAtoms:
            self.atomArrayValid[:] = False
            self.dAtoms_needs_update[:] = True
            self.hAtoms_needs_update[:] = True

    def copy_initNCaCs(self, other: 'IC_Chain') -> None:
        """Copy atom coordinates for initNCaC atoms from other IC_Chain.

        Copies the coordinates and sets atomArrayValid flags True for initial
        NCaC and after any chain breaks.

        Needed for :meth:`.distance_to_internal_coordinates` if target has
        chain breaks (otherwise each fragment will start at origin).

        Also useful if copying internal coordinates from another chain.

        N.B. :meth:`IC_Residue.set_angle()` and :meth:`IC_Residue.set_length()`
        invalidate their relevant atoms, so apply them before calling this
        function.
        """
        ndx = [self.atomArrayIndex[ak] for iNCaC in other.initNCaCs for ak in iNCaC]
        self.atomArray[ndx] = other.atomArray[ndx]
        self.atomArrayValid[ndx] = True

    def make_extended(self):
        """Set all psi and phi angles to extended conformation (123, -104)."""
        for ric in self.ordered_aa_ic_list:
            ric.set_angle('psi', 123)
            ric.set_angle('phi', -104)