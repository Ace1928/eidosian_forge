import os
from copy import copy
from io import BytesIO
import patiencediff
from ..lazy_import import lazy_import
from breezy import tsort
from .. import errors, osutils
from .. import transport as _mod_transport
from ..errors import RevisionAlreadyPresent, RevisionNotPresent
from ..osutils import dirname, sha, sha_strings, split_lines
from ..revision import NULL_REVISION
from ..trace import mutter
from .versionedfile import (AbsentContentFactory, ContentFactory,
from .weavefile import _read_weave_v5, write_weave_v5
class Weave(VersionedFile):
    """weave - versioned text file storage.

    A Weave manages versions of line-based text files, keeping track
    of the originating version for each line.

    To clients the "lines" of the file are represented as a list of strings.
    These strings  will typically have terminal newline characters, but
    this is not required.  In particular files commonly do not have a newline
    at the end of the file.

    Texts can be identified in either of two ways:

    * a nonnegative index number.

    * a version-id string.

    Typically the index number will be valid only inside this weave and
    the version-id is used to reference it in the larger world.

    The weave is represented as a list mixing edit instructions and
    literal text.  Each entry in _weave can be either a string (or
    unicode), or a tuple.  If a string, it means that the given line
    should be output in the currently active revisions.

    If a tuple, it gives a processing instruction saying in which
    revisions the enclosed lines are active.  The tuple has the form
    (instruction, version).

    The instruction can be '{' or '}' for an insertion block, and '['
    and ']' for a deletion block respectively.  The version is the
    integer version index.  There is no replace operator, only deletes
    and inserts.  For '}', the end of an insertion, there is no
    version parameter because it always closes the most recently
    opened insertion.

    Constraints/notes:

    * A later version can delete lines that were introduced by any
      number of ancestor versions; this implies that deletion
      instructions can span insertion blocks without regard to the
      insertion block's nesting.

    * Similarly, deletions need not be properly nested with regard to
      each other, because they might have been generated by
      independent revisions.

    * Insertions are always made by inserting a new bracketed block
      into a single point in the previous weave.  This implies they
      can nest but not overlap, and the nesting must always have later
      insertions on the inside.

    * It doesn't seem very useful to have an active insertion
      inside an inactive insertion, but it might happen.

    * Therefore, all instructions are always"considered"; that
      is passed onto and off the stack.  An outer inactive block
      doesn't disable an inner block.

    * Lines are enabled if the most recent enclosing insertion is
      active and none of the enclosing deletions are active.

    * There is no point having a deletion directly inside its own
      insertion; you might as well just not write it.  And there
      should be no way to get an earlier version deleting a later
      version.

    _weave
        Text of the weave; list of control instruction tuples and strings.

    _parents
        List of parents, indexed by version number.
        It is only necessary to store the minimal set of parents for
        each version; the parent's parents are implied.

    _sha1s
        List of hex SHA-1 of each version.

    _names
        List of symbolic names for each version.  Each should be unique.

    _name_map
        For each name, the version number.

    _weave_name
        Descriptive name of this weave; typically the filename if known.
        Set by read_weave.
    """
    __slots__ = ['_weave', '_parents', '_sha1s', '_names', '_name_map', '_weave_name', '_matcher', '_allow_reserved']

    def __init__(self, weave_name=None, access_mode='w', matcher=None, get_scope=None, allow_reserved=False):
        """Create a weave.

        :param get_scope: A callable that returns an opaque object to be used
            for detecting when this weave goes out of scope (should stop
            answering requests or allowing mutation).
        """
        super().__init__()
        self._weave = []
        self._parents = []
        self._sha1s = []
        self._names = []
        self._name_map = {}
        self._weave_name = weave_name
        if matcher is None:
            self._matcher = patiencediff.PatienceSequenceMatcher
        else:
            self._matcher = matcher
        if get_scope is None:

            def get_scope():
                return None
        self._get_scope = get_scope
        self._scope = get_scope()
        self._access_mode = access_mode
        self._allow_reserved = allow_reserved

    def __repr__(self):
        return 'Weave(%r)' % self._weave_name

    def _check_write_ok(self):
        """Is the versioned file marked as 'finished' ? Raise if it is."""
        if self._get_scope() != self._scope:
            raise errors.OutSideTransaction()
        if self._access_mode != 'w':
            raise errors.ReadOnlyObjectDirtiedError(self)

    def copy(self):
        """Return a deep copy of self.

        The copy can be modified without affecting the original weave."""
        other = Weave()
        other._weave = self._weave[:]
        other._parents = self._parents[:]
        other._sha1s = self._sha1s[:]
        other._names = self._names[:]
        other._name_map = self._name_map.copy()
        other._weave_name = self._weave_name
        return other

    def __eq__(self, other):
        if not isinstance(other, Weave):
            return False
        return self._parents == other._parents and self._weave == other._weave and (self._sha1s == other._sha1s)

    def __ne__(self, other):
        return not self.__eq__(other)

    def _idx_to_name(self, version):
        return self._names[version]

    def _lookup(self, name):
        """Convert symbolic version name to index."""
        if not self._allow_reserved:
            self.check_not_reserved_id(name)
        try:
            return self._name_map[name]
        except KeyError:
            raise RevisionNotPresent(name, self._weave_name)

    def versions(self):
        """See VersionedFile.versions."""
        return self._names[:]

    def has_version(self, version_id):
        """See VersionedFile.has_version."""
        return version_id in self._name_map
    __contains__ = has_version

    def get_record_stream(self, versions, ordering, include_delta_closure):
        """Get a stream of records for versions.

        :param versions: The versions to include. Each version is a tuple
            (version,).
        :param ordering: Either 'unordered' or 'topological'. A topologically
            sorted stream has compression parents strictly before their
            children.
        :param include_delta_closure: If True then the closure across any
            compression parents will be included (in the opaque data).
        :return: An iterator of ContentFactory objects, each of which is only
            valid until the iterator is advanced.
        """
        versions = [version[-1] for version in versions]
        if ordering == 'topological':
            parents = self.get_parent_map(versions)
            new_versions = tsort.topo_sort(parents)
            new_versions.extend(set(versions).difference(set(parents)))
            versions = new_versions
        elif ordering == 'groupcompress':
            parents = self.get_parent_map(versions)
            new_versions = sort_groupcompress(parents)
            new_versions.extend(set(versions).difference(set(parents)))
            versions = new_versions
        for version in versions:
            if version in self:
                yield WeaveContentFactory(version, self)
            else:
                yield AbsentContentFactory((version,))

    def get_parent_map(self, version_ids):
        """See VersionedFile.get_parent_map."""
        result = {}
        for version_id in version_ids:
            if version_id == NULL_REVISION:
                parents = ()
            else:
                try:
                    parents = tuple(map(self._idx_to_name, self._parents[self._lookup(version_id)]))
                except RevisionNotPresent:
                    continue
            result[version_id] = parents
        return result

    def get_parents_with_ghosts(self, version_id):
        raise NotImplementedError(self.get_parents_with_ghosts)

    def insert_record_stream(self, stream):
        """Insert a record stream into this versioned file.

        :param stream: A stream of records to insert.
        :return: None
        :seealso VersionedFile.get_record_stream:
        """
        adapters = {}
        for record in stream:
            if record.storage_kind == 'absent':
                raise RevisionNotPresent([record.key[0]], self)
            parents = [parent[0] for parent in record.parents]
            if record.storage_kind in ('fulltext', 'chunked', 'lines'):
                self.add_lines(record.key[0], parents, record.get_bytes_as('lines'))
            else:
                adapter_key = (record.storage_kind, 'lines')
                try:
                    adapter = adapters[adapter_key]
                except KeyError:
                    adapter_factory = adapter_registry.get(adapter_key)
                    adapter = adapter_factory(self)
                    adapters[adapter_key] = adapter
                lines = adapter.get_bytes(record, 'lines')
                try:
                    self.add_lines(record.key[0], parents, lines)
                except RevisionAlreadyPresent:
                    pass

    def _check_repeated_add(self, name, parents, text, sha1):
        """Check that a duplicated add is OK.

        If it is, return the (old) index; otherwise raise an exception.
        """
        idx = self._lookup(name)
        if sorted(self._parents[idx]) != sorted(parents) or sha1 != self._sha1s[idx]:
            raise RevisionAlreadyPresent(name, self._weave_name)
        return idx

    def _add_lines(self, version_id, parents, lines, parent_texts, left_matching_blocks, nostore_sha, random_id, check_content):
        """See VersionedFile.add_lines."""
        idx = self._add(version_id, lines, list(map(self._lookup, parents)), nostore_sha=nostore_sha)
        return (sha_strings(lines), sum(map(len, lines)), idx)

    def _add(self, version_id, lines, parents, sha1=None, nostore_sha=None):
        """Add a single text on top of the weave.

        Returns the index number of the newly added version.

        version_id
            Symbolic name for this version.
            (Typically the revision-id of the revision that added it.)
            If None, a name will be allocated based on the hash. (sha1:SHAHASH)

        parents
            List or set of direct parent version numbers.

        lines
            Sequence of lines to be added in the new version.

        :param nostore_sha: See VersionedFile.add_lines.
        """
        self._check_lines_not_unicode(lines)
        self._check_lines_are_lines(lines)
        if not sha1:
            sha1 = sha_strings(lines)
        if sha1 == nostore_sha:
            raise ExistingContent
        if version_id is None:
            version_id = b'sha1:' + sha1
        if version_id in self._name_map:
            return self._check_repeated_add(version_id, parents, lines, sha1)
        self._check_versions(parents)
        new_version = len(self._parents)
        self._parents.append(parents[:])
        self._sha1s.append(sha1)
        self._names.append(version_id)
        self._name_map[version_id] = new_version
        if not parents:
            if lines:
                self._weave.append((b'{', new_version))
                self._weave.extend(lines)
                self._weave.append((b'}', None))
            return new_version
        if len(parents) == 1:
            pv = list(parents)[0]
            if sha1 == self._sha1s[pv]:
                return new_version
        ancestors = self._inclusions(parents)
        l = self._weave
        basis_lineno = []
        basis_lines = []
        for origin, lineno, line in self._extract(ancestors):
            basis_lineno.append(lineno)
            basis_lines.append(line)
        if lines == basis_lines:
            return new_version
        basis_lineno.append(len(self._weave))
        s = self._matcher(None, basis_lines, lines)
        offset = 0
        for tag, i1, i2, j1, j2 in s.get_opcodes():
            if tag == 'equal':
                continue
            i1 = basis_lineno[i1]
            i2 = basis_lineno[i2]
            if i1 != i2:
                self._weave.insert(i1 + offset, (b'[', new_version))
                self._weave.insert(i2 + offset + 1, (b']', new_version))
                offset += 2
            if j1 != j2:
                i = i2 + offset
                self._weave[i:i] = [(b'{', new_version)] + lines[j1:j2] + [(b'}', None)]
                offset += 2 + (j2 - j1)
        return new_version

    def _inclusions(self, versions):
        """Return set of all ancestors of given version(s)."""
        if not len(versions):
            return set()
        i = set(versions)
        for v in range(max(versions), 0, -1):
            if v in i:
                i.update(self._parents[v])
        return i

    def get_ancestry(self, version_ids, topo_sorted=True):
        """See VersionedFile.get_ancestry."""
        if isinstance(version_ids, bytes):
            version_ids = [version_ids]
        i = self._inclusions([self._lookup(v) for v in version_ids])
        return {self._idx_to_name(v) for v in i}

    def _check_versions(self, indexes):
        """Check everything in the sequence of indexes is valid"""
        for i in indexes:
            try:
                self._parents[i]
            except IndexError:
                raise IndexError('invalid version number %r' % i)

    def _compatible_parents(self, my_parents, other_parents):
        """During join check that other_parents are joinable with my_parents.

        Joinable is defined as 'is a subset of' - supersets may require
        regeneration of diffs, but subsets do not.
        """
        return len(other_parents.difference(my_parents)) == 0

    def annotate(self, version_id):
        """Return a list of (version-id, line) tuples for version_id.

        The index indicates when the line originated in the weave."""
        incls = [self._lookup(version_id)]
        return [(self._idx_to_name(origin), text) for origin, lineno, text in self._extract(incls)]

    def iter_lines_added_or_present_in_versions(self, version_ids=None, pb=None):
        """See VersionedFile.iter_lines_added_or_present_in_versions()."""
        if version_ids is None:
            version_ids = self.versions()
        version_ids = set(version_ids)
        for lineno, inserted, deletes, line in self._walk_internal(version_ids):
            if inserted not in version_ids:
                continue
            if not line.endswith(b'\n'):
                yield (line + b'\n', inserted)
            else:
                yield (line, inserted)

    def _walk_internal(self, version_ids=None):
        """Helper method for weave actions."""
        istack = []
        dset = set()
        lineno = 0
        for l in self._weave:
            if l.__class__ == tuple:
                c, v = l
                if c == b'{':
                    istack.append(self._names[v])
                elif c == b'}':
                    istack.pop()
                elif c == b'[':
                    dset.add(self._names[v])
                elif c == b']':
                    dset.remove(self._names[v])
                else:
                    raise WeaveFormatError('unexpected instruction %r' % v)
            else:
                yield (lineno, istack[-1], frozenset(dset), l)
            lineno += 1
        if istack:
            raise WeaveFormatError('unclosed insertion blocks at end of weave: %s' % istack)
        if dset:
            raise WeaveFormatError('unclosed deletion blocks at end of weave: %s' % dset)

    def plan_merge(self, ver_a, ver_b):
        """Return pseudo-annotation indicating how the two versions merge.

        This is computed between versions a and b and their common
        base.

        Weave lines present in none of them are skipped entirely.
        """
        inc_a = self.get_ancestry([ver_a])
        inc_b = self.get_ancestry([ver_b])
        inc_c = inc_a & inc_b
        for lineno, insert, deleteset, line in self._walk_internal([ver_a, ver_b]):
            if deleteset & inc_c:
                yield ('killed-base', line)
            elif insert in inc_c:
                killed_a = bool(deleteset & inc_a)
                killed_b = bool(deleteset & inc_b)
                if killed_a and killed_b:
                    yield ('killed-both', line)
                elif killed_a:
                    yield ('killed-a', line)
                elif killed_b:
                    yield ('killed-b', line)
                else:
                    yield ('unchanged', line)
            elif insert in inc_a:
                if deleteset & inc_a:
                    yield ('ghost-a', line)
                else:
                    yield ('new-a', line)
            elif insert in inc_b:
                if deleteset & inc_b:
                    yield ('ghost-b', line)
                else:
                    yield ('new-b', line)
            else:
                yield ('irrelevant', line)

    def _extract(self, versions):
        """Yield annotation of lines in included set.

        Yields a sequence of tuples (origin, lineno, text), where
        origin is the origin version, lineno the index in the weave,
        and text the text of the line.

        The set typically but not necessarily corresponds to a version.
        """
        for i in versions:
            if not isinstance(i, int):
                raise ValueError(i)
        included = self._inclusions(versions)
        istack = []
        iset = set()
        dset = set()
        lineno = 0
        isactive = None
        result = []
        for l in self._weave:
            if l.__class__ == tuple:
                c, v = l
                isactive = None
                if c == b'{':
                    istack.append(v)
                    iset.add(v)
                elif c == b'}':
                    iset.remove(istack.pop())
                elif c == b'[':
                    if v in included:
                        dset.add(v)
                elif c == b']':
                    if v in included:
                        dset.remove(v)
                else:
                    raise AssertionError()
            else:
                if isactive is None:
                    isactive = not dset and istack and (istack[-1] in included)
                if isactive:
                    result.append((istack[-1], lineno, l))
            lineno += 1
        if istack:
            raise WeaveFormatError('unclosed insertion blocks at end of weave: %s' % istack)
        if dset:
            raise WeaveFormatError('unclosed deletion blocks at end of weave: %s' % dset)
        return result

    def _maybe_lookup(self, name_or_index):
        """Convert possible symbolic name to index, or pass through indexes.

        NOT FOR PUBLIC USE.
        """
        if isinstance(name_or_index, int):
            return name_or_index
        else:
            return self._lookup(name_or_index)

    def get_lines(self, version_id):
        """See VersionedFile.get_lines()."""
        int_index = self._maybe_lookup(version_id)
        result = [line for origin, lineno, line in self._extract([int_index])]
        expected_sha1 = self._sha1s[int_index]
        measured_sha1 = sha_strings(result)
        if measured_sha1 != expected_sha1:
            raise WeaveInvalidChecksum('file %s, revision %s, expected: %s, measured %s' % (self._weave_name, version_id, expected_sha1, measured_sha1))
        return result

    def get_sha1s(self, version_ids):
        """See VersionedFile.get_sha1s()."""
        result = {}
        for v in version_ids:
            result[v] = self._sha1s[self._lookup(v)]
        return result

    def num_versions(self):
        """How many versions are in this weave?"""
        return len(self._parents)
    __len__ = num_versions

    def check(self, progress_bar=None):
        for version in range(self.num_versions()):
            inclusions = list(self._parents[version])
            if inclusions:
                inclusions.sort()
                if inclusions[-1] >= version:
                    raise WeaveFormatError('invalid included version %d for index %d' % (inclusions[-1], version))
        nv = self.num_versions()
        sha1s = {}
        texts = {}
        inclusions = {}
        for i in range(nv):
            name = self._idx_to_name(i)
            sha1s[name] = sha()
            texts[name] = []
            new_inc = {name}
            for p in self._parents[i]:
                new_inc.update(inclusions[self._idx_to_name(p)])
            if new_inc != self.get_ancestry(name):
                raise AssertionError('failed %s != %s' % (new_inc, self.get_ancestry(name)))
            inclusions[name] = new_inc
        nlines = len(self._weave)
        update_text = 'checking weave'
        if self._weave_name:
            short_name = os.path.basename(self._weave_name)
            update_text = 'checking {}'.format(short_name)
            update_text = update_text[:25]
        for lineno, insert, deleteset, line in self._walk_internal():
            if progress_bar:
                progress_bar.update(update_text, lineno, nlines)
            for name, name_inclusions in inclusions.items():
                if insert in name_inclusions and (not deleteset & name_inclusions):
                    sha1s[name].update(line)
        for i in range(nv):
            version = self._idx_to_name(i)
            hd = sha1s[version].hexdigest().encode()
            expected = self._sha1s[i]
            if hd != expected:
                raise WeaveInvalidChecksum('mismatched sha1 for version %s: got %s, expected %s' % (version, hd, expected))

    def _imported_parents(self, other, other_idx):
        """Return list of parents in self corresponding to indexes in other."""
        new_parents = []
        for parent_idx in other._parents[other_idx]:
            parent_name = other._names[parent_idx]
            if parent_name not in self._name_map:
                raise WeaveError('missing parent {%s} of {%s} in %r' % (parent_name, other._name_map[other_idx], self))
            new_parents.append(self._name_map[parent_name])
        return new_parents

    def _check_version_consistent(self, other, other_idx, name):
        """Check if a version in consistent in this and other.

        To be consistent it must have:

         * the same text
         * the same direct parents (by name, not index, and disregarding
           order)

        If present & correct return True;
        if not present in self return False;
        if inconsistent raise error."""
        this_idx = self._name_map.get(name, -1)
        if this_idx != -1:
            if self._sha1s[this_idx] != other._sha1s[other_idx]:
                raise WeaveTextDiffers(name, self, other)
            self_parents = self._parents[this_idx]
            other_parents = other._parents[other_idx]
            n1 = {self._names[i] for i in self_parents}
            n2 = {other._names[i] for i in other_parents}
            if not self._compatible_parents(n1, n2):
                raise WeaveParentMismatch('inconsistent parents for version {%s}: %s vs %s' % (name, n1, n2))
            else:
                return True
        else:
            return False

    def _reweave(self, other, pb, msg):
        """Reweave self with other - internal helper for join().

        :param other: The other weave to merge
        :param pb: An optional progress bar, indicating how far done we are
        :param msg: An optional message for the progress
        """
        new_weave = _reweave(self, other, pb=pb, msg=msg)
        self._copy_weave_content(new_weave)

    def _copy_weave_content(self, otherweave):
        """adsorb the content from otherweave."""
        for attr in self.__slots__:
            if attr != '_weave_name':
                setattr(self, attr, copy(getattr(otherweave, attr)))