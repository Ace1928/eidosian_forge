import re
from pygments.lexer import RegexLexer, default, words
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
class IsabelleLexer(RegexLexer):
    """
    For the `Isabelle <http://isabelle.in.tum.de/>`_ proof assistant.

    .. versionadded:: 2.0
    """
    name = 'Isabelle'
    aliases = ['isabelle']
    filenames = ['*.thy']
    mimetypes = ['text/x-isabelle']
    keyword_minor = ('and', 'assumes', 'attach', 'avoids', 'binder', 'checking', 'class_instance', 'class_relation', 'code_module', 'congs', 'constant', 'constrains', 'datatypes', 'defines', 'file', 'fixes', 'for', 'functions', 'hints', 'identifier', 'if', 'imports', 'in', 'includes', 'infix', 'infixl', 'infixr', 'is', 'keywords', 'lazy', 'module_name', 'monos', 'morphisms', 'no_discs_sels', 'notes', 'obtains', 'open', 'output', 'overloaded', 'parametric', 'permissive', 'pervasive', 'rep_compat', 'shows', 'structure', 'type_class', 'type_constructor', 'unchecked', 'unsafe', 'where')
    keyword_diag = ('ML_command', 'ML_val', 'class_deps', 'code_deps', 'code_thms', 'display_drafts', 'find_consts', 'find_theorems', 'find_unused_assms', 'full_prf', 'help', 'locale_deps', 'nitpick', 'pr', 'prf', 'print_abbrevs', 'print_antiquotations', 'print_attributes', 'print_binds', 'print_bnfs', 'print_bundles', 'print_case_translations', 'print_cases', 'print_claset', 'print_classes', 'print_codeproc', 'print_codesetup', 'print_coercions', 'print_commands', 'print_context', 'print_defn_rules', 'print_dependencies', 'print_facts', 'print_induct_rules', 'print_inductives', 'print_interps', 'print_locale', 'print_locales', 'print_methods', 'print_options', 'print_orders', 'print_quot_maps', 'print_quotconsts', 'print_quotients', 'print_quotientsQ3', 'print_quotmapsQ3', 'print_rules', 'print_simpset', 'print_state', 'print_statement', 'print_syntax', 'print_theorems', 'print_theory', 'print_trans_rules', 'prop', 'pwd', 'quickcheck', 'refute', 'sledgehammer', 'smt_status', 'solve_direct', 'spark_status', 'term', 'thm', 'thm_deps', 'thy_deps', 'try', 'try0', 'typ', 'unused_thms', 'value', 'values', 'welcome', 'print_ML_antiquotations', 'print_term_bindings', 'values_prolog')
    keyword_thy = ('theory', 'begin', 'end')
    keyword_section = ('header', 'chapter')
    keyword_subsection = ('section', 'subsection', 'subsubsection', 'sect', 'subsect', 'subsubsect')
    keyword_theory_decl = ('ML', 'ML_file', 'abbreviation', 'adhoc_overloading', 'arities', 'atom_decl', 'attribute_setup', 'axiomatization', 'bundle', 'case_of_simps', 'class', 'classes', 'classrel', 'codatatype', 'code_abort', 'code_class', 'code_const', 'code_datatype', 'code_identifier', 'code_include', 'code_instance', 'code_modulename', 'code_monad', 'code_printing', 'code_reflect', 'code_reserved', 'code_type', 'coinductive', 'coinductive_set', 'consts', 'context', 'datatype', 'datatype_new', 'datatype_new_compat', 'declaration', 'declare', 'default_sort', 'defer_recdef', 'definition', 'defs', 'domain', 'domain_isomorphism', 'domaindef', 'equivariance', 'export_code', 'extract', 'extract_type', 'fixrec', 'fun', 'fun_cases', 'hide_class', 'hide_const', 'hide_fact', 'hide_type', 'import_const_map', 'import_file', 'import_tptp', 'import_type_map', 'inductive', 'inductive_set', 'instantiation', 'judgment', 'lemmas', 'lifting_forget', 'lifting_update', 'local_setup', 'locale', 'method_setup', 'nitpick_params', 'no_adhoc_overloading', 'no_notation', 'no_syntax', 'no_translations', 'no_type_notation', 'nominal_datatype', 'nonterminal', 'notation', 'notepad', 'oracle', 'overloading', 'parse_ast_translation', 'parse_translation', 'partial_function', 'primcorec', 'primrec', 'primrec_new', 'print_ast_translation', 'print_translation', 'quickcheck_generator', 'quickcheck_params', 'realizability', 'realizers', 'recdef', 'record', 'refute_params', 'setup', 'setup_lifting', 'simproc_setup', 'simps_of_case', 'sledgehammer_params', 'spark_end', 'spark_open', 'spark_open_siv', 'spark_open_vcg', 'spark_proof_functions', 'spark_types', 'statespace', 'syntax', 'syntax_declaration', 'text', 'text_raw', 'theorems', 'translations', 'type_notation', 'type_synonym', 'typed_print_translation', 'typedecl', 'hoarestate', 'install_C_file', 'install_C_types', 'wpc_setup', 'c_defs', 'c_types', 'memsafe', 'SML_export', 'SML_file', 'SML_import', 'approximate', 'bnf_axiomatization', 'cartouche', 'datatype_compat', 'free_constructors', 'functor', 'nominal_function', 'nominal_termination', 'permanent_interpretation', 'binds', 'defining', 'smt2_status', 'term_cartouche', 'boogie_file', 'text_cartouche')
    keyword_theory_script = ('inductive_cases', 'inductive_simps')
    keyword_theory_goal = ('ax_specification', 'bnf', 'code_pred', 'corollary', 'cpodef', 'crunch', 'crunch_ignore', 'enriched_type', 'function', 'instance', 'interpretation', 'lemma', 'lift_definition', 'nominal_inductive', 'nominal_inductive2', 'nominal_primrec', 'pcpodef', 'primcorecursive', 'quotient_definition', 'quotient_type', 'recdef_tc', 'rep_datatype', 'schematic_corollary', 'schematic_lemma', 'schematic_theorem', 'spark_vc', 'specification', 'subclass', 'sublocale', 'termination', 'theorem', 'typedef', 'wrap_free_constructors')
    keyword_qed = ('by', 'done', 'qed')
    keyword_abandon_proof = ('sorry', 'oops')
    keyword_proof_goal = ('have', 'hence', 'interpret')
    keyword_proof_block = ('next', 'proof')
    keyword_proof_chain = ('finally', 'from', 'then', 'ultimately', 'with')
    keyword_proof_decl = ('ML_prf', 'also', 'include', 'including', 'let', 'moreover', 'note', 'txt', 'txt_raw', 'unfolding', 'using', 'write')
    keyword_proof_asm = ('assume', 'case', 'def', 'fix', 'presume')
    keyword_proof_asm_goal = ('guess', 'obtain', 'show', 'thus')
    keyword_proof_script = ('apply', 'apply_end', 'apply_trace', 'back', 'defer', 'prefer')
    operators = ('::', ':', '(', ')', '[', ']', '_', '=', ',', '|', '+', '-', '!', '?')
    proof_operators = ('{', '}', '.', '..')
    tokens = {'root': [('\\s+', Text), ('\\(\\*', Comment, 'comment'), ('\\{\\*', Comment, 'text'), (words(operators), Operator), (words(proof_operators), Operator.Word), (words(keyword_minor, prefix='\\b', suffix='\\b'), Keyword.Pseudo), (words(keyword_diag, prefix='\\b', suffix='\\b'), Keyword.Type), (words(keyword_thy, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_theory_decl, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_section, prefix='\\b', suffix='\\b'), Generic.Heading), (words(keyword_subsection, prefix='\\b', suffix='\\b'), Generic.Subheading), (words(keyword_theory_goal, prefix='\\b', suffix='\\b'), Keyword.Namespace), (words(keyword_theory_script, prefix='\\b', suffix='\\b'), Keyword.Namespace), (words(keyword_abandon_proof, prefix='\\b', suffix='\\b'), Generic.Error), (words(keyword_qed, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_goal, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_block, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_decl, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_chain, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_asm, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_asm_goal, prefix='\\b', suffix='\\b'), Keyword), (words(keyword_proof_script, prefix='\\b', suffix='\\b'), Keyword.Pseudo), ('\\\\<\\w*>', Text.Symbol), ("[^\\W\\d][.\\w']*", Name), ("\\?[^\\W\\d][.\\w']*", Name), ("'[^\\W\\d][.\\w']*", Name.Type), ('\\d[\\d_]*', Name), ('0[xX][\\da-fA-F][\\da-fA-F_]*', Number.Hex), ('0[oO][0-7][0-7_]*', Number.Oct), ('0[bB][01][01_]*', Number.Bin), ('"', String, 'string'), ('`', String.Other, 'fact')], 'comment': [('[^(*)]+', Comment), ('\\(\\*', Comment, '#push'), ('\\*\\)', Comment, '#pop'), ('[(*)]', Comment)], 'text': [('[^*}]+', Comment), ('\\*\\}', Comment, '#pop'), ('\\*', Comment), ('\\}', Comment)], 'string': [('[^"\\\\]+', String), ('\\\\<\\w*>', String.Symbol), ('\\\\"', String), ('\\\\', String), ('"', String, '#pop')], 'fact': [('[^`\\\\]+', String.Other), ('\\\\<\\w*>', String.Symbol), ('\\\\`', String.Other), ('\\\\', String.Other), ('`', String.Other, '#pop')]}