from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import collections
import copy
import inspect
from fire import inspectutils
import six
def _BashScript(name, commands, default_options=None):
    """Returns a Bash script registering a completion function for the commands.

  Args:
    name: The first token in the commands, also the name of the command.
    commands: A list of all possible commands that tab completion can complete
        to. Each command is a list or tuple of the string tokens that make up
        that command.
    default_options: A dict of options that can be used with any command. Use
        this if there are flags that can always be appended to a command.
  Returns:
    A string which is the Bash script. Source the bash script to enable tab
    completion in Bash.
  """
    default_options = default_options or set()
    global_options, options_map, subcommands_map = _GetMaps(name, commands, default_options)
    bash_completion_template = '# bash completion support for {name}\n# DO NOT EDIT.\n# This script is autogenerated by fire/completion.py.\n\n_complete-{identifier}()\n{{\n  local cur prev opts lastcommand\n  COMPREPLY=()\n  prev="${{COMP_WORDS[COMP_CWORD-1]}}"\n  cur="${{COMP_WORDS[COMP_CWORD]}}"\n  lastcommand=$(get_lastcommand)\n\n  opts="{default_options}"\n  GLOBAL_OPTIONS="{global_options}"\n\n{checks}\n\n  COMPREPLY=( $(compgen -W "${{opts}}" -- ${{cur}}) )\n  return 0\n}}\n\nget_lastcommand()\n{{\n  local lastcommand i\n\n  lastcommand=\n  for ((i=0; i < ${{#COMP_WORDS[@]}}; ++i)); do\n    if [[ ${{COMP_WORDS[i]}} != -* ]] && [[ -n ${{COMP_WORDS[i]}} ]] && [[\n      ${{COMP_WORDS[i]}} != $cur ]]; then\n      lastcommand=${{COMP_WORDS[i]}}\n    fi\n  done\n\n  echo $lastcommand\n}}\n\nfilter_options()\n{{\n  local opts\n  opts=""\n  for opt in "$@"\n  do\n    if ! option_already_entered $opt; then\n      opts="$opts $opt"\n    fi\n  done\n\n  echo $opts\n}}\n\noption_already_entered()\n{{\n  local opt\n  for opt in ${{COMP_WORDS[@]:0:$COMP_CWORD}}\n  do\n    if [ $1 == $opt ]; then\n      return 0\n    fi\n  done\n  return 1\n}}\n\nis_prev_global()\n{{\n  local opt\n  for opt in $GLOBAL_OPTIONS\n  do\n    if [ $opt == $prev ]; then\n      return 0\n    fi\n  done\n  return 1\n}}\n\ncomplete -F _complete-{identifier} {command}\n'
    check_wrapper = '\n  case "${{lastcommand}}" in\n  {lastcommand_checks}\n  esac'
    lastcommand_check_template = '\n    {command})\n      {opts_assignment}\n      opts=$(filter_options $opts)\n    ;;'
    opts_assignment_subcommand_template = '\n      if is_prev_global; then\n        opts="${{GLOBAL_OPTIONS}}"\n      else\n        opts="{options} ${{GLOBAL_OPTIONS}}"\n      fi'
    opts_assignment_main_command_template = '\n      opts="{options} ${{GLOBAL_OPTIONS}}" '

    def _GetOptsAssignmentTemplate(command):
        if command == name:
            return opts_assignment_main_command_template
        else:
            return opts_assignment_subcommand_template
    lines = []
    commands_set = set()
    commands_set.add(name)
    commands_set = commands_set.union(set(subcommands_map.keys()))
    commands_set = commands_set.union(set(options_map.keys()))
    for command in commands_set:
        opts_assignment = _GetOptsAssignmentTemplate(command).format(options=' '.join(sorted(options_map[command].union(subcommands_map[command]))))
        lines.append(lastcommand_check_template.format(command=command, opts_assignment=opts_assignment))
    lastcommand_checks = '\n'.join(lines)
    checks = check_wrapper.format(lastcommand_checks=lastcommand_checks)
    return bash_completion_template.format(name=name, command=name, checks=checks, default_options=' '.join(default_options), identifier=name.replace('/', '').replace('.', '').replace(',', ''), global_options=' '.join(global_options))