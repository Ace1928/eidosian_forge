import atexit
import functools
import locale
import logging
import multiprocessing
import os
import traceback
import pathlib
import Pyro4.core
import argparse
from enum import IntEnum
import shutil
import socket
import struct
import collections
import subprocess
import sys
import tempfile
import threading
import time
from contextlib import contextmanager
import uuid
import psutil
import Pyro4
from random import Random
from minerl.env import comms
import minerl.utils.process_watcher
@classmethod
def _get_next_seed(cls, i=None):
    """Gets the next seed for an instance.
        
        Raises:
            TypeError: If the seed type cannot generate seeds.
        
        Returns:
            long: The seed generated by the seed type generator for seeds.  
        """
    if cls._seed_type == SeedType.CONSTANT:
        return cls._seed_generator
    elif cls._seed_type == SeedType.GENERATED:
        return [cls._seed_generator.randint(-MAXRAND, MAXRAND)]
    elif cls._seed_type == SeedType.SPECIFIED:
        try:
            if i is None:
                i = 0
                logger.warning('Trying to use specified seed type without specifying index id.')
            return cls._seed_generator[i]
        except IndexError:
            raise TypeError('Seed type {} ran out of seeds.'.format(cls._seed_type))
    else:
        raise TypeError('Seed type {} does not support getting next seed'.format(cls._seed_type))