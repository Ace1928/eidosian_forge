from __future__ import annotations
import math
import pickle
from textwrap import dedent
import numpy as np
import pandas as pd
import pytest
import xarray as xr
from xarray import DataArray, Variable
from xarray.namedarray.pycompat import array_type
from xarray.tests import assert_equal, assert_identical, requires_dask
@pytest.mark.parametrize('func,sparse_output', [(do('all'), False), (do('any'), False), (do('assign_attrs', {'foo': 'bar'}), True), (do('assign_coords', x=make_xrarray({'x': 10}).x + 1), True), (do('astype', int), True), (do('clip', min=0, max=1), True), (do('compute'), True), (do('conj'), True), (do('copy'), True), (do('count'), False), (do('diff', 'x'), True), (do('drop_vars', 'x'), True), (do('expand_dims', {'z': 2}, axis=2), True), (do('get_axis_num', 'x'), False), (do('get_index', 'x'), False), (do('identical', make_xrarray({'x': 5, 'y': 5})), False), (do('integrate', 'x'), True), (do('isel', {'x': slice(0, 3), 'y': slice(2, 4)}), True), (do('isnull'), True), (do('load'), True), (do('mean'), False), (do('persist'), True), (do('reindex', {'x': [1, 2, 3]}), True), (do('rename', 'foo'), True), (do('reorder_levels'), True), (do('reset_coords', drop=True), True), (do('reset_index', 'x'), True), (do('round'), True), (do('sel', x=[0, 1, 2]), True), (do('shift'), True), (do('sortby', 'x', ascending=False), True), (do('stack', z=['x', 'y']), True), (do('transpose'), True), (do('broadcast_equals', make_xrvar({'x': 10, 'y': 5})), False), (do('equals', make_xrvar({'x': 10, 'y': 5})), False), param(do('argmax'), True, marks=[xfail(reason='Missing implementation for np.argmax'), filterwarnings('ignore:Behaviour of argmin/argmax')]), param(do('argmin'), True, marks=[xfail(reason='Missing implementation for np.argmin'), filterwarnings('ignore:Behaviour of argmin/argmax')]), param(do('argsort'), True, marks=xfail(reason="'COO' object has no attribute 'argsort'")), param(do('bfill', dim='x'), False, marks=xfail(reason='Missing implementation for np.flip')), (do('combine_first', make_xrarray({'x': 10, 'y': 5})), True), param(do('conjugate'), False, marks=xfail(reason="'COO' object has no attribute 'conjugate'")), param(do('cumprod'), True, marks=xfail(reason='Missing implementation for np.nancumprod')), param(do('cumsum'), True, marks=xfail(reason='Missing implementation for np.nancumsum')), param(do('differentiate', 'x'), False, marks=xfail(reason='Missing implementation for np.gradient')), param(do('dot', make_xrarray({'x': 10, 'y': 5})), True, marks=xfail(reason='Missing implementation for np.einsum')), param(do('dropna', 'x'), False, marks=xfail(reason='Coercion to dense')), param(do('ffill', 'x'), False, marks=xfail(reason='Coercion to dense')), (do('fillna', 0), True), param(do('interp', coords={'x': np.arange(10) + 0.5}), True, marks=xfail(reason='Coercion to dense')), param(do('interp_like', make_xrarray({'x': 10, 'y': 5}, coords={'x': np.arange(10) + 0.5, 'y': np.arange(5) + 0.5})), True, marks=xfail(reason='Indexing COO with more than one iterable index')), param(do('interpolate_na', 'x'), True, marks=xfail(reason='Coercion to dense')), param(do('isin', [1, 2, 3]), False, marks=xfail(reason='Missing implementation for np.isin')), param(do('item', (1, 1)), False, marks=xfail(reason="'COO' object has no attribute 'item'")), param(do('max'), False), param(do('min'), False), param(do('median'), False, marks=xfail(reason='Missing implementation for np.nanmedian')), (do('notnull'), True), (do('pipe', func='sum', axis=1), True), (do('prod'), False), param(do('quantile', q=0.5), False, marks=xfail(reason='Missing implementation for np.nanpercentile')), param(do('rank', 'x'), False, marks=xfail(reason='Only implemented for NumPy arrays (via bottleneck)')), param(do('reduce', func='sum', dim='x'), False, marks=xfail(reason='Coercion to dense')), param(do('reindex_like', make_xrarray({'x': 10, 'y': 5}, coords={'x': np.arange(10) + 0.5, 'y': np.arange(5) + 0.5})), True, marks=xfail(reason='Indexing COO with more than one iterable index')), (do('roll', x=2, roll_coords=True), True), param(do('sel', x=[0, 1, 2], y=[2, 3]), True, marks=xfail(reason='Indexing COO with more than one iterable index')), param(do('std'), False, marks=xfail(reason='Missing implementation for np.nanstd')), (do('sum'), False), param(do('var'), False, marks=xfail(reason='Missing implementation for np.nanvar')), param(do('where', make_xrarray({'x': 10, 'y': 5}) > 0.5), False, marks=xfail(reason='Conversion of dense to sparse when using sparse mask'))], ids=repr)
def test_dataarray_method(func, sparse_output):
    arr_s = make_xrarray({'x': 10, 'y': 5}, coords={'x': np.arange(10), 'y': np.arange(5)})
    arr_d = xr.DataArray(arr_s.data.todense(), coords=arr_s.coords, dims=arr_s.dims)
    ret_s = func(arr_s)
    ret_d = func(arr_d)
    if sparse_output:
        assert isinstance(ret_s.data, sparse.SparseArray)
        assert np.allclose(ret_s.data.todense(), ret_d.data, equal_nan=True)
    else:
        assert np.allclose(ret_s, ret_d, equal_nan=True)