import pyomo.common.unittest as unittest
from pyomo.common.errors import InfeasibleConstraintException
from pyomo.environ import (
def test_var_bound_propagate_revert(self):
    """Test to make sure bound propagation revert works."""
    m = ConcreteModel()
    m.v1 = Var(initialize=1, bounds=(1, 3))
    m.v2 = Var(initialize=2, bounds=(0, 8))
    m.v3 = Var(initialize=3, bounds=(2, 4))
    m.v4 = Var(initialize=4, bounds=(0, 5))
    m.c1 = Constraint(expr=m.v1 == m.v2)
    m.c2 = Constraint(expr=m.v2 == m.v3)
    m.c3 = Constraint(expr=m.v3 == m.v4)
    xfrm = TransformationFactory('contrib.propagate_eq_var_bounds')
    xfrm.apply_to(m, tmp=True)
    self.assertEqual(value(m.v1.lb), 2)
    self.assertEqual(value(m.v1.lb), value(m.v2.lb))
    self.assertEqual(value(m.v1.lb), value(m.v3.lb))
    self.assertEqual(value(m.v1.lb), value(m.v4.lb))
    self.assertEqual(value(m.v1.ub), 3)
    self.assertEqual(value(m.v1.ub), value(m.v2.ub))
    self.assertEqual(value(m.v1.ub), value(m.v3.ub))
    self.assertEqual(value(m.v1.ub), value(m.v4.ub))
    xfrm.revert(m)
    self.assertEqual(value(m.v1.lb), 1)
    self.assertEqual(value(m.v2.lb), 0)
    self.assertEqual(value(m.v3.lb), 2)
    self.assertEqual(value(m.v4.lb), 0)
    self.assertEqual(value(m.v1.ub), 3)
    self.assertEqual(value(m.v2.ub), 8)
    self.assertEqual(value(m.v3.ub), 4)
    self.assertEqual(value(m.v4.ub), 5)