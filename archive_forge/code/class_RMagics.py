import contextlib
import sys
import tempfile
from glob import glob
import os
from shutil import rmtree
import textwrap
import typing
import rpy2.rinterface_lib.callbacks
import rpy2.rinterface as ri
import rpy2.rinterface_lib.openrlib
import rpy2.robjects as ro
import rpy2.robjects.packages as rpacks
from rpy2.robjects.lib import grdevices
from rpy2.robjects.conversion import (Converter,
import warnings
import IPython.display  # type: ignore
from IPython.core import displaypub  # type: ignore
from IPython.core.magic import (Magics,   # type: ignore
from IPython.core.magic_arguments import (argument,  # type: ignore
@magics_class
class RMagics(Magics):
    """A set of magics useful for interactive work with R via rpy2.
    """

    def __init__(self, shell, converter=converter, cache_display_data=False, device='png'):
        """
        Parameters
        ----------

        shell : IPython shell

        converter : rpy2 Converter instance to use. If None,
                    the magic's current converter is used.

        cache_display_data : bool
            If True, the published results of the final call to R are
            cached in the variable 'display_cache'.

        device : ['png', 'jpeg', 'X11', 'svg']
            Device to be used for plotting.
            Currently only 'png', 'jpeg', 'X11' and 'svg' are supported,
            with 'X11' allowing interactive plots on a locally-running jupyter,
            and the other allowing to visualize R figure generated on a remote
            jupyter server/kernel.
        """
        super(RMagics, self).__init__(shell)
        self.cache_display_data = cache_display_data
        self.Rstdout_cache = []
        self.converter = converter
        self.set_R_plotting_device(device)

    def set_R_plotting_device(self, device):
        """
        Set which device R should use to produce plots.
        If device == 'svg' then the package 'Cairo'
        must be installed. Because Cairo forces "onefile=TRUE",
        it is not posible to include multiple plots per cell.

        :param device: ['png', 'jpeg', 'X11', 'svg']
            Device to be used for plotting.
            Currently only 'png', 'jpeg', 'X11' and 'svg' are supported,
            with 'X11' allowing interactive plots on a locally-running jupyter,
            and the other allowing to visualize R figure generated on a remote
            jupyter server/kernel.
        """
        device = device.strip()
        if device not in DEVICES_SUPPORTED:
            raise ValueError(f'device must be one of {DEVICES_SUPPORTED}, got "{device}"')
        if device == 'svg':
            try:
                self.cairo = rpacks.importr('Cairo')
            except ri.embedded.RRuntimeError as rre:
                if rpacks.isinstalled('Cairo'):
                    msg = 'An error occurred when trying to load the ' + "R package Cairo'\n%s" % str(rre)
                else:
                    msg = textwrap.dedent("\n                    The R package 'Cairo' is required but it does not appear\n                    to be installed/available. Try:\n\n                    import rpy2.robjects.packages as rpacks\n                    utils = rpacks.importr('utils')\n                    utils.chooseCRANmirror(ind=1)\n                    utils.install_packages('Cairo')\n                    ")
                raise RInterpreterError(msg)
        self.device = device

    @line_magic
    def Rdevice(self, line):
        '\n        Change the plotting device R uses to one of {}.\n        '.format(DEVICES_SUPPORTED)
        self.set_R_plotting_device(line.strip())

    def eval(self, code):
        """
        Parse and evaluate a line of R code with rpy2.
        Returns the output to R's stdout() connection,
        the value generated by evaluating the code, and a
        boolean indicating whether the return value would be
        visible if the line of code were evaluated in an R REPL.

        R Code evaluation and visibility determination are done via an R call
        of the form withVisible(code_string), and this entire expression needs
        to be evaluated in R (we can't use rpy2 function proxies here, as
        withVisible is a LISPy R function).
        """
        with contextlib.ExitStack() as stack:
            obj_in_module = rpy2.rinterface_lib.callbacks.obj_in_module
            if self.cache_display_data:
                stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, 'consolewrite_print', self.write_console_regular))
            stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, 'consolewrite_warnerror', self.write_console_regular))
            stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, '_WRITECONSOLE_EXCEPTION_LOG', '%s'))
            try:
                r_expr = ri.parse(code)
                value, visible = ri.evalr_expr_with_visible(r_expr)
            except (ri.embedded.RRuntimeError, ValueError) as exception:
                warning_or_other_msg = self.flush()
                raise RInterpreterError(code, str(exception), warning_or_other_msg)
            finally:
                ro._print_deferred_warnings()
            text_output = self.flush()
            return (text_output, value, visible[0])

    def write_console_regular(self, output):
        """
        A hook to capture R's stdout in a cache.
        """
        self.Rstdout_cache.append(output)

    def flush(self):
        """
        Flush R's stdout cache to a string, returning the string.
        """
        value = ''.join(self.Rstdout_cache)
        self.Rstdout_cache = []
        return value

    def _import_name_into_r(self, arg: str, env: ri.SexpEnvironment, local_ns: dict) -> None:
        lhs, rhs = _parse_input_argument(arg)
        val = None
        try:
            val = _find(rhs, local_ns)
        except NameError:
            if self.shell is None:
                warnings.warn(f'The shell is None. Unable to look for {rhs}.')
            else:
                val = _find(rhs, self.shell.user_ns)
        if val is not None:
            env[lhs] = val

    def _find_converter(self, name: str, local_ns: dict) -> ro.conversion.Converter:
        converter = None
        if name is None:
            converter = self.converter
        else:
            try:
                converter = _find(name, local_ns)
            except NameError:
                if self.shell is None:
                    warnings.warn(f'The shell is None. Unable to look for converter {name}.')
                else:
                    converter = _find(name, self.shell.user_ns)
        if not isinstance(converter, Converter):
            raise TypeError("'%s' must be a %s object (but it is a %s)." % (converter, Converter, type(converter)))
        return converter

    @magic_arguments()
    @argument('-c', '--converter', default=None, help=textwrap.dedent("\n        Name of local converter to use. A converter contains the rules to\n        convert objects back and forth between Python and R. If not\n        specified/None, the defaut converter for the magic's module is used\n        (that is rpy2's default converter + numpy converter + pandas converter\n        if all three are available)."))
    @argument('inputs', nargs='*')
    @needs_local_scope
    @line_magic
    def Rpush(self, line, local_ns=None):
        """
        A line-level magic that pushes
        variables from python to R. The line should be made up
        of whitespace separated variable names in the IPython
        namespace::

            In [7]: import numpy as np

            In [8]: X = np.array([4.5,6.3,7.9])

            In [9]: X.mean()
            Out[9]: 6.2333333333333343

            In [10]: %Rpush X

            In [11]: %R mean(X)
            Out[11]: array([ 6.23333333])

        """
        args = parse_argstring(self.Rpush, line)
        converter = self._find_converter(args.converter, local_ns)
        if local_ns is None:
            local_ns = {}
        with localconverter(converter):
            for arg in args.inputs:
                self._import_name_into_r(arg, ro.globalenv, local_ns)

    @magic_arguments()
    @argument('outputs', nargs='*')
    @line_magic
    def Rpull(self, line):
        """
        A line-level magic for R that pulls
        variables from python to rpy2::

            In [18]: _ = %R x = c(3,4,6.7); y = c(4,6,7); z = c('a',3,4)

            In [19]: %Rpull x  y z

            In [20]: x
            Out[20]: array([ 3. ,  4. ,  6.7])

            In [21]: y
            Out[21]: array([ 4.,  6.,  7.])

            In [22]: z
            Out[22]:
            array(['a', '3', '4'],
                  dtype='|S1')


        This is useful when a structured array is desired as output, or
        when the object in R has mixed data types.
        See the %%R docstring for more examples.

        Notes
        -----

        Beware that R names can have dots ('.') so this is not fool proof.
        To avoid this, don't name your R objects with dots...

        """
        args = parse_argstring(self.Rpull, line)
        outputs = args.outputs
        with localconverter(self.converter):
            for output in outputs:
                robj = ri.globalenv.find(output)
                self.shell.push({output: robj})

    @magic_arguments()
    @argument('output', nargs=1, type=str)
    @line_magic
    def Rget(self, line):
        """
        Return an object from rpy2, possibly as a structured array (if
        possible).
        Similar to Rpull except only one argument is accepted and the value is
        returned rather than pushed to self.shell.user_ns::

            In [3]: dtype=[('x', '<i4'), ('y', '<f8'), ('z', '|S1')]

            In [4]: datapy = np.array([(1, 2.9, 'a'), (2, 3.5, 'b'),
            ...                        (3, 2.1, 'c'), (4, 5, 'e')],
            ...                        dtype=dtype)

            In [5]: %R -i datapy

            In [6]: %Rget datapy
            Out[6]:
            array([['1', '2', '3', '4'],
                   ['2', '3', '2', '5'],
                   ['a', 'b', 'c', 'e']],
                  dtype='|S1')
        """
        args = parse_argstring(self.Rget, line)
        output = args.output
        with localconverter(self.converter):
            res = ro.globalenv.find(output[0])
        return res

    def setup_graphics(self, args):
        """Setup graphics in preparation for evaluating R code.

        args : argparse bunch (should be whatever the R magic got)."""
        if getattr(args, 'units') is not None:
            if args.units != 'px' and getattr(args, 'res') is None:
                args.res = 72
        plot_arg_names = ['width', 'height', 'pointsize', 'bg', 'type']
        if self.device in DEVICES_STATIC_RASTER:
            plot_arg_names += ['units', 'res']
        argdict = {}
        for name in plot_arg_names:
            val = getattr(args, name)
            if val is not None:
                argdict[name] = val
        tmpd = None
        if self.device in DEVICES_STATIC:
            tmpd = tempfile.mkdtemp()
            tmpd_fix_slashes = tmpd.replace('\\', '/')
            if self.device in DEVICES_STATIC_RASTER:
                rfunc = getattr(grdevices, self.device)
                rfunc(f'{tmpd_fix_slashes}/Rplots%%03d.{self.device}', **argdict)
            elif self.device == 'svg':
                self.cairo.CairoSVG(f'{tmpd_fix_slashes}/Rplot.svg', **argdict)
        elif self.device == 'X11':
            ro.r('\n            if (substr(names(dev.cur()), 1, 3) != "X11") {\n                X11()\n            }')
        else:
            raise RInterpreterError(f'device must be one of {DEVICES_SUPPORTED}')
        return tmpd

    def publish_graphics(self, graph_dir, isolate_svgs=True):
        """Wrap graphic file data for presentation in IPython.

        This method is deprecated. Use `display_figures` or
        'display_figures_svg` instead.

        graph_dir : str
            Probably provided by some tmpdir call
        isolate_svgs : bool
            Enable SVG namespace isolation in metadata"""
        warnings.warn('Use method fetch_figures.', DeprecationWarning)
        images = []
        display_data = []
        md = {}
        if self.device == 'png':
            for imgfile in sorted(glob('%s/Rplots*png' % graph_dir)):
                if os.stat(imgfile).st_size >= 1000:
                    with open(imgfile, 'rb') as fh_img:
                        images.append(fh_img.read())
        else:
            imgfile = '%s/Rplot.svg' % graph_dir
            if os.stat(imgfile).st_size >= 1000:
                with open(imgfile, 'rb') as fh_img:
                    images.append(fh_img.read().decode())
        mimetypes = {'png': 'image/png', 'svg': 'image/svg+xml'}
        mime = mimetypes[self.device]
        if images and self.device == 'svg' and isolate_svgs:
            md = {'image/svg+xml': dict(isolated=True)}
        for image in images:
            sys.stdout.flush()
            sys.stderr.flush()
            display_data.append(('RMagic.R', {mime: image}))
        return (display_data, md)

    @magic_arguments()
    @argument('-i', '--input', action='append', help=textwrap.dedent("\n        Names of Python objects to be assigned to R\n        objects after using the default converter or\n        one specified through the argument `-c/--converter`.\n        Multiple inputs can be passed separated only by commas with no\n        whitespace.\n\n        Names of Python objects can be either the name of an object\n        in the current notebook/ipython shell, or a path to a name\n        nested in a namespace visible from the current notebook/ipython\n        shell. For example, '-i myvariable' or\n        '-i mypackage.myothervariable' would both work.\n\n        Each input can be either the name of Python object, in which\n        case the same name will be used for the R object, or an\n        expression of the form <r-name>=<python-name>."))
    @argument('-o', '--output', action='append', help=textwrap.dedent("\n        Names of variables to be pushed from rpy2 to `shell.user_ns` after\n        executing cell body (rpy2's internal facilities will apply ri2ro as\n        appropriate). Multiple names can be passed separated only by commas\n        with no whitespace."))
    @argument('-n', '--noreturn', help='Force the magic to not return anything.', action='store_true', default=False)
    @argument_group('Plot', 'Arguments to plotting device')
    @argument('-w', '--width', type=float, help='Width of plotting device in R.')
    @argument('-h', '--height', type=float, help='Height of plotting device in R.')
    @argument('-p', '--pointsize', type=int, help='Pointsize of plotting device in R.')
    @argument('-b', '--bg', help='Background of plotting device in R.')
    @argument_group('SVG', 'SVG specific arguments')
    @argument('--noisolation', help=textwrap.dedent('\n        Disable SVG isolation in the Notebook. By default, SVGs are isolated to\n        avoid namespace collisions between figures. Disabling SVG isolation\n        allows to reference previous figures or share CSS rules across a set\n        of SVGs.'), action='store_false', default=True, dest='isolate_svgs')
    @argument_group('PNG', 'PNG specific arguments')
    @argument('-u', '--units', type=str, choices=['px', 'in', 'cm', 'mm'], help=textwrap.dedent('\n        Units of png plotting device sent as an argument to *png* in R. One of\n        ["px", "in", "cm", "mm"].'))
    @argument('-r', '--res', type=int, help=textwrap.dedent('\n        Resolution of png plotting device sent as an argument to *png* in R.\n        Defaults to 72 if *units* is one of ["in", "cm", "mm"].'))
    @argument('--type', type=str, choices=['cairo', 'cairo-png', 'Xlib', 'quartz'], help=textwrap.dedent('\n        Type device used to generate the figure.\n        '))
    @argument('-c', '--converter', default=None, help=textwrap.dedent("\n        Name of local converter to use. A converter contains the rules to\n        convert objects back and forth between Python and R. If not\n        specified/None, the defaut converter for the magic's module is used\n        (that is rpy2's default converter + numpy converter + pandas converter\n        if all three are available)."))
    @argument('-d', '--display', default=None, help=textwrap.dedent('\n        Name of function to use to display the output of an R cell (the last\n        object or function call that does not have a left-hand side\n        assignment). That function will have the signature `(robject, args)`\n        where `robject` is the R objects that is an output of the cell, and\n        `args` a namespace with all parameters passed to the cell.\n        '))
    @argument('code', nargs='*')
    @needs_local_scope
    @line_cell_magic
    @no_var_expand
    def R(self, line, cell=None, local_ns=None):
        """
        Execute code in R, optionally returning results to the Python runtime.

        In line mode, this will evaluate an expression and convert the returned
        value to a Python object.  The return value is determined by rpy2's
        behaviour of returning the result of evaluating the final expression.

        Multiple R expressions can be executed by joining them with
        semicolons::

            In [9]: %R X=c(1,4,5,7); sd(X); mean(X)
            Out[9]: array([ 4.25])

        In cell mode, this will run a block of R code. The resulting value
        is printed if it would be printed when evaluating the same code
        within a standard R REPL.

        Nothing is returned to python by default in cell mode::

            In [10]: %%R
               ....: Y = c(2,4,3,9)
               ....: summary(lm(Y~X))

            Call:
            lm(formula = Y ~ X)

            Residuals:
                1     2     3     4
             0.88 -0.24 -2.28  1.64

            Coefficients:
                        Estimate Std. Error t value Pr(>|t|)
            (Intercept)   0.0800     2.3000   0.035    0.975
            X             1.0400     0.4822   2.157    0.164

            Residual standard error: 2.088 on 2 degrees of freedom
            Multiple R-squared: 0.6993,Adjusted R-squared: 0.549
            F-statistic: 4.651 on 1 and 2 DF,  p-value: 0.1638

        In the notebook, plots are published as the output of the cell::

            %R plot(X, Y)

        will create a scatter plot of X bs Y.

        If cell is not None and line has some R code, it is prepended to
        the R code in cell.

        Objects can be passed back and forth between rpy2 and python via the
        -i -o flags in line::

            In [14]: Z = np.array([1,4,5,10])

            In [15]: %R -i Z mean(Z)
            Out[15]: array([ 5.])


            In [16]: %R -o W W=Z*mean(Z)
            Out[16]: array([  5.,  20.,  25.,  50.])

            In [17]: W
            Out[17]: array([  5.,  20.,  25.,  50.])

        The return value is determined by these rules:

        * If the cell is not None (i.e., has contents), the magic returns None.

        * If the final line results in a NULL value when evaluated
          by rpy2, then None is returned.

        * No attempt is made to convert the final value to a structured array.
          Use %Rget to push a structured array.

        * If the -n flag is present, there is no return value.

        * A trailing ';' will also result in no return value as the last
          value in the line is an empty string.
        """
        args = parse_argstring(self.R, line)
        if cell is None:
            code = ''
            return_output = True
            line_mode = True
        else:
            code = cell
            return_output = False
            line_mode = False
        code = ' '.join(args.code) + code
        if local_ns is None:
            local_ns = {}
        converter = self._find_converter(args.converter, local_ns)
        if args.input:
            with localconverter(converter) as cv:
                for arg in ','.join(args.input).split(','):
                    self._import_name_into_r(arg, ro.globalenv, local_ns)
        if args.display:
            try:
                cell_display = local_ns[args.display]
            except KeyError:
                try:
                    cell_display = self.shell.user_ns[args.display]
                except KeyError:
                    raise NameError("name '%s' is not defined" % args.display)
        else:
            cell_display = CELL_DISPLAY_DEFAULT
        tmpd = self.setup_graphics(args)
        text_output = ''
        display_data = []
        try:
            if line_mode:
                for line in code.split(';'):
                    text_result, result, visible = self.eval(line)
                    text_output += text_result
                if text_result:
                    return_output = False
            else:
                text_result, result, visible = self.eval(code)
                text_output += text_result
                if visible:
                    with contextlib.ExitStack() as stack:
                        obj_in_module = rpy2.rinterface_lib.callbacks.obj_in_module
                        if self.cache_display_data:
                            stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, 'consolewrite_print', self.write_console_regular))
                        stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, 'consolewrite_warnerror', self.write_console_regular))
                        stack.enter_context(obj_in_module(rpy2.rinterface_lib.callbacks, '_WRITECONSOLE_EXCEPTION_LOG', '%s'))
                        cell_display(result, args)
                        text_output += self.flush()
        except RInterpreterError as e:
            print(e.stdout)
            if not e.stdout.endswith(e.err):
                print(e.err)
            raise e
        finally:
            if self.device in DEVICES_STATIC:
                ro.r('dev.off()')
            if text_output:
                displaypub.publish_display_data(source='RMagic.R', data={'text/plain': text_output})
            if self.device in DEVICES_STATIC_RASTER:
                for _ in display_figures(tmpd, format=self.device):
                    if self.cache_display_data:
                        display_data.append(_)
            elif self.device == 'svg':
                for _ in display_figures_svg(tmpd):
                    if self.cache_display_data:
                        display_data.append(_)
            if tmpd:
                rmtree(tmpd)
        if args.output:
            with localconverter(converter) as cv:
                for output in ','.join(args.output).split(','):
                    output_ipy = ro.globalenv.find(output)
                    self.shell.push({output: output_ipy})
        if self.cache_display_data:
            self.display_cache = display_data
        if return_output and (not args.noreturn):
            if result is not ri.NULL:
                with localconverter(converter) as cv:
                    res = cv.rpy2py(result)
                return res