import time
import functools
from hashlib import md5
from urllib.request import parse_http_list, parse_keqv_list
import cherrypy
from cherrypy._cpcompat import ntob, tonative
class HttpDigestAuthorization(object):
    """
    Parses a Digest Authorization header and performs
    re-calculation of the digest.
    """
    scheme = 'digest'

    def errmsg(self, s):
        return 'Digest Authorization header: %s' % s

    @classmethod
    def matches(cls, header):
        scheme, _, _ = header.partition(' ')
        return scheme.lower() == cls.scheme

    def __init__(self, auth_header, http_method, debug=False, accept_charset=DEFAULT_CHARSET[:]):
        self.http_method = http_method
        self.debug = debug
        if not self.matches(auth_header):
            raise ValueError('Authorization scheme is not "Digest"')
        self.auth_header = _try_decode_header(auth_header, accept_charset)
        scheme, params = self.auth_header.split(' ', 1)
        items = parse_http_list(params)
        paramsd = parse_keqv_list(items)
        self.realm = paramsd.get('realm')
        self.username = paramsd.get('username')
        self.nonce = paramsd.get('nonce')
        self.uri = paramsd.get('uri')
        self.method = paramsd.get('method')
        self.response = paramsd.get('response')
        self.algorithm = paramsd.get('algorithm', 'MD5').upper()
        self.cnonce = paramsd.get('cnonce')
        self.opaque = paramsd.get('opaque')
        self.qop = paramsd.get('qop')
        self.nc = paramsd.get('nc')
        if self.algorithm not in valid_algorithms:
            raise ValueError(self.errmsg("Unsupported value for algorithm: '%s'" % self.algorithm))
        has_reqd = self.username and self.realm and self.nonce and self.uri and self.response
        if not has_reqd:
            raise ValueError(self.errmsg('Not all required parameters are present.'))
        if self.qop:
            if self.qop not in valid_qops:
                raise ValueError(self.errmsg("Unsupported value for qop: '%s'" % self.qop))
            if not (self.cnonce and self.nc):
                raise ValueError(self.errmsg('If qop is sent then cnonce and nc MUST be present'))
        elif self.cnonce or self.nc:
            raise ValueError(self.errmsg('If qop is not sent, neither cnonce nor nc can be present'))

    def __str__(self):
        return 'authorization : %s' % self.auth_header

    def validate_nonce(self, s, key):
        """Validate the nonce.
        Returns True if nonce was generated by synthesize_nonce() and the
        timestamp is not spoofed, else returns False.

        s
            A string related to the resource, such as the hostname of
            the server.

        key
            A secret string known only to the server.

        Both s and key must be the same values which were used to synthesize
        the nonce we are trying to validate.
        """
        try:
            timestamp, hashpart = self.nonce.split(':', 1)
            s_timestamp, s_hashpart = synthesize_nonce(s, key, timestamp).split(':', 1)
            is_valid = s_hashpart == hashpart
            if self.debug:
                TRACE('validate_nonce: %s' % is_valid)
            return is_valid
        except ValueError:
            pass
        return False

    def is_nonce_stale(self, max_age_seconds=600):
        """Returns True if a validated nonce is stale. The nonce contains a
        timestamp in plaintext and also a secure hash of the timestamp.
        You should first validate the nonce to ensure the plaintext
        timestamp is not spoofed.
        """
        try:
            timestamp, hashpart = self.nonce.split(':', 1)
            if int(timestamp) + max_age_seconds > int(time.time()):
                return False
        except ValueError:
            pass
        if self.debug:
            TRACE('nonce is stale')
        return True

    def HA2(self, entity_body=''):
        """Returns the H(A2) string. See :rfc:`2617` section 3.2.2.3."""
        if self.qop is None or self.qop == 'auth':
            a2 = '%s:%s' % (self.http_method, self.uri)
        elif self.qop == 'auth-int':
            a2 = '%s:%s:%s' % (self.http_method, self.uri, H(entity_body))
        else:
            raise ValueError(self.errmsg('Unrecognized value for qop!'))
        return H(a2)

    def request_digest(self, ha1, entity_body=''):
        """Calculates the Request-Digest. See :rfc:`2617` section 3.2.2.1.

        ha1
            The HA1 string obtained from the credentials store.

        entity_body
            If 'qop' is set to 'auth-int', then A2 includes a hash
            of the "entity body".  The entity body is the part of the
            message which follows the HTTP headers. See :rfc:`2617` section
            4.3.  This refers to the entity the user agent sent in the
            request which has the Authorization header. Typically GET
            requests don't have an entity, and POST requests do.

        """
        ha2 = self.HA2(entity_body)
        if self.qop:
            req = '%s:%s:%s:%s:%s' % (self.nonce, self.nc, self.cnonce, self.qop, ha2)
        else:
            req = '%s:%s' % (self.nonce, ha2)
        if self.algorithm == 'MD5-sess':
            ha1 = H('%s:%s:%s' % (ha1, self.nonce, self.cnonce))
        digest = H('%s:%s' % (ha1, req))
        return digest