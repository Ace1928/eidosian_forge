from __future__ import annotations
import enum
from itertools import zip_longest
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union
from .visitors import anon_map
from .visitors import HasTraversalDispatch
from .visitors import HasTraverseInternals
from .visitors import InternalTraversal
from .visitors import prefix_anon_map
from .. import util
from ..inspection import inspect
from ..util import HasMemoized
from ..util.typing import Literal
from ..util.typing import Protocol
@classmethod
def _generate_cache_attrs(cls) -> Union[_CacheKeyTraversalDispatchType, Literal[CacheConst.NO_CACHE]]:
    """generate cache key dispatcher for a new class.

        This sets the _generated_cache_key_traversal attribute once called
        so should only be called once per class.

        """
    inherit_cache = cls.__dict__.get('inherit_cache', None)
    inherit = bool(inherit_cache)
    if inherit:
        _cache_key_traversal = getattr(cls, '_cache_key_traversal', None)
        if _cache_key_traversal is None:
            try:
                assert issubclass(cls, HasTraverseInternals)
                _cache_key_traversal = cls._traverse_internals
            except AttributeError:
                cls._generated_cache_key_traversal = NO_CACHE
                return NO_CACHE
        assert _cache_key_traversal is not NO_CACHE, f'class {cls} has _cache_key_traversal=NO_CACHE, which conflicts with inherit_cache=True'
        return _cache_key_traversal_visitor.generate_dispatch(cls, _cache_key_traversal, '_generated_cache_key_traversal')
    else:
        _cache_key_traversal = cls.__dict__.get('_cache_key_traversal', None)
        if _cache_key_traversal is None:
            _cache_key_traversal = cls.__dict__.get('_traverse_internals', None)
            if _cache_key_traversal is None:
                cls._generated_cache_key_traversal = NO_CACHE
                if inherit_cache is None and cls._hierarchy_supports_caching:
                    util.warn("Class %s will not make use of SQL compilation caching as it does not set the 'inherit_cache' attribute to ``True``.  This can have significant performance implications including some performance degradations in comparison to prior SQLAlchemy versions.  Set this attribute to True if this object can make use of the cache key generated by the superclass.  Alternatively, this attribute may be set to False which will disable this warning." % cls.__name__, code='cprf')
                return NO_CACHE
        return _cache_key_traversal_visitor.generate_dispatch(cls, _cache_key_traversal, '_generated_cache_key_traversal')