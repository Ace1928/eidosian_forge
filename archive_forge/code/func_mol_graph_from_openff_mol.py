from __future__ import annotations
import warnings
from pathlib import Path
import numpy as np
import pymatgen
from pymatgen.analysis.graphs import MoleculeGraph
from pymatgen.analysis.local_env import OpenBabelNN, metal_edge_extender
from pymatgen.core import Element, Molecule
def mol_graph_from_openff_mol(molecule: tk.Molecule) -> MoleculeGraph:
    """
    This is designed to closely mirror the graph structure generated by tk.Molecule.to_networkx

    Args:
        molecule (tk.Molecule): The OpenFF Molecule to convert.

    Returns:
        MoleculeGraph: The converted MoleculeGraph.
    """
    mol_graph = MoleculeGraph.with_empty_graph(Molecule([], []), name='none')
    p_table = {el.Z: str(el) for el in Element}
    total_charge = 0
    cum_atoms = 0
    coords = molecule.conformers[0].magnitude if molecule.conformers is not None else np.zeros((molecule.n_atoms, 3))
    for idx, atom in enumerate(molecule.atoms):
        mol_graph.insert_node(cum_atoms + idx, p_table[atom.atomic_number], coords[idx, :])
        mol_graph.graph.nodes[cum_atoms + idx]['atomic_number'] = atom.atomic_number
        mol_graph.graph.nodes[cum_atoms + idx]['is_aromatic'] = atom.is_aromatic
        mol_graph.graph.nodes[cum_atoms + idx]['stereochemistry'] = atom.stereochemistry
        partial_charge = None if atom.partial_charge is None else atom.partial_charge.magnitude
        mol_graph.graph.nodes[cum_atoms + idx]['partial_charge'] = partial_charge
        formal_charge = atom.formal_charge.magnitude
        mol_graph.graph.nodes[cum_atoms + idx]['formal_charge'] = formal_charge
        total_charge += formal_charge
    for bond in molecule.bonds:
        mol_graph.graph.add_edge(cum_atoms + bond.atom1_index, cum_atoms + bond.atom2_index, bond_order=bond.bond_order, is_aromatic=bond.is_aromatic, stereochemistry=bond.stereochemistry)
    cum_atoms += molecule.n_atoms
    mol_graph.molecule.set_charge_and_spin(charge=total_charge)
    return mol_graph