import unittest
import warnings
from io import BytesIO
from itertools import product
from os.path import join as pjoin
import numpy as np
import pytest
from numpy.testing import assert_allclose, assert_array_equal
from .. import ecat, minc1, minc2, parrec
from ..analyze import AnalyzeHeader
from ..arrayproxy import ArrayProxy, is_proxy
from ..casting import have_binary128, sctypes
from ..externals.netcdf import netcdf_file
from ..freesurfer.mghformat import MGHHeader
from ..nifti1 import Nifti1Header
from ..optpkg import optional_package
from ..spm2analyze import Spm2AnalyzeHeader
from ..spm99analyze import Spm99AnalyzeHeader
from ..testing import assert_dt_equal, clear_and_catch_warnings
from ..testing import data_path as DATA_PATH
from ..tmpdirs import InTemporaryDirectory
from ..volumeutils import apply_read_scaling
from .test_api_validators import ValidateAPI
from .test_parrec import EG_REC, VARY_REC
class TestAnalyzeProxyAPI(_TestProxyAPI):
    """Specific Analyze-type array proxy API test

    The analyze proxy extends the general API by adding read-only attributes
    ``slope, inter, offset``
    """
    proxy_class = ArrayProxy
    header_class = AnalyzeHeader
    shapes = ((2,), (2, 3), (2, 3, 4), (2, 3, 4, 5))
    has_slope = False
    has_inter = False
    data_dtypes = (np.uint8, np.int16, np.int32, np.float32, np.complex64, np.float64)
    array_order = 'F'
    settable_offset = True
    data_endian = '='

    def obj_params(self):
        """Iterator returning (``proxy_creator``, ``proxy_params``) pairs

        Each pair will be tested separately.

        ``proxy_creator`` is a function taking no arguments and returning (fresh
        proxy object, fileobj, header).  We need to pass this function rather
        than a proxy instance so we can recreate the proxy objects fresh for
        each of multiple tests run from the ``validate_xxx`` autogenerated test
        methods.  This allows the tests to modify the proxy instance without
        having an effect on the later tests in the same function.
        """
        if not self.settable_offset:
            offsets = (self.header_class().get_data_offset(),)
        else:
            offsets = (0, 16)
        slopes = (1.0, 2.0, float(np.float32(3.1416))) if self.has_slope else (1.0,)
        inters = (0.0, 10.0, float(np.float32(2.7183))) if self.has_inter else (0.0,)
        for shape, dtype, offset, slope, inter in product(self.shapes, self.data_dtypes, offsets, slopes, inters):
            n_els = np.prod(shape)
            dtype = np.dtype(dtype).newbyteorder(self.data_endian)
            arr = np.arange(n_els, dtype=dtype).reshape(shape)
            data = arr.tobytes(order=self.array_order)
            hdr = self.header_class()
            hdr.set_data_dtype(dtype)
            hdr.set_data_shape(shape)
            if self.settable_offset:
                hdr.set_data_offset(offset)
            if (slope, inter) == (1, 0):
                dtype_out = dtype
            else:
                hdr.set_slope_inter(slope, inter)
                s, i = hdr.get_slope_inter()
                tmp = apply_read_scaling(arr, 1.0 if s is None else s, 0.0 if i is None else i)
                dtype_out = tmp.dtype.type

            def sio_func():
                fio = BytesIO()
                fio.truncate(0)
                fio.seek(offset)
                fio.write(data)
                new_hdr = hdr.copy()
                return (self.proxy_class(fio, new_hdr), fio, new_hdr)
            params = dict(dtype=dtype, dtype_out=dtype_out, arr=arr.copy(), arr_out=arr.astype(dtype_out) * slope + inter, shape=shape, offset=offset, slope=slope, inter=inter)
            yield (sio_func, params)
            with InTemporaryDirectory():
                fname = 'data.bin'

                def fname_func():
                    with open(fname, 'wb') as fio:
                        fio.seek(offset)
                        fio.write(data)
                    new_hdr = hdr.copy()
                    return (self.proxy_class(fname, new_hdr), fname, new_hdr)
                params = params.copy()
                yield (fname_func, params)

    def validate_dtype(self, pmaker, params):
        prox, fio, hdr = pmaker()
        assert_dt_equal(prox.dtype, params['dtype'])
        with pytest.raises(AttributeError):
            prox.dtype = np.dtype(prox.dtype)

    def validate_slope_inter_offset(self, pmaker, params):
        prox, fio, hdr = pmaker()
        for attr_name in ('slope', 'inter', 'offset'):
            expected = params[attr_name]
            assert_array_equal(getattr(prox, attr_name), expected)
            with pytest.raises(AttributeError):
                setattr(prox, attr_name, expected)