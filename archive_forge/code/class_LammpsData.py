from __future__ import annotations
import itertools
import re
import warnings
from io import StringIO
from pathlib import Path
from typing import TYPE_CHECKING, Literal
import numpy as np
import pandas as pd
from monty.io import zopen
from monty.json import MSONable
from monty.serialization import loadfn
from ruamel.yaml import YAML
from pymatgen.core import Element, Lattice, Molecule, Structure
from pymatgen.core.operations import SymmOp
from pymatgen.util.io_utils import clean_lines
class LammpsData(MSONable):
    """Object for representing the data in a LAMMPS data file."""

    def __init__(self, box: LammpsBox, masses: pd.DataFrame, atoms: pd.DataFrame, velocities: pd.DataFrame=None, force_field: dict | None=None, topology: dict[str, pd.DataFrame] | None=None, atom_style: str='full') -> None:
        """
        This is a low level constructor designed to work with parsed
        data or other bridging objects (ForceField and Topology). Not
        recommended to use directly.

        Args:
            box (LammpsBox): Simulation box.
            masses (pandas.DataFrame): DataFrame with one column
                ["mass"] for Masses section.
            atoms (pandas.DataFrame): DataFrame with multiple columns
                for Atoms section. Column names vary with atom_style.
            velocities (pandas.DataFrame): DataFrame with three columns
                ["vx", "vy", "vz"] for Velocities section. Optional
                with default to None. If not None, its index should be
                consistent with atoms.
            force_fieldct (dict): Data for force field sections. Optional
                with default to None. Only keywords in force field and
                class 2 force field are valid keys, and each value is a
                DataFrame.
            topology (dict): Data for topology sections. Optional with
                default to None. Only keywords in topology are valid
                keys, and each value is a DataFrame.
            atom_style (str): Output atom_style. Default to "full".
        """
        if velocities is not None:
            assert len(velocities) == len(atoms), 'Inconsistency found between atoms and velocities'
        if force_field:
            all_ff_kws = SECTION_KEYWORDS['ff'] + SECTION_KEYWORDS['class2']
            force_field = {key: values for key, values in force_field.items() if key in all_ff_kws}
        if topology:
            topology = {key: values for key, values in topology.items() if key in SECTION_KEYWORDS['topology']}
        self.box = box
        self.masses = masses
        self.atoms = atoms
        self.velocities = velocities
        self.force_field = force_field
        self.topology = topology
        self.atom_style = atom_style

    def __str__(self) -> str:
        return self.get_str()

    def __repr__(self) -> str:
        return self.get_str()

    @property
    def structure(self) -> Structure:
        """
        Exports a periodic structure object representing the simulation
        box.

        Returns:
            Structure
        """
        masses = self.masses
        atoms = self.atoms.copy()
        if 'nx' in atoms.columns:
            atoms = atoms.drop(['nx', 'ny', 'nz'], axis=1)
        atoms['molecule-ID'] = 1
        ld_copy = type(self)(self.box, masses, atoms)
        topologies = ld_copy.disassemble()[-1]
        molecule = topologies[0].sites
        coords = molecule.cart_coords - np.array(self.box.bounds)[:, 0]
        species = molecule.species
        lattice = self.box.to_lattice()
        site_properties = {}
        if 'q' in atoms:
            site_properties['charge'] = atoms['q'].to_numpy()
        if self.velocities is not None:
            site_properties['velocities'] = self.velocities.to_numpy()
        return Structure(lattice, species, coords, coords_are_cartesian=True, site_properties=site_properties)

    def get_str(self, distance: int=6, velocity: int=8, charge: int=4, hybrid: bool=True) -> str:
        """
        Returns the string representation of LammpsData, essentially
        the string to be written to a file. Support hybrid style
        coeffs read and write.

        Args:
            distance (int): No. of significant figures to output for
                box settings (bounds and tilt) and atomic coordinates.
                Default to 6.
            velocity (int): No. of significant figures to output for
                velocities. Default to 8.
            charge (int): No. of significant figures to output for
                charges. Default to 4.
            hybrid (bool): Whether to write hybrid coeffs types.
                Default to True. If the data object has no hybrid
                coeffs types and has large coeffs section, one may
                use False to speed up the process. Otherwise, the
                default is recommended.

        Returns:
            String representation
        """
        file_template = 'Generated by pymatgen.io.lammps.data.LammpsData\n\n{stats}\n\n{box}\n\n{body}\n'
        box = self.box.get_str(distance)
        body_dict = {}
        body_dict['Masses'] = self.masses
        types = {}
        types['atom'] = len(self.masses)
        if self.force_field:
            all_ff_kws = SECTION_KEYWORDS['ff'] + SECTION_KEYWORDS['class2']
            ff_kws = [k for k in all_ff_kws if k in self.force_field]
            for kw in ff_kws:
                body_dict[kw] = self.force_field[kw]
                if kw in SECTION_KEYWORDS['ff'][2:]:
                    types[kw.lower()[:-7]] = len(self.force_field[kw])
        body_dict['Atoms'] = self.atoms
        counts = {}
        counts['atoms'] = len(self.atoms)
        if self.velocities is not None:
            body_dict['Velocities'] = self.velocities
        if self.topology:
            for kw in SECTION_KEYWORDS['topology']:
                if kw in self.topology:
                    body_dict[kw] = self.topology[kw]
                    counts[kw.lower()] = len(self.topology[kw])
        all_stats = list(counts.values()) + list(types.values())
        right_indent = len(str(max(all_stats)))
        count_lines = [f'{v:>{right_indent}}  {k}' for k, v in counts.items()]
        type_lines = [f'{v:>{right_indent}}  {k + ' types'}' for k, v in types.items()]
        stats = '\n'.join([*count_lines, '', *type_lines])

        def map_coords(q) -> str:
            return f'{q:.{distance}f}'

        def map_velos(q) -> str:
            return f'{q:.{velocity}f}'

        def map_charges(q) -> str:
            return f'{q:.{charge}f}'
        float_format = '{:.9f}'.format
        float_format_2 = '{:.1f}'.format
        int_format = '{:.0f}'.format
        default_formatters = {'x': map_coords, 'y': map_coords, 'z': map_coords, 'vx': map_velos, 'vy': map_velos, 'vz': map_velos, 'q': map_charges}
        coeffs_data_type = loadfn(str(MODULE_DIR / 'CoeffsDataType.yaml'))
        coeffs: dict[str, dict] = {}
        for style, types in coeffs_data_type.items():
            coeffs[style] = {}
            for type, formatter in types.items():
                coeffs[style][type] = {}
                for coeff, datatype in formatter.items():
                    if datatype == 'int_format':
                        coeffs[style][type][coeff] = int_format
                    elif datatype == 'float_format_2':
                        coeffs[style][type][coeff] = float_format_2
                    else:
                        coeffs[style][type][coeff] = float_format
        section_template = '{kw}\n\n{df}\n'
        parts = []
        for key, val in body_dict.items():
            index = key != 'PairIJ Coeffs'
            if hybrid and key in ['Bond Coeffs', 'Angle Coeffs', 'Dihedral Coeffs', 'Improper Coeffs']:
                dfs: list[pd.DataFrame] = np.array_split(val, len(val.index))
                df_string = ''
                for idx, df in enumerate(dfs):
                    if isinstance(df.iloc[0]['coeff1'], str):
                        try:
                            formatters = {**default_formatters, **coeffs[key][df.iloc[0]['coeff1']]}
                        except KeyError:
                            formatters = default_formatters
                        line_string = df.to_string(header=False, formatters=formatters, index_names=False, index=index, na_rep='')
                    else:
                        line_string = val.to_string(header=False, formatters=default_formatters, index_names=False, index=index, na_rep='').splitlines()[idx]
                    df_string += line_string.replace('nan', '').rstrip() + '\n'
            else:
                df_string = val.to_string(header=False, formatters=default_formatters, index_names=False, index=index, na_rep='')
            parts.append(section_template.format(kw=key, df=df_string))
        body = '\n'.join(parts)
        return file_template.format(stats=stats, box=box, body=body)

    def write_file(self, filename: str, distance: int=6, velocity: int=8, charge: int=4) -> None:
        """
        Writes LammpsData to file.

        Args:
            filename (str): Filename.
            distance (int): No. of significant figures to output for
                box settings (bounds and tilt) and atomic coordinates.
                Default to 6.
            velocity (int): No. of significant figures to output for
                velocities. Default to 8.
            charge (int): No. of significant figures to output for
                charges. Default to 4.
        """
        with open(filename, mode='w', encoding='utf-8') as file:
            file.write(self.get_str(distance=distance, velocity=velocity, charge=charge))

    def disassemble(self, atom_labels: Sequence[str] | None=None, guess_element: bool=True, ff_label: str='ff_map') -> tuple[LammpsBox, ForceField, list[Topology]]:
        """
        Breaks down LammpsData to building blocks
        (LammpsBox, ForceField and a series of Topology).
        RESTRICTIONS APPLIED:

        1. No complex force field defined not just on atom
            types, where the same type or equivalent types of topology
            may have more than one set of coefficients.
        2. No intermolecular topologies (with atoms from different
            molecule-ID) since a Topology object includes data for ONE
            molecule or structure only.

        Args:
            atom_labels ([str]): List of strings (must be different
                from one another) for labelling each atom type found in
                Masses section. Default to None, where the labels are
                automatically added based on either element guess or
                dummy specie assignment.
            guess_element (bool): Whether to guess the element based on
                its atomic mass. Default to True, otherwise dummy
                species "Qa", "Qb", ... will be assigned to various
                atom types. The guessed or assigned elements will be
                reflected on atom labels if atom_labels is None, as
                well as on the species of molecule in each Topology.
            ff_label (str): Site property key for labeling atoms of
                different types. Default to "ff_map".

        Returns:
            LammpsBox, ForceField, [Topology]
        """
        atoms_df = self.atoms.copy()
        if 'nx' in atoms_df.columns:
            atoms_df[['x', 'y', 'z']] += self.box.get_box_shift(atoms_df[['nx', 'ny', 'nz']].values)
        atoms_df = pd.concat([atoms_df, self.velocities], axis=1)
        mids = atoms_df.get('molecule-ID')
        if mids is None:
            unique_mids = [1]
            data_by_mols = {1: {'Atoms': atoms_df}}
        else:
            unique_mids = np.unique(mids)
            data_by_mols = {}
            for k in unique_mids:
                df = atoms_df[atoms_df['molecule-ID'] == k]
                data_by_mols[k] = {'Atoms': df}
        masses = self.masses.copy()
        masses['label'] = atom_labels
        unique_masses = np.unique(masses['mass'])
        if guess_element:
            ref_masses = {el.name: el.atomic_mass.real for el in Element}
            symbols = list(ref_masses)
            diff = np.abs(np.array(list(ref_masses.values())) - unique_masses[:, None])
            symbols = [Element(symbols[idx]).symbol for idx in np.argmin(diff, axis=1)]
        else:
            symbols = [f'Q{a}' for a in map(chr, range(97, 97 + len(unique_masses)))]
        for um, s in zip(unique_masses, symbols):
            masses.loc[masses['mass'] == um, 'element'] = s
        if atom_labels is None:
            for el, vc in masses['element'].value_counts().items():
                masses.loc[masses['element'] == el, 'label'] = [f'{el}{c}' for c in range(1, vc + 1)]
        assert masses['label'].nunique(dropna=False) == len(masses), 'Expecting unique atom label for each type'
        mass_info = [(row.label, row.mass) for row in masses.itertuples()]
        non_bond_coeffs: list = []
        topo_coeffs: dict = {}
        if self.force_field:
            if 'PairIJ Coeffs' in self.force_field:
                nbc = self.force_field['PairIJ Coeffs']
                nbc = nbc.sort_values(['id1', 'id2']).drop(['id1', 'id2'], axis=1)
                non_bond_coeffs = [list(t) for t in nbc.itertuples(index=False, name=None)]
            elif 'Pair Coeffs' in self.force_field:
                nbc = self.force_field['Pair Coeffs'].sort_index()
                non_bond_coeffs = [list(t) for t in nbc.itertuples(index=False, name=None)]
            topo_coeffs = {k: [] for k in SECTION_KEYWORDS['ff'][2:] if k in self.force_field}
            for kw in topo_coeffs:
                class2_coeffs = {k: list(v.itertuples(index=False, name=None)) for k, v in self.force_field.items() if k in CLASS2_KEYWORDS.get(kw, [])}
                ff_df = self.force_field[kw]
                for t in ff_df.itertuples(index=True, name=None):
                    coeffs_dict = {'coeffs': list(t[1:]), 'types': []}
                    if class2_coeffs:
                        coeffs_dict.update({k: list(v[t[0] - 1]) for k, v in class2_coeffs.items()})
                    topo_coeffs[kw].append(coeffs_dict)
        if self.topology:

            def label_topo(t) -> tuple:
                return tuple(masses.loc[atoms_df.loc[t, 'type'], 'label'])
            for key, values in self.topology.items():
                ff_kw = key[:-1] + ' Coeffs'
                for topo in values.itertuples(index=False, name=None):
                    topo_idx = topo[0] - 1
                    indices = list(topo[1:])
                    mids = atoms_df.loc[indices]['molecule-ID'].unique()
                    assert len(mids) == 1, 'Do not support intermolecular topology formed by atoms with different molecule-IDs'
                    label = label_topo(indices)
                    topo_coeffs[ff_kw][topo_idx]['types'].append(label)
                    if data_by_mols[mids[0]].get(key):
                        data_by_mols[mids[0]][key].append(indices)
                    else:
                        data_by_mols[mids[0]][key] = [indices]
        if any(topo_coeffs):
            for v in topo_coeffs.values():
                for coeffs_dict in v:
                    coeffs_dict['types'] = list(set(coeffs_dict['types']))
        ff = ForceField(mass_info=mass_info, nonbond_coeffs=non_bond_coeffs if any(non_bond_coeffs) else None, topo_coeffs=topo_coeffs if any(topo_coeffs) else None)
        topo_list = []
        for mid in unique_mids:
            data = data_by_mols[mid]
            atoms = data['Atoms']
            shift = min(atoms.index)
            type_ids = atoms['type']
            species = masses.loc[type_ids, 'element']
            labels = masses.loc[type_ids, 'label']
            coords = atoms[['x', 'y', 'z']]
            mol = Molecule(species.values, coords.values, site_properties={ff_label: labels.to_numpy()})
            charges = atoms.get('q')
            velocities = atoms[['vx', 'vy', 'vz']] if 'vx' in atoms.columns else None
            topologies = {}
            for kw in SECTION_KEYWORDS['topology']:
                if data.get(kw):
                    topologies[kw] = (np.array(data[kw]) - shift).tolist()
            topo_list.append(Topology(sites=mol, ff_label=ff_label, charges=charges, velocities=velocities, topologies=topologies or None))
        return (self.box, ff, topo_list)

    @classmethod
    def from_file(cls, filename: str, atom_style: str='full', sort_id: bool=False) -> Self:
        """
        Constructor that parses a file.

        Args:
            filename (str): Filename to read.
            atom_style (str): Associated atom_style. Default to "full".
            sort_id (bool): Whether sort each section by id. Default to
                True.
        """
        with zopen(filename, mode='rt') as file:
            lines = file.readlines()
        kw_pattern = '|'.join(itertools.chain(*SECTION_KEYWORDS.values()))
        section_marks = [idx for idx, line in enumerate(lines) if re.search(kw_pattern, line)]
        parts = np.split(lines, section_marks)
        float_group = '([0-9eE.+-]+)'
        header_pattern: dict[str, str] = {}
        header_pattern['counts'] = '^\\s*(\\d+)\\s+([a-zA-Z]+)$'
        header_pattern['types'] = '^\\s*(\\d+)\\s+([a-zA-Z]+)\\s+types$'
        header_pattern['bounds'] = '^\\s*{}$'.format('\\s+'.join([float_group] * 2 + ['([xyz])lo \\3hi']))
        header_pattern['tilt'] = '^\\s*{}$'.format('\\s+'.join([float_group] * 3 + ['xy xz yz']))
        header: dict[str, Any] = {'counts': {}, 'types': {}}
        bounds = {}
        for line in clean_lines(parts[0][1:]):
            match = None
            for k, v in header_pattern.items():
                match = re.match(v, line)
                if match:
                    break
            if match and k in ['counts', 'types']:
                header[k][match.group(2)] = int(match.group(1))
            elif match and k == 'bounds':
                g = match.groups()
                bounds[g[2]] = [float(i) for i in g[:2]]
            elif match and k == 'tilt':
                header['tilt'] = [float(i) for i in match.groups()]
        header['bounds'] = [bounds.get(i, [-0.5, 0.5]) for i in 'xyz']
        box = LammpsBox(header['bounds'], header.get('tilt'))

        def parse_section(sec_lines) -> tuple[str, pd.DataFrame]:
            title_info = sec_lines[0].split('#', 1)
            kw = title_info[0].strip()
            sio = StringIO(''.join(sec_lines[2:]))
            if kw.endswith('Coeffs') and (not kw.startswith('PairIJ')):
                df_list = [pd.read_csv(StringIO(line), header=None, comment='#', delim_whitespace=True) for line in sec_lines[2:] if line.strip()]
                df = pd.concat(df_list, ignore_index=True)
                names = ['id'] + [f'coeff{i}' for i in range(1, df.shape[1])]
            else:
                df = pd.read_csv(sio, header=None, comment='#', delim_whitespace=True)
                if kw == 'PairIJ Coeffs':
                    names = ['id1', 'id2'] + [f'coeff{i}' for i in range(1, df.shape[1] - 1)]
                    df.index.name = None
                elif kw in SECTION_HEADERS:
                    names = ['id'] + SECTION_HEADERS[kw]
                elif kw == 'Atoms':
                    names = ['id'] + ATOMS_HEADERS[atom_style]
                    if df.shape[1] == len(names):
                        pass
                    elif df.shape[1] == len(names) + 3:
                        names += ['nx', 'ny', 'nz']
                    else:
                        raise ValueError(f'Format in Atoms section inconsistent with atom_style={atom_style!r}')
                else:
                    raise NotImplementedError(f'Parser for {kw} section not implemented')
            df.columns = names
            if sort_id:
                sort_by = 'id' if kw != 'PairIJ Coeffs' else ['id1', 'id2']
                df = df.sort_values(sort_by)
            if 'id' in df.columns:
                df = df.set_index('id', drop=True)
                df.index.name = None
            return (kw, df)
        err_msg = 'Bad LAMMPS data format where '
        body = {}
        seen_atoms = False
        for part in parts[1:]:
            name, section = parse_section(part)
            if name == 'Atoms':
                seen_atoms = True
            if name in ['Velocities'] + SECTION_KEYWORDS['topology'] and (not seen_atoms):
                raise RuntimeError(f'{err_msg}{name} section appears before Atoms section')
            body[name] = section
        err_msg += 'Nos. of {} do not match between header and {} section'
        assert len(body['Masses']) == header['types']['atom'], err_msg.format('atom types', 'Masses')
        atom_sections = ['Atoms', 'Velocities'] if 'Velocities' in body else ['Atoms']
        for s in atom_sections:
            assert len(body[s]) == header['counts']['atoms'], err_msg.format('atoms', s)
        for s in SECTION_KEYWORDS['topology']:
            if header['counts'].get(s.lower(), 0) > 0:
                assert len(body[s]) == header['counts'][s.lower()], err_msg.format(s.lower(), s)
        items = {k.lower(): body[k] for k in ['Masses', 'Atoms']}
        items['velocities'] = body.get('Velocities')
        ff_kws = [k for k in body if k in SECTION_KEYWORDS['ff'] + SECTION_KEYWORDS['class2']]
        items['force_field'] = {k: body[k] for k in ff_kws} if ff_kws else None
        topo_kws = [k for k in body if k in SECTION_KEYWORDS['topology']]
        items['topology'] = {k: body[k] for k in topo_kws} if topo_kws else None
        items['atom_style'] = atom_style
        items['box'] = box
        return cls(**items)

    @classmethod
    def from_ff_and_topologies(cls, box: LammpsBox, ff: ForceField, topologies: Sequence[Topology], atom_style: str='full') -> Self:
        """
        Constructor building LammpsData from a ForceField object and a
        list of Topology objects. Do not support intermolecular
        topologies since a Topology object includes data for ONE
        molecule or structure only.

        Args:
            box (LammpsBox): Simulation box.
            ff (ForceField): ForceField object with data for Masses and
                force field sections.
            topologies ([Topology]): List of Topology objects with data
                for Atoms, Velocities and topology sections.
            atom_style (str): Output atom_style. Default to "full".
        """
        atom_types = set.union(*(t.species for t in topologies))
        assert atom_types.issubset(ff.maps['Atoms']), 'Unknown atom type found in topologies'
        items = {'box': box, 'atom_style': atom_style, 'masses': ff.masses, 'force_field': ff.force_field}
        mol_ids: list[int] = []
        charges: list[float] = []
        coords: list[np.ndarray] = []
        labels: list[str] = []
        v_collector: list | None = [] if topologies[0].velocities else None
        topo_collector: dict[str, list] = {'Bonds': [], 'Angles': [], 'Dihedrals': [], 'Impropers': []}
        topo_labels: dict[str, list] = {'Bonds': [], 'Angles': [], 'Dihedrals': [], 'Impropers': []}
        for idx, topo in enumerate(topologies):
            if topo.topologies:
                shift = len(labels)
                for k, v in topo.topologies.items():
                    topo_collector[k].append(np.array(v) + shift + 1)
                    topo_labels[k].extend([tuple((topo.type_by_sites[j] for j in t)) for t in v])
            if isinstance(v_collector, list):
                v_collector.append(topo.velocities)
            mol_ids.extend([idx + 1] * len(topo.sites))
            labels.extend(topo.type_by_sites)
            coords.append(topo.sites.cart_coords)
            charges.extend(topo.charges or [0.0] * len(topo.sites))
        atoms = pd.DataFrame(np.concatenate(coords), columns=['x', 'y', 'z'])
        atoms['molecule-ID'] = mol_ids
        atoms['q'] = charges
        atoms['type'] = list(map(ff.maps['Atoms'].get, labels))
        atoms.index += 1
        atoms = atoms[ATOMS_HEADERS[atom_style]]
        velocities = None
        if v_collector:
            velocities = pd.DataFrame(np.concatenate(v_collector), columns=SECTION_HEADERS['Velocities'])
            velocities.index += 1
        topology = {key: pd.DataFrame([]) for key, values in topo_labels.items() if len(values) > 0}
        for key in topology:
            df = pd.DataFrame(np.concatenate(topo_collector[key]), columns=SECTION_HEADERS[key][1:])
            df['type'] = list(map(ff.maps[key].get, topo_labels[key]))
            if any(pd.isna(df['type'])):
                warnings.warn(f'Undefined {key.lower()} detected and removed')
                df = df.dropna(subset=['type'])
                df = df.reset_index(drop=True)
            df.index += 1
            topology[key] = df[SECTION_HEADERS[key]]
        topology = {key: values for key, values in topology.items() if not values.empty}
        items.update({'atoms': atoms, 'velocities': velocities, 'topology': topology})
        return cls(**items)

    @classmethod
    def from_structure(cls, structure: Structure, ff_elements: Sequence[str] | None=None, atom_style: Literal['atomic', 'charge']='charge', is_sort: bool=False) -> Self:
        """
        Simple constructor building LammpsData from a structure without
        force field parameters and topologies.

        Args:
            structure (Structure): Input structure.
            ff_elements ([str]): List of strings of elements that must
                be present due to force field settings but not
                necessarily in the structure. Default to None.
            atom_style (str): Choose between "atomic" (neutral) and
                "charge" (charged). Default to "charge".
            is_sort (bool): whether to sort sites
        """
        struct = structure.get_sorted_structure() if is_sort else structure.copy()
        box, symm_op = lattice_2_lmpbox(struct.lattice)
        coords = symm_op.operate_multi(struct.cart_coords)
        site_properties = struct.site_properties
        if 'velocities' in site_properties:
            velos = np.array(struct.site_properties['velocities'])
            rot = SymmOp.from_rotation_and_translation(symm_op.rotation_matrix)
            rot_velos = rot.operate_multi(velos)
            site_properties['velocities'] = rot_velos
        boxed_s = Structure(box.to_lattice(), struct.species, coords, site_properties=site_properties, coords_are_cartesian=True)
        symbols = list(struct.symbol_set)
        if ff_elements:
            symbols.extend(ff_elements)
        elements = sorted((Element(el) for el in set(symbols)))
        mass_info = [tuple([i.symbol] * 2) for i in elements]
        ff = ForceField(mass_info)
        topo = Topology(boxed_s)
        return cls.from_ff_and_topologies(box=box, ff=ff, topologies=[topo], atom_style=atom_style)

    def set_charge_atom(self, charges: dict[int, float]) -> None:
        """
        Set the charges of specific atoms of the data.

        Args:
            charges: A dictionary with atom indexes as keys and
                charges as values, e.g., to set the charge
                of the atom with index 3 to -2, use `{3: -2}`.
        """
        for iat, q in charges.items():
            self.atoms.loc[iat, 'q'] = q

    def set_charge_atom_type(self, charges: dict[str | int, float]) -> None:
        """
        Add or modify charges of all atoms of a given type in the data.

        Args:
            charges: Dict containing the charges for the atom types to set.
                The dict should contain atom types as integers or labels and charges.
                Example: change the charge of Li atoms to +3:
                    charges={"Li": 3}
                    charges={1: 3} if Li atoms are of type 1
        """
        for iat, q in charges.items():
            if isinstance(iat, str):
                mass_iat = Element(iat).atomic_mass
                iat = self.masses.loc[self.masses['mass'] == mass_iat].index[0]
            self.atoms.loc[self.atoms['type'] == iat, 'q'] = q