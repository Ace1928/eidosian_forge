from __future__ import annotations
import enum
import functools
import re
import types
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Match
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes  # noqa
from . import exc
from ._typing import _O
from ._typing import insp_is_aliased_class
from ._typing import insp_is_mapper
from ._typing import prop_is_relationship
from .base import _class_to_mapper as _class_to_mapper
from .base import _MappedAnnotationBase
from .base import _never_set as _never_set  # noqa: F401
from .base import _none_set as _none_set  # noqa: F401
from .base import attribute_str as attribute_str  # noqa: F401
from .base import class_mapper as class_mapper
from .base import DynamicMapped
from .base import InspectionAttr as InspectionAttr
from .base import instance_str as instance_str  # noqa: F401
from .base import Mapped
from .base import object_mapper as object_mapper
from .base import object_state as object_state  # noqa: F401
from .base import opt_manager_of_class
from .base import ORMDescriptor
from .base import state_attribute_str as state_attribute_str  # noqa: F401
from .base import state_class_str as state_class_str  # noqa: F401
from .base import state_str as state_str  # noqa: F401
from .base import WriteOnlyMapped
from .interfaces import CriteriaOption
from .interfaces import MapperProperty as MapperProperty
from .interfaces import ORMColumnsClauseRole
from .interfaces import ORMEntityColumnsClauseRole
from .interfaces import ORMFromClauseRole
from .path_registry import PathRegistry as PathRegistry
from .. import event
from .. import exc as sa_exc
from .. import inspection
from .. import sql
from .. import util
from ..engine.result import result_tuple
from ..sql import coercions
from ..sql import expression
from ..sql import lambdas
from ..sql import roles
from ..sql import util as sql_util
from ..sql import visitors
from ..sql._typing import is_selectable
from ..sql.annotation import SupportsCloneAnnotations
from ..sql.base import ColumnCollection
from ..sql.cache_key import HasCacheKey
from ..sql.cache_key import MemoizedHasCacheKey
from ..sql.elements import ColumnElement
from ..sql.elements import KeyedColumnElement
from ..sql.selectable import FromClause
from ..util.langhelpers import MemoizedSlots
from ..util.typing import de_stringify_annotation as _de_stringify_annotation
from ..util.typing import (
from ..util.typing import eval_name_only as _eval_name_only
from ..util.typing import is_origin_of_cls
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import typing_get_origin
class AliasedClass(inspection.Inspectable['AliasedInsp[_O]'], ORMColumnsClauseRole[_O]):
    """Represents an "aliased" form of a mapped class for usage with Query.

    The ORM equivalent of a :func:`~sqlalchemy.sql.expression.alias`
    construct, this object mimics the mapped class using a
    ``__getattr__`` scheme and maintains a reference to a
    real :class:`~sqlalchemy.sql.expression.Alias` object.

    A primary purpose of :class:`.AliasedClass` is to serve as an alternate
    within a SQL statement generated by the ORM, such that an existing
    mapped entity can be used in multiple contexts.   A simple example::

        # find all pairs of users with the same name
        user_alias = aliased(User)
        session.query(User, user_alias).\\
                        join((user_alias, User.id > user_alias.id)).\\
                        filter(User.name == user_alias.name)

    :class:`.AliasedClass` is also capable of mapping an existing mapped
    class to an entirely new selectable, provided this selectable is column-
    compatible with the existing mapped selectable, and it can also be
    configured in a mapping as the target of a :func:`_orm.relationship`.
    See the links below for examples.

    The :class:`.AliasedClass` object is constructed typically using the
    :func:`_orm.aliased` function.   It also is produced with additional
    configuration when using the :func:`_orm.with_polymorphic` function.

    The resulting object is an instance of :class:`.AliasedClass`.
    This object implements an attribute scheme which produces the
    same attribute and method interface as the original mapped
    class, allowing :class:`.AliasedClass` to be compatible
    with any attribute technique which works on the original class,
    including hybrid attributes (see :ref:`hybrids_toplevel`).

    The :class:`.AliasedClass` can be inspected for its underlying
    :class:`_orm.Mapper`, aliased selectable, and other information
    using :func:`_sa.inspect`::

        from sqlalchemy import inspect
        my_alias = aliased(MyClass)
        insp = inspect(my_alias)

    The resulting inspection object is an instance of :class:`.AliasedInsp`.


    .. seealso::

        :func:`.aliased`

        :func:`.with_polymorphic`

        :ref:`relationship_aliased_class`

        :ref:`relationship_to_window_function`


    """
    __name__: str

    def __init__(self, mapped_class_or_ac: _EntityType[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False, with_polymorphic_mappers: Optional[Sequence[Mapper[Any]]]=None, with_polymorphic_discriminator: Optional[ColumnElement[Any]]=None, base_alias: Optional[AliasedInsp[Any]]=None, use_mapper_path: bool=False, represents_outer_join: bool=False):
        insp = cast('_InternalEntityType[_O]', inspection.inspect(mapped_class_or_ac))
        mapper = insp.mapper
        nest_adapters = False
        if alias is None:
            if insp.is_aliased_class and insp.selectable._is_subquery:
                alias = insp.selectable.alias()
            else:
                alias = mapper._with_polymorphic_selectable._anonymous_fromclause(name=name, flat=flat)
        elif insp.is_aliased_class:
            nest_adapters = True
        assert alias is not None
        self._aliased_insp = AliasedInsp(self, insp, alias, name, with_polymorphic_mappers if with_polymorphic_mappers else mapper.with_polymorphic_mappers, with_polymorphic_discriminator if with_polymorphic_discriminator is not None else mapper.polymorphic_on, base_alias, use_mapper_path, adapt_on_names, represents_outer_join, nest_adapters)
        self.__name__ = f'aliased({mapper.class_.__name__})'

    @classmethod
    def _reconstitute_from_aliased_insp(cls, aliased_insp: AliasedInsp[_O]) -> AliasedClass[_O]:
        obj = cls.__new__(cls)
        obj.__name__ = f'aliased({aliased_insp.mapper.class_.__name__})'
        obj._aliased_insp = aliased_insp
        if aliased_insp._is_with_polymorphic:
            for sub_aliased_insp in aliased_insp._with_polymorphic_entities:
                if sub_aliased_insp is not aliased_insp:
                    ent = AliasedClass._reconstitute_from_aliased_insp(sub_aliased_insp)
                    setattr(obj, sub_aliased_insp.class_.__name__, ent)
        return obj

    def __getattr__(self, key: str) -> Any:
        try:
            _aliased_insp = self.__dict__['_aliased_insp']
        except KeyError:
            raise AttributeError()
        else:
            target = _aliased_insp._target
            attr = getattr(target, key)
        if hasattr(attr, '__call__') and hasattr(attr, '__self__'):
            return types.MethodType(attr.__func__, self)
        if hasattr(attr, '__get__'):
            attr = attr.__get__(None, self)
        if hasattr(attr, 'adapt_to_entity'):
            attr = attr.adapt_to_entity(_aliased_insp)
            setattr(self, key, attr)
        return attr

    def _get_from_serialized(self, key: str, mapped_class: _O, aliased_insp: AliasedInsp[_O]) -> Any:
        attr = getattr(mapped_class, key)
        if hasattr(attr, '__call__') and hasattr(attr, '__self__'):
            return types.MethodType(attr.__func__, self)
        if hasattr(attr, '__get__'):
            attr = attr.__get__(None, self)
        if hasattr(attr, 'adapt_to_entity'):
            aliased_insp._weak_entity = weakref.ref(self)
            attr = attr.adapt_to_entity(aliased_insp)
            setattr(self, key, attr)
        return attr

    def __repr__(self) -> str:
        return '<AliasedClass at 0x%x; %s>' % (id(self), self._aliased_insp._target.__name__)

    def __str__(self) -> str:
        return str(self._aliased_insp)