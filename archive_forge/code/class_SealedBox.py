from typing import ClassVar, Generic, Optional, Type, TypeVar
import nacl.bindings
from nacl import encoding
from nacl import exceptions as exc
from nacl.encoding import Encoder
from nacl.utils import EncryptedMessage, StringFixer, random
class SealedBox(Generic[_Key], encoding.Encodable, StringFixer):
    """
    The SealedBox class boxes and unboxes messages addressed to
    a specified key-pair by using ephemeral sender's keypairs,
    whose private part will be discarded just after encrypting
    a single plaintext message.

    The ciphertexts generated by :class:`~nacl.public.SecretBox` include
    the public part of the ephemeral key before the :class:`~nacl.public.Box`
    ciphertext.

    :param recipient_key: a :class:`~nacl.public.PublicKey` used to encrypt
        messages and derive nonces, or a :class:`~nacl.public.PrivateKey` used
        to decrypt messages.

    .. versionadded:: 1.2
    """
    _public_key: bytes
    _private_key: Optional[bytes]

    def __init__(self, recipient_key: _Key):
        if isinstance(recipient_key, PublicKey):
            self._public_key = recipient_key.encode(encoder=encoding.RawEncoder)
            self._private_key = None
        elif isinstance(recipient_key, PrivateKey):
            self._private_key = recipient_key.encode(encoder=encoding.RawEncoder)
            self._public_key = recipient_key.public_key.encode(encoder=encoding.RawEncoder)
        else:
            raise exc.TypeError('SealedBox must be created from a PublicKey or a PrivateKey')

    def __bytes__(self) -> bytes:
        return self._public_key

    def encrypt(self, plaintext: bytes, encoder: encoding.Encoder=encoding.RawEncoder) -> bytes:
        """
        Encrypts the plaintext message using a random-generated ephemeral
        keypair and returns a "composed ciphertext", containing both
        the public part of the keypair and the ciphertext proper,
        encoded with the encoder.

        The private part of the ephemeral key-pair will be scrubbed before
        returning the ciphertext, therefore, the sender will not be able to
        decrypt the generated ciphertext.

        :param plaintext: [:class:`bytes`] The plaintext message to encrypt
        :param encoder: The encoder to use to encode the ciphertext
        :return bytes: encoded ciphertext
        """
        ciphertext = nacl.bindings.crypto_box_seal(plaintext, self._public_key)
        encoded_ciphertext = encoder.encode(ciphertext)
        return encoded_ciphertext

    def decrypt(self: 'SealedBox[PrivateKey]', ciphertext: bytes, encoder: encoding.Encoder=encoding.RawEncoder) -> bytes:
        """
        Decrypts the ciphertext using the ephemeral public key enclosed
        in the ciphertext and the SealedBox private key, returning
        the plaintext message.

        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt
        :param encoder: The encoder used to decode the ciphertext.
        :return bytes: The original plaintext
        :raises TypeError: if this SealedBox was created with a
            :class:`~nacl.public.PublicKey` rather than a
            :class:`~nacl.public.PrivateKey`.
        """
        ciphertext = encoder.decode(ciphertext)
        if self._private_key is None:
            raise TypeError('SealedBoxes created with a public key cannot decrypt')
        plaintext = nacl.bindings.crypto_box_seal_open(ciphertext, self._public_key, self._private_key)
        return plaintext