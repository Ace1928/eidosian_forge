import pyomo.common.unittest as unittest
import pyomo.environ as pyo
from pyomo.common.dependencies import numpy as np, scipy_available, numpy_available
from pyomo.common.log import LoggingIntercept
from pyomo.repn.plugins.standard_form import LinearStandardFormCompiler
@unittest.skipIf(linear_solver is None, 'verifying results requires a linear solver')
def test_alternative_forms(self):
    m = pyo.ConcreteModel()
    m.x = pyo.Var()
    m.y = pyo.Var([0, 1, 3], bounds=lambda m, i: (-1 * (i % 2) * 5, 10 - 12 * (i // 2)))
    m.c = pyo.Constraint(expr=m.x + 2 * m.y[1] >= 3)
    m.d = pyo.Constraint(expr=m.y[1] + 4 * m.y[3] <= 5)
    m.e = pyo.Constraint(expr=pyo.inequality(-2, m.y[0] + 1 + 6 * m.y[1], 7))
    m.f = pyo.Constraint(expr=m.x + m.y[0] + 2 == 10)
    m.o = pyo.Objective([1, 3], rule=lambda m, i: m.x + i * 5 * m.y[i])
    m.o[1].sense = pyo.maximize
    col_order = [m.x, m.y[0], m.y[1], m.y[3]]
    m.o[1].deactivate()
    linear_solver.solve(m)
    m.o[1].activate()
    soln = [(v, v.value) for v in col_order]
    repn = LinearStandardFormCompiler().write(m, column_order=col_order)
    self.assertEqual(repn.rows, [(m.c, -1), (m.d, 1), (m.e, 1), (m.e, -1), (m.f, 1), (m.f, -1)])
    self.assertEqual(repn.x, [m.x, m.y[0], m.y[1], m.y[3]])
    ref = np.array([[-1, 0, -2, 0], [0, 0, 1, 4], [0, 1, 6, 0], [0, -1, -6, 0], [1, 1, 0, 0], [-1, -1, 0, 0]])
    self.assertTrue(np.all(repn.A == ref))
    self.assertTrue(np.all(repn.b == np.array([-3, 5, 6, 3, 8, -8])))
    self.assertTrue(np.all(repn.c == np.array([[-1, 0, -5, 0], [1, 0, 0, 15]])))
    self._verify_solution(soln, repn, False)
    repn = LinearStandardFormCompiler().write(m, nonnegative_vars=True, column_order=col_order)
    self.assertEqual(repn.rows, [(m.c, -1), (m.d, 1), (m.e, 1), (m.e, -1), (m.f, 1), (m.f, -1)])
    self.assertEqual(list(map(str, repn.x)), ['_neg_0', '_pos_0', 'y[0]', '_neg_2', '_pos_2', '_neg_3'])
    ref = np.array([[1, -1, 0, 2, -2, 0], [0, 0, 0, -1, 1, -4], [0, 0, 1, -6, 6, 0], [0, 0, -1, 6, -6, 0], [-1, 1, 1, 0, 0, 0], [1, -1, -1, 0, 0, 0]])
    self.assertTrue(np.all(repn.A == ref))
    self.assertTrue(np.all(repn.b == np.array([-3, 5, 6, 3, 8, -8])))
    self.assertTrue(np.all(repn.c == np.array([[1, -1, 0, 5, -5, 0], [-1, 1, 0, 0, 0, -15]])))
    self._verify_solution(soln, repn, False)
    repn = LinearStandardFormCompiler().write(m, slack_form=True, column_order=col_order)
    self.assertEqual(repn.rows, [(m.c, 1), (m.d, 1), (m.e, 1), (m.f, 1)])
    self.assertEqual(list(map(str, repn.x)), ['x', 'y[0]', 'y[1]', 'y[3]', '_slack_0', '_slack_1', '_slack_2'])
    self.assertEqual(list((v.bounds for v in repn.x)), [(None, None), (0, 10), (-5, 10), (-5, -2), (None, 0), (0, None), (-9, 0)])
    ref = np.array([[1, 0, 2, 0, 1, 0, 0], [0, 0, 1, 4, 0, 1, 0], [0, 1, 6, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0]])
    self.assertTrue(np.all(repn.A == ref))
    self.assertTrue(np.all(repn.b == np.array([3, 5, -3, 8])))
    self.assertTrue(np.all(repn.c == np.array([[-1, 0, -5, 0, 0, 0, 0], [1, 0, 0, 15, 0, 0, 0]])))
    self._verify_solution(soln, repn, True)
    repn = LinearStandardFormCompiler().write(m, slack_form=True, nonnegative_vars=True, column_order=col_order)
    self.assertEqual(repn.rows, [(m.c, 1), (m.d, 1), (m.e, 1), (m.f, 1)])
    self.assertEqual(list(map(str, repn.x)), ['_neg_0', '_pos_0', 'y[0]', '_neg_2', '_pos_2', '_neg_3', '_neg_4', '_slack_1', '_neg_6'])
    self.assertEqual(list((v.bounds for v in repn.x)), [(0, None), (0, None), (0, 10), (0, 5), (0, 10), (2, 5), (0, None), (0, None), (0, 9)])
    ref = np.array([[-1, 1, 0, -2, 2, 0, -1, 0, 0], [0, 0, 0, -1, 1, -4, 0, 1, 0], [0, 0, 1, -6, 6, 0, 0, 0, -1], [-1, 1, 1, 0, 0, 0, 0, 0, 0]])
    self.assertTrue(np.all(repn.A == ref))
    self.assertTrue(np.all(repn.b == np.array([3, 5, -3, 8])))
    ref = np.array([[1, -1, 0, 5, -5, 0, 0, 0, 0], [-1, 1, 0, 0, 0, -15, 0, 0, 0]])
    self.assertTrue(np.all(repn.c == ref))
    self._verify_solution(soln, repn, True)