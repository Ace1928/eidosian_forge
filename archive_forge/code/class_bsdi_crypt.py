import re
import logging; log = logging.getLogger(__name__)
from warnings import warn
from passlib.utils import safe_crypt, test_crypt, to_unicode
from passlib.utils.binary import h64, h64big
from passlib.utils.compat import byte_elem_value, u, uascii_to_str, unicode, suppress_cause
from passlib.crypto.des import des_encrypt_int_block
import passlib.utils.handlers as uh
class bsdi_crypt(uh.HasManyBackends, uh.HasRounds, uh.HasSalt, uh.GenericHandler):
    """This class implements the BSDi-Crypt password hash, and follows the :ref:`password-hash-api`.

    It supports a fixed-length salt, and a variable number of rounds.

    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:

    :type salt: str
    :param salt:
        Optional salt string.
        If not specified, one will be autogenerated (this is recommended).
        If specified, it must be 4 characters, drawn from the regexp range ``[./0-9A-Za-z]``.

    :type rounds: int
    :param rounds:
        Optional number of rounds to use.
        Defaults to 5001, must be between 1 and 16777215, inclusive.

    :type relaxed: bool
    :param relaxed:
        By default, providing an invalid value for one of the other
        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,
        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`
        will be issued instead. Correctable errors include ``rounds``
        that are too small or too large, and ``salt`` strings that are too long.

        .. versionadded:: 1.6

    .. versionchanged:: 1.6
        :meth:`hash` will now issue a warning if an even number of rounds is used
        (see :ref:`bsdi-crypt-security-issues` regarding weak DES keys).
    """
    name = 'bsdi_crypt'
    setting_kwds = ('salt', 'rounds')
    checksum_size = 11
    checksum_chars = uh.HASH64_CHARS
    min_salt_size = max_salt_size = 4
    salt_chars = uh.HASH64_CHARS
    default_rounds = 5001
    min_rounds = 1
    max_rounds = 16777215
    rounds_cost = 'linear'
    _hash_regex = re.compile(u('\n        ^\n        _\n        (?P<rounds>[./a-z0-9]{4})\n        (?P<salt>[./a-z0-9]{4})\n        (?P<chk>[./a-z0-9]{11})?\n        $'), re.X | re.I)

    @classmethod
    def from_string(cls, hash):
        hash = to_unicode(hash, 'ascii', 'hash')
        m = cls._hash_regex.match(hash)
        if not m:
            raise uh.exc.InvalidHashError(cls)
        rounds, salt, chk = m.group('rounds', 'salt', 'chk')
        return cls(rounds=h64.decode_int24(rounds.encode('ascii')), salt=salt, checksum=chk)

    def to_string(self):
        hash = u('_%s%s%s') % (h64.encode_int24(self.rounds).decode('ascii'), self.salt, self.checksum)
        return uascii_to_str(hash)
    _avoid_even_rounds = True

    @classmethod
    def using(cls, **kwds):
        subcls = super(bsdi_crypt, cls).using(**kwds)
        if not subcls.default_rounds & 1:
            warn('bsdi_crypt rounds should be odd, as even rounds may reveal weak DES keys', uh.exc.PasslibSecurityWarning)
        return subcls

    @classmethod
    def _generate_rounds(cls):
        rounds = super(bsdi_crypt, cls)._generate_rounds()
        return rounds | 1

    def _calc_needs_update(self, **kwds):
        if not self.rounds & 1:
            return True
        return super(bsdi_crypt, self)._calc_needs_update(**kwds)
    backends = ('os_crypt', 'builtin')

    @classmethod
    def _load_backend_os_crypt(cls):
        if test_crypt('test', '_/...lLDAxARksGCHin.'):
            cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)
            return True
        else:
            return False

    def _calc_checksum_os_crypt(self, secret):
        config = self.to_string()
        hash = safe_crypt(secret, config)
        if hash is None:
            return self._calc_checksum_builtin(secret)
        if not hash.startswith(config[:9]) or len(hash) != 20:
            raise uh.exc.CryptBackendError(self, config, hash)
        return hash[-11:]

    @classmethod
    def _load_backend_builtin(cls):
        cls._set_calc_checksum_backend(cls._calc_checksum_builtin)
        return True

    def _calc_checksum_builtin(self, secret):
        return _raw_bsdi_crypt(secret, self.rounds, self.salt.encode('ascii')).decode('ascii')