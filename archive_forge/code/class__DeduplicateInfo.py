import copy
import logging
import sys
import weakref
import textwrap
from collections import defaultdict
from contextlib import contextmanager
from inspect import isclass, currentframe
from io import StringIO
from itertools import filterfalse, chain
from operator import itemgetter, attrgetter
from pyomo.common.autoslots import AutoSlots
from pyomo.common.collections import Mapping
from pyomo.common.deprecation import deprecated, deprecation_warning, RenamedClass
from pyomo.common.formatting import StreamIndenter
from pyomo.common.gc_manager import PauseGC
from pyomo.common.log import is_debug_set
from pyomo.common.pyomo_typing import overload
from pyomo.common.timing import ConstructionTimer
from pyomo.core.base.component import (
from pyomo.core.base.enums import SortComponents, TraversalStrategy
from pyomo.core.base.global_set import UnindexedComponent_index
from pyomo.core.base.componentuid import ComponentUID
from pyomo.core.base.set import Any
from pyomo.core.base.var import Var
from pyomo.core.base.initializer import Initializer
from pyomo.core.base.indexed_component import (
from pyomo.opt.base import ProblemFormat, guess_format
from pyomo.opt import WriterFactory
class _DeduplicateInfo(object):
    """Class implementing a unique component data object filter

    This class implements :py:meth:`unique()`, which is an efficient
    Reference-aware filter that wraps a generator and returns only
    unique component data objects.  This is nominally the same as:

        seen = set()
        for data in iterator:
            if id(data) not in seen:
                seen.add(id(data))
                yield data

    However, it is aware of the existence of Reference components (and
    that the only way you should ever encounter a duplicate is through a
    Reference).  This allows it to avoid generating and storing the id()
    of every data object.

    """
    __slots__ = ('seen_components', 'seen_comp_thru_reference', 'seen_data')

    def __init__(self):
        self.seen_components = set()
        self.seen_comp_thru_reference = set()
        self.seen_data = set()

    def unique(self, comp, items, are_values):
        """Returns generator that filters duplicate _ComponentData objects from items

        Parameters
        ----------
        comp: ComponentBase
           The Component (indexed or scalar) that contains all
           _ComponentData returned by the `items` generator.  `comp` may
           be an IndexedComponent generated by :py:func:`Reference` (and
           hence may not own the component datas in `items`)

        items: generator
            Generator yielding either the values or the items from the
            `comp` Component.

        are_values: bool
            If `True`, `items` yields _ComponentData objects, otherwise,
            `items` yields `(index, _ComponentData)` tuples.

        """
        if comp.is_reference():
            seen_components_contains = self.seen_components.__contains__
            seen_comp_thru_reference_contains = self.seen_comp_thru_reference.__contains__
            seen_comp_thru_reference_add = self.seen_comp_thru_reference.add
            seen_data_contains = self.seen_data.__contains__
            seen_data_add = self.seen_data.add

            def has_been_seen(data):
                _id = id(data.parent_component())
                if seen_components_contains(_id):
                    return True
                if not seen_comp_thru_reference_contains(_id):
                    seen_comp_thru_reference_add(_id)
                _id = id(data)
                if seen_data_contains(_id):
                    return True
                else:
                    seen_data_add(_id)
                    return False
            if are_values:
                return filterfalse(has_been_seen, items)
            else:
                return filterfalse(lambda item: has_been_seen(item[1]), items)
        else:
            _id = id(comp)
            self.seen_components.add(_id)
            if _id not in self.seen_comp_thru_reference:
                return items
            else:
                seen_data_contains = self.seen_data.__contains__
                if are_values:
                    has_been_seen = lambda item: seen_data_contains(id(item))
                else:
                    has_been_seen = lambda item: seen_data_contains(id(item[1]))
                return filterfalse(has_been_seen, items)