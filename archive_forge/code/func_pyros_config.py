from collections.abc import Iterable
import logging
from pyomo.common.collections import ComponentSet
from pyomo.common.config import (
from pyomo.common.errors import ApplicationError, PyomoException
from pyomo.core.base import Var, _VarData
from pyomo.core.base.param import Param, _ParamData
from pyomo.opt import SolverFactory
from pyomo.contrib.pyros.util import ObjectiveType, setup_pyros_logger
from pyomo.contrib.pyros.uncertainty_sets import UncertaintySet
def pyros_config():
    CONFIG = ConfigDict('PyROS')
    CONFIG.declare('time_limit', ConfigValue(default=None, domain=NonNegativeFloat, doc='\n                Wall time limit for the execution of the PyROS solver\n                in seconds (including time spent by subsolvers).\n                If `None` is provided, then no time limit is enforced.\n                '))
    CONFIG.declare('keepfiles', ConfigValue(default=False, domain=bool, description='\n                Export subproblems with a non-acceptable termination status\n                for debugging purposes.\n                If True is provided, then the argument\n                `subproblem_file_directory` must also be specified.\n                '))
    CONFIG.declare('tee', ConfigValue(default=False, domain=bool, description='Output subordinate solver logs for all subproblems.'))
    CONFIG.declare('load_solution', ConfigValue(default=True, domain=bool, description='\n                Load final solution(s) found by PyROS to the deterministic\n                model provided.\n                '))
    CONFIG.declare('first_stage_variables', ConfigValue(default=[], domain=InputDataStandardizer(Var, _VarData, allow_repeats=False), description='First-stage (or design) variables.', visibility=1))
    CONFIG.declare('second_stage_variables', ConfigValue(default=[], domain=InputDataStandardizer(Var, _VarData, allow_repeats=False), description='Second-stage (or control) variables.', visibility=1))
    CONFIG.declare('uncertain_params', ConfigValue(default=[], domain=InputDataStandardizer(ctype=Param, cdatatype=_ParamData, ctype_validator=mutable_param_validator, allow_repeats=False), description='\n                Uncertain model parameters.\n                The `mutable` attribute for all uncertain parameter\n                objects should be set to True.\n                ', visibility=1))
    CONFIG.declare('uncertainty_set', ConfigValue(default=None, domain=IsInstance(UncertaintySet), description='\n                Uncertainty set against which the\n                final solution(s) returned by PyROS should be certified\n                to be robust.\n                ', visibility=1))
    CONFIG.declare('local_solver', ConfigValue(default=None, domain=SolverResolvable(solver_desc='local solver', require_available=True), description='Subordinate local NLP solver.', visibility=1))
    CONFIG.declare('global_solver', ConfigValue(default=None, domain=SolverResolvable(solver_desc='global solver', require_available=True), description='Subordinate global NLP solver.', visibility=1))
    CONFIG.declare('objective_focus', ConfigValue(default=ObjectiveType.nominal, domain=InEnum(ObjectiveType), description='\n                Choice of objective focus to optimize in the master problems.\n                Choices are: `ObjectiveType.worst_case`,\n                `ObjectiveType.nominal`.\n                ', doc='\n                Objective focus for the master problems:\n\n                - `ObjectiveType.nominal`:\n                  Optimize the objective function subject to the nominal\n                  uncertain parameter realization.\n                - `ObjectiveType.worst_case`:\n                  Optimize the objective function subject to the worst-case\n                  uncertain parameter realization.\n\n                By default, `ObjectiveType.nominal` is chosen.\n\n                A worst-case objective focus is required for certification\n                of robust optimality of the final solution(s) returned\n                by PyROS.\n                If a nominal objective focus is chosen, then only robust\n                feasibility is guaranteed.\n                '))
    CONFIG.declare('nominal_uncertain_param_vals', ConfigValue(default=[], domain=list, doc='\n                Nominal uncertain parameter realization.\n                Entries should be provided in an order consistent with the\n                entries of the argument `uncertain_params`.\n                If an empty list is provided, then the values of the `Param`\n                objects specified through `uncertain_params` are chosen.\n                '))
    CONFIG.declare('decision_rule_order', ConfigValue(default=0, domain=In([0, 1, 2]), description='\n                Order (or degree) of the polynomial decision rule functions\n                used for approximating the adjustability of the second stage\n                variables with respect to the uncertain parameters.\n                ', doc='\n                Order (or degree) of the polynomial decision rule functions\n                for approximating the adjustability of the second stage\n                variables with respect to the uncertain parameters.\n\n                Choices are:\n\n                - 0: static recourse\n                - 1: affine recourse\n                - 2: quadratic recourse\n                '))
    CONFIG.declare('solve_master_globally', ConfigValue(default=False, domain=bool, doc='\n                True to solve all master problems with the subordinate\n                global solver, False to solve all master problems with\n                the subordinate local solver.\n                Along with a worst-case objective focus\n                (see argument `objective_focus`),\n                solving the master problems to global optimality is required\n                for certification\n                of robust optimality of the final solution(s) returned\n                by PyROS. Otherwise, only robust feasibility is guaranteed.\n                '))
    CONFIG.declare('max_iter', ConfigValue(default=-1, domain=PositiveIntOrMinusOne(), description='\n                Iteration limit. If -1 is provided, then no iteration\n                limit is enforced.\n                '))
    CONFIG.declare('robust_feasibility_tolerance', ConfigValue(default=0.0001, domain=NonNegativeFloat, description='\n                Relative tolerance for assessing maximal inequality\n                constraint violations during the GRCS separation step.\n                '))
    CONFIG.declare('separation_priority_order', ConfigValue(default={}, domain=dict, doc='\n                Mapping from model inequality constraint names\n                to positive integers specifying the priorities\n                of their corresponding separation subproblems.\n                A higher integer value indicates a higher priority.\n                Constraints not referenced in the `dict` assume\n                a priority of 0.\n                Separation subproblems are solved in order of decreasing\n                priority.\n                '))
    CONFIG.declare('progress_logger', ConfigValue(default=default_pyros_solver_logger, domain=LoggerType(), doc='\n                Logger (or name thereof) used for reporting PyROS solver\n                progress. If `None` or a `str` is provided, then\n                ``progress_logger``\n                is cast to ``logging.getLogger(progress_logger)``.\n                In the default case, `progress_logger` is set to\n                a :class:`pyomo.contrib.pyros.util.PreformattedLogger`\n                object of level ``logging.INFO``.\n                '))
    CONFIG.declare('backup_local_solvers', ConfigValue(default=[], domain=SolverIterable(solver_desc='backup local solver', require_available=False, filter_by_availability=True), doc='\n                Additional subordinate local NLP optimizers to invoke\n                in the event the primary local NLP optimizer fails\n                to solve a subproblem to an acceptable termination condition.\n                '))
    CONFIG.declare('backup_global_solvers', ConfigValue(default=[], domain=SolverIterable(solver_desc='backup global solver', require_available=False, filter_by_availability=True), doc='\n                Additional subordinate global NLP optimizers to invoke\n                in the event the primary global NLP optimizer fails\n                to solve a subproblem to an acceptable termination condition.\n                '))
    CONFIG.declare('subproblem_file_directory', ConfigValue(default=None, domain=Path(), description='\n                Directory to which to export subproblems not successfully\n                solved to an acceptable termination condition.\n                In the event ``keepfiles=True`` is specified, a str or\n                path-like referring to an existing directory must be\n                provided.\n                '))
    CONFIG.declare('bypass_local_separation', ConfigValue(default=False, domain=bool, description='\n                This is an advanced option.\n                Solve all separation subproblems with the subordinate global\n                solver(s) only.\n                This option is useful for expediting PyROS\n                in the event that the subordinate global optimizer(s) provided\n                can quickly solve separation subproblems to global optimality.\n                '))
    CONFIG.declare('bypass_global_separation', ConfigValue(default=False, domain=bool, doc='\n                This is an advanced option.\n                Solve all separation subproblems with the subordinate local\n                solver(s) only.\n                If `True` is chosen, then robustness of the final solution(s)\n                returned by PyROS is not guaranteed, and a warning will\n                be issued at termination.\n                This option is useful for expediting PyROS\n                in the event that the subordinate global optimizer provided\n                cannot tractably solve separation subproblems to global\n                optimality.\n                '))
    CONFIG.declare('p_robustness', ConfigValue(default={}, domain=dict, doc="\n                This is an advanced option.\n                Add p-robustness constraints to all master subproblems.\n                If an empty dict is provided, then p-robustness constraints\n                are not added.\n                Otherwise, the dict must map a `str` of value ``'rho'``\n                to a non-negative `float`. PyROS automatically\n                specifies ``1 + p_robustness['rho']``\n                as an upper bound for the ratio of the\n                objective function value under any PyROS-sampled uncertain\n                parameter realization to the objective function under\n                the nominal parameter realization.\n                ", visibility=1))
    return CONFIG