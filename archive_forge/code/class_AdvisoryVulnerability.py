from __future__ import annotations
from typing import TYPE_CHECKING, Any, Union
from typing_extensions import TypedDict
import github.AdvisoryVulnerabilityPackage
from github.GithubObject import Attribute, NonCompletableGithubObject, NotSet
class AdvisoryVulnerability(NonCompletableGithubObject):
    """
    This class represents a package that is vulnerable to a parent SecurityAdvisory.
    The reference can be found here https://docs.github.com/en/rest/security-advisories/repository-advisories
    """

    @property
    def package(self) -> AdvisoryVulnerabilityPackage:
        """
        :type: :class:`github.AdvisoryVulnerability.AdvisoryVulnerability`
        """
        return self._package.value

    @property
    def patched_versions(self) -> str:
        """
        :type: string
        """
        return self._patched_versions.value

    @property
    def vulnerable_functions(self) -> list[str] | None:
        """
        :type: list of string
        """
        return self._vulnerable_functions.value

    @property
    def vulnerable_version_range(self) -> str | None:
        """
        :type: string
        """
        return self._vulnerable_version_range.value

    def _initAttributes(self) -> None:
        self._package: Attribute[AdvisoryVulnerabilityPackage] = NotSet
        self._patched_versions: Attribute[str] = NotSet
        self._vulnerable_functions: Attribute[list[str]] = NotSet
        self._vulnerable_version_range: Attribute[str] = NotSet

    def _useAttributes(self, attributes: dict[str, Any]) -> None:
        if 'package' in attributes:
            self._package = self._makeClassAttribute(github.AdvisoryVulnerabilityPackage.AdvisoryVulnerabilityPackage, attributes['package'])
        if 'patched_versions' in attributes:
            self._patched_versions = self._makeStringAttribute(attributes['patched_versions'])
        if 'vulnerable_functions' in attributes:
            self._vulnerable_functions = self._makeListOfStringsAttribute(attributes['vulnerable_functions'])
        if 'vulnerable_version_range' in attributes:
            self._vulnerable_version_range = self._makeStringAttribute(attributes['vulnerable_version_range'])

    @classmethod
    def _validate_vulnerability(cls, vulnerability: AdvisoryVulnerabilityInput) -> None:
        assert isinstance(vulnerability, (dict, cls)), vulnerability
        if isinstance(vulnerability, dict):
            assert 'package' in vulnerability, vulnerability
            package: SimpleAdvisoryVulnerabilityPackage = vulnerability['package']
            assert isinstance(package, dict), package
            assert 'ecosystem' in package, package
            assert isinstance(package['ecosystem'], str), package
            assert 'name' in package, package
            assert isinstance(package['name'], (str, type(None))), package
            assert 'patched_versions' in vulnerability, vulnerability
            assert isinstance(vulnerability['patched_versions'], (str, type(None))), vulnerability
            assert 'vulnerable_functions' in vulnerability, vulnerability
            assert isinstance(vulnerability['vulnerable_functions'], (list, type(None))), vulnerability
            assert 'vulnerable_functions' in vulnerability, vulnerability
            assert all((isinstance(vf, str) for vf in vulnerability['vulnerable_functions'])) if vulnerability['vulnerable_functions'] is not None else True, vulnerability
            assert 'vulnerable_version_range' in vulnerability, vulnerability
            assert isinstance(vulnerability['vulnerable_version_range'], (str, type(None))), vulnerability
        else:
            assert vulnerability.package is github.AdvisoryVulnerabilityPackage.AdvisoryVulnerabilityPackage, vulnerability

    @staticmethod
    def _to_github_dict(vulnerability: AdvisoryVulnerabilityInput) -> SimpleAdvisoryVulnerability:
        if isinstance(vulnerability, dict):
            vulnerability_package: SimpleAdvisoryVulnerabilityPackage = vulnerability['package']
            return {'package': {'ecosystem': vulnerability_package['ecosystem'], 'name': vulnerability_package['name']}, 'patched_versions': vulnerability['patched_versions'], 'vulnerable_functions': vulnerability['vulnerable_functions'], 'vulnerable_version_range': vulnerability['vulnerable_version_range']}
        return {'package': {'ecosystem': vulnerability.package.ecosystem, 'name': vulnerability.package.name}, 'patched_versions': vulnerability.patched_versions, 'vulnerable_functions': vulnerability.vulnerable_functions, 'vulnerable_version_range': vulnerability.vulnerable_version_range}