from __future__ import annotations
import abc
import itertools
import os
import re
import shutil
import warnings
from collections.abc import Sequence
from copy import deepcopy
from dataclasses import dataclass, field
from glob import glob
from itertools import chain
from pathlib import Path
from typing import TYPE_CHECKING, Any, Literal, Union, cast
from zipfile import ZipFile
import numpy as np
from monty.dev import deprecated
from monty.io import zopen
from monty.json import MSONable
from monty.serialization import loadfn
from pymatgen.analysis.structure_matcher import StructureMatcher
from pymatgen.core import Element, PeriodicSite, SiteCollection, Species, Structure
from pymatgen.io.core import InputGenerator
from pymatgen.io.vasp.inputs import Incar, Kpoints, Poscar, Potcar, VaspInput
from pymatgen.io.vasp.outputs import Outcar, Vasprun
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
from pymatgen.symmetry.bandstructure import HighSymmKpath
from pymatgen.util.due import Doi, due
def calculate_ng(self, max_prime_factor: int=7, must_inc_2: bool=True, custom_encut: float | None=None, custom_prec: str | None=None) -> tuple:
    """
        Calculates the NGX, NGY, and NGZ values using the information available in the INCAR and POTCAR
        This is meant to help with making initial guess for the FFT grid so we can interact with the Charge density API.

        Args:
            max_prime_factor (int): the valid prime factors of the grid size in each direction
                VASP has many different setting for this to handle many compiling options.
                For typical MPI options all prime factors up to 7 are allowed
            must_inc_2 (bool): Whether 2 must be a prime factor of the result. Defaults to True.
            custom_encut (float | None): Calculates the FFT grid parameters using a custom
                ENCUT that may be different from what is generated by the input set. Defaults to None.
                Do *not* use this unless you know what you are doing.
            custom_prec (str | None): Calculates the FFT grid parameters using a custom prec
                that may be different from what is generated by the input set. Defaults to None.
                Do *not* use this unless you know what you are doing.
        """
    _RYTOEV = 13.605826
    _AUTOA = 0.529177249
    if custom_encut is not None:
        encut = custom_encut
    elif self.incar.get('ENCUT', 0) > 0:
        encut = self.incar['ENCUT']
    else:
        encut = max((i_species.enmax for i_species in self.get_vasp_input()['POTCAR']))
    PREC = self.incar.get('PREC', 'Normal') if custom_prec is None else custom_prec
    if PREC[0].lower() in {'l', 'm', 'h'}:
        raise NotImplementedError('PREC = LOW/MEDIUM/HIGH from VASP 4.x and not supported, Please use NORMA/SINGLE/ACCURATE')
    if PREC[0].lower() not in {'a', 's', 'n', 'l', 'm', 'h'}:
        raise ValueError(f'PREC={PREC!r} does not exist. If this is no longer correct, please update this code.')
    CUTOFF = [np.sqrt(encut / _RYTOEV) / (2 * np.pi / (anorm / _AUTOA)) for anorm in self.poscar.structure.lattice.abc]
    _WFACT = 4 if PREC[0].lower() in {'a', 's'} else 3

    def next_g_size(cur_g_size):
        g_size = int(_WFACT * cur_g_size + 0.5)
        return next_num_with_prime_factors(g_size, max_prime_factor, must_inc_2)
    ng_vec = [*map(next_g_size, CUTOFF)]
    finer_g_scale = 2 if PREC[0].lower() in {'a', 'n'} else 1
    return (ng_vec, [ng_ * finer_g_scale for ng_ in ng_vec])