import collections
import re
import io
import itertools
import numbers
from os.path import dirname, join, abspath
from typing import Iterable, List, Sequence, Union
from qiskit.circuit import (
from qiskit.circuit.bit import Bit
from qiskit.circuit.classical import expr, types
from qiskit.circuit.controlflow import (
from qiskit.circuit.library import standard_gates
from qiskit.circuit.register import Register
from qiskit.circuit.tools import pi_check
from . import ast
from .experimental import ExperimentalFeatures
from .exceptions import QASM3ExporterError
from .printer import BasicPrinter
class QASM3Builder:
    """QASM3 builder constructs an AST from a QuantumCircuit."""
    builtins = (Barrier, Measure, Reset, Delay, BreakLoopOp, ContinueLoopOp)
    loose_bit_prefix = '_bit'
    loose_qubit_prefix = '_qubit'
    gate_parameter_prefix = '_gate_p'
    gate_qubit_prefix = '_gate_q'

    def __init__(self, quantumcircuit, includeslist, basis_gates, disable_constants, allow_aliasing, experimental=ExperimentalFeatures(0)):
        self._circuit_ctx = []
        self.push_context(quantumcircuit)
        self.includeslist = includeslist
        self._global_io_declarations = []
        self._global_classical_declarations = []
        self._gate_to_declare = {}
        self._opaque_to_declare = {}
        self._counter = itertools.count()
        self.disable_constants = disable_constants
        self.allow_aliasing = allow_aliasing
        self.global_namespace = GlobalNamespace(includeslist, basis_gates)
        self.experimental = experimental

    def _unique_name(self, prefix: str, scope: _Scope) -> str:
        table = scope.symbol_map
        name = basename = _escape_invalid_identifier(prefix)
        while name in table or name in _RESERVED_KEYWORDS:
            name = f'{basename}__generated{next(self._counter)}'
        return name

    def _register_gate(self, gate):
        self.global_namespace.register(gate)
        self._gate_to_declare[id(gate)] = gate

    def _register_opaque(self, instruction):
        if instruction not in self.global_namespace:
            self.global_namespace.register(instruction)
            self._opaque_to_declare[id(instruction)] = instruction

    def _register_variable(self, variable, scope: _Scope, name=None) -> ast.Identifier:
        """Register a variable in the symbol table for the given scope, returning the name that
        should be used to refer to the variable.  The same name will be returned by subsequent calls
        to :meth:`_lookup_variable` within the same scope.

        If ``name`` is given explicitly, it must not already be defined in the scope.
        """
        table = scope.symbol_map
        if name is not None:
            if name in _RESERVED_KEYWORDS:
                raise QASM3ExporterError(f"cannot reserve the keyword '{name}' as a variable name")
            if name in table:
                raise QASM3ExporterError(f"tried to reserve '{name}', but it is already used by '{table[name]}'")
        else:
            name = self._unique_name(variable.name, scope)
        identifier = ast.Identifier(name)
        table[identifier.string] = variable
        table[variable] = identifier
        return identifier

    def _reserve_variable_name(self, name: ast.Identifier, scope: _Scope) -> ast.Identifier:
        """Reserve a variable name in the given scope, raising a :class:`.QASM3ExporterError` if
        the name is already in use.

        This is useful for autogenerated names that the exporter itself reserves when dealing with
        objects that have no standard Terra object backing them.

        Returns the same identifier, for convenience in chaining."""
        table = scope.symbol_map
        if name.string in table:
            variable = table[name.string]
            raise QASM3ExporterError(f"tried to reserve '{name.string}', but it is already used by '{variable}'")
        table[name.string] = '<internal object>'
        return name

    def _lookup_variable(self, variable) -> ast.Identifier:
        """Lookup a Terra object within the current context, and return the name that should be used
        to represent it in OpenQASM 3 programmes."""
        if isinstance(variable, Bit):
            variable = self.current_scope().bit_map[variable]
        for scope in reversed(self.current_context()):
            if variable in scope.symbol_map:
                return scope.symbol_map[variable]
        raise KeyError(f"'{variable}' is not defined in the current context")

    def build_header(self):
        """Builds a Header"""
        version = ast.Version('3.0')
        includes = self.build_includes()
        return ast.Header(version, includes)

    def build_program(self):
        """Builds a Program"""
        self.hoist_declarations(self.global_scope(assert_=True).circuit.data)
        return ast.Program(self.build_header(), self.build_global_statements())

    def hoist_declarations(self, instructions):
        """Walks the definitions in gates/instructions to make a list of gates to declare."""
        for instruction in instructions:
            if isinstance(instruction.operation, ControlFlowOp):
                for block in instruction.operation.blocks:
                    self.hoist_declarations(block.data)
                continue
            if instruction.operation in self.global_namespace or isinstance(instruction.operation, self.builtins):
                continue
            if isinstance(instruction.operation, standard_gates.CXGate):
                if instruction.operation not in self.global_namespace:
                    self._register_gate(instruction.operation)
            if instruction.operation.definition is None:
                self._register_opaque(instruction.operation)
            elif not isinstance(instruction.operation, Gate):
                raise QASM3ExporterError('Exporting non-unitary instructions is not yet supported.')
            else:
                self.hoist_declarations(instruction.operation.definition.data)
                self._register_gate(instruction.operation)

    def global_scope(self, assert_=False):
        """Return the global circuit scope that is used as the basis of the full program.  If
        ``assert_=True``, then this raises :obj:`.QASM3ExporterError` if the current context is not
        the global one."""
        if assert_ and len(self._circuit_ctx) != 1 and (len(self._circuit_ctx[0]) != 1):
            raise QASM3ExporterError(f'Not currently in the global context. Current contexts are: {self._circuit_ctx}')
        return self._circuit_ctx[0][0]

    def current_scope(self):
        """Return the current circuit scope."""
        return self._circuit_ctx[-1][-1]

    def current_context(self):
        """Return the current context (list of scopes)."""
        return self._circuit_ctx[-1]

    def push_scope(self, circuit: QuantumCircuit, qubits: Iterable[Qubit], clbits: Iterable[Clbit]):
        """Push a new scope (like a ``for`` or ``while`` loop body) onto the current context
        stack."""
        current_map = self.current_scope().bit_map
        qubits = tuple((current_map[qubit] for qubit in qubits))
        clbits = tuple((current_map[clbit] for clbit in clbits))
        if circuit.num_qubits != len(qubits):
            raise QASM3ExporterError(f'Tried to push a scope whose circuit needs {circuit.num_qubits} qubits, but only provided {len(qubits)} qubits to create the mapping.')
        if circuit.num_clbits != len(clbits):
            raise QASM3ExporterError(f'Tried to push a scope whose circuit needs {circuit.num_clbits} clbits, but only provided {len(clbits)} clbits to create the mapping.')
        mapping = dict(itertools.chain(zip(circuit.qubits, qubits), zip(circuit.clbits, clbits)))
        self.current_context().append(_Scope(circuit, mapping, {}))

    def pop_scope(self) -> _Scope:
        """Pop the current scope (like a ``for`` or ``while`` loop body) off the current context
        stack."""
        if len(self._circuit_ctx[-1]) <= 1:
            raise QASM3ExporterError('Tried to pop a scope from the current context, but there are no current scopes.')
        return self._circuit_ctx[-1].pop()

    def push_context(self, outer_context: QuantumCircuit):
        """Push a new context (like for a ``gate`` or ``def`` body) onto the stack."""
        mapping = {bit: bit for bit in itertools.chain(outer_context.qubits, outer_context.clbits)}
        self._circuit_ctx.append([_Scope(outer_context, mapping, {})])

    def pop_context(self):
        """Pop the current context (like for a ``gate`` or ``def`` body) onto the stack."""
        if len(self._circuit_ctx) == 1:
            raise QASM3ExporterError('Tried to pop the current context, but that is the global context.')
        if len(self._circuit_ctx[-1]) != 1:
            raise QASM3ExporterError(f'Tried to pop the current context while there are still {len(self._circuit_ctx[-1]) - 1} unclosed scopes.')
        self._circuit_ctx.pop()

    def build_includes(self):
        """Builds a list of included files."""
        return [ast.Include(filename) for filename in self.includeslist]

    def build_global_statements(self) -> List[ast.Statement]:
        """Get a list of the statements that form the global scope of the program."""
        definitions = self.build_definitions()
        self.build_parameter_declarations()
        self.build_classical_declarations()
        context = self.global_scope(assert_=True).circuit
        quantum_declarations = self.build_quantum_declarations()
        quantum_instructions = self.build_quantum_instructions(context.data)
        return [statement for source in (self._global_io_declarations, definitions, self._global_classical_declarations, quantum_declarations, quantum_instructions) for statement in source]

    def build_definitions(self):
        """Builds all the definition."""
        ret = []
        for instruction in self._opaque_to_declare.values():
            ret.append(self.build_opaque_definition(instruction))
        for instruction in self._gate_to_declare.values():
            ret.append(self.build_gate_definition(instruction))
        return ret

    def build_opaque_definition(self, instruction):
        """Builds an Opaque gate definition as a CalibrationDefinition"""
        raise QASM3ExporterError(f'Exporting opaque instructions with pulse-level calibrations is not yet supported by the OpenQASM 3 exporter. Received this instruction, which appears opaque:\n{instruction}')

    def build_gate_definition(self, gate):
        """Builds a QuantumGateDefinition"""
        if isinstance(gate, standard_gates.CXGate):
            control, target = (ast.Identifier('c'), ast.Identifier('t'))
            call = ast.QuantumGateCall(ast.Identifier('U'), [control, target], parameters=[ast.Constant.PI, ast.IntegerLiteral(0), ast.Constant.PI], modifiers=[ast.QuantumGateModifier(ast.QuantumGateModifierName.CTRL)])
            return ast.QuantumGateDefinition(ast.QuantumGateSignature(ast.Identifier('cx'), [control, target]), ast.QuantumBlock([call]))
        self.push_context(gate.definition)
        signature = self.build_gate_signature(gate)
        body = ast.QuantumBlock(self.build_quantum_instructions(gate.definition.data))
        self.pop_context()
        return ast.QuantumGateDefinition(signature, body)

    def build_gate_signature(self, gate):
        """Builds a QuantumGateSignature"""
        name = self.global_namespace[gate]
        params = []
        definition = gate.definition
        scope = self.current_scope()
        for num in range(len(gate.params) - len(definition.parameters)):
            param_name = f'{self.gate_parameter_prefix}_{num}'
            params.append(self._reserve_variable_name(ast.Identifier(param_name), scope))
        params += [self._register_variable(param, scope) for param in definition.parameters]
        quantum_arguments = [self._register_variable(qubit, scope, self._unique_name(f'{self.gate_qubit_prefix}_{i}', scope)) for i, qubit in enumerate(definition.qubits)]
        return ast.QuantumGateSignature(ast.Identifier(name), quantum_arguments, params or None)

    def build_parameter_declarations(self):
        """Builds lists of the input, output and standard variables used in this program."""
        global_scope = self.global_scope(assert_=True)
        for parameter in global_scope.circuit.parameters:
            parameter_name = self._register_variable(parameter, global_scope)
            declaration = _infer_variable_declaration(global_scope.circuit, parameter, parameter_name)
            if declaration is None:
                continue
            if isinstance(declaration, ast.IODeclaration):
                self._global_io_declarations.append(declaration)
            else:
                self._global_classical_declarations.append(declaration)

    def build_classical_declarations(self):
        """Extend the global classical declarations with AST nodes declaring all the classical bits
        and registers.

        The behaviour of this function depends on the setting ``allow_aliasing``. If this
        is ``True``, then the output will be in the same form as the output of
        :meth:`.build_classical_declarations`, with the registers being aliases.  If ``False``, it
        will instead return a :obj:`.ast.ClassicalDeclaration` for each classical register, and one
        for the loose :obj:`.Clbit` instances, and will raise :obj:`QASM3ExporterError` if any
        registers overlap.
        """
        scope = self.global_scope(assert_=True)
        if any((len(scope.circuit.find_bit(q).registers) > 1 for q in scope.circuit.clbits)):
            if not self.allow_aliasing:
                raise QASM3ExporterError("Some classical registers in this circuit overlap and need aliases to express, but 'allow_aliasing' is false.")
            clbits = (ast.ClassicalDeclaration(ast.BitType(), self._register_variable(clbit, scope, self._unique_name(f'{self.loose_bit_prefix}{i}', scope))) for i, clbit in enumerate(scope.circuit.clbits))
            self._global_classical_declarations.extend(clbits)
            self._global_classical_declarations.extend(self.build_aliases(scope.circuit.cregs))
            return
        self._global_classical_declarations.extend((ast.ClassicalDeclaration(ast.BitType(), self._register_variable(clbit, scope, self._unique_name(f'{self.loose_bit_prefix}{i}', scope))) for i, clbit in enumerate(scope.circuit.clbits) if not scope.circuit.find_bit(clbit).registers))
        for register in scope.circuit.cregs:
            name = self._register_variable(register, scope)
            for i, bit in enumerate(register):
                scope.symbol_map[bit] = ast.SubscriptedIdentifier(name.string, ast.IntegerLiteral(i))
            self._global_classical_declarations.append(ast.ClassicalDeclaration(ast.BitArrayType(len(register)), name))

    def build_quantum_declarations(self):
        """Return a list of AST nodes declaring all the qubits in the current scope, and all the
        alias declarations for these qubits."""
        scope = self.global_scope(assert_=True)
        if scope.circuit.layout is not None:
            for i, bit in enumerate(scope.circuit.qubits):
                scope.symbol_map[bit] = ast.Identifier(f'${i}')
            return []
        if any((len(scope.circuit.find_bit(q).registers) > 1 for q in scope.circuit.qubits)):
            if not self.allow_aliasing:
                raise QASM3ExporterError("Some quantum registers in this circuit overlap and need aliases to express, but 'allow_aliasing' is false.")
            qubits = [ast.QuantumDeclaration(self._register_variable(qubit, scope, self._unique_name(f'{self.loose_qubit_prefix}{i}', scope))) for i, qubit in enumerate(scope.circuit.qubits)]
            return qubits + self.build_aliases(scope.circuit.qregs)
        loose_qubits = [ast.QuantumDeclaration(self._register_variable(qubit, scope, self._unique_name(f'{self.loose_qubit_prefix}{i}', scope))) for i, qubit in enumerate(scope.circuit.qubits) if not scope.circuit.find_bit(qubit).registers]
        registers = []
        for register in scope.circuit.qregs:
            name = self._register_variable(register, scope)
            for i, bit in enumerate(register):
                scope.symbol_map[bit] = ast.SubscriptedIdentifier(name.string, ast.IntegerLiteral(i))
            registers.append(ast.QuantumDeclaration(name, ast.Designator(ast.IntegerLiteral(len(register)))))
        return loose_qubits + registers

    def build_aliases(self, registers: Iterable[Register]) -> List[ast.AliasStatement]:
        """Return a list of alias declarations for the given registers.  The registers can be either
        classical or quantum."""
        scope = self.current_scope()
        out = []
        for register in registers:
            name = self._register_variable(register, scope)
            elements = [self._lookup_variable(bit) for bit in register]
            for i, bit in enumerate(register):
                scope.symbol_map[bit] = ast.SubscriptedIdentifier(name.string, ast.IntegerLiteral(i))
            out.append(ast.AliasStatement(name, ast.IndexSet(elements)))
        return out

    def build_quantum_instructions(self, instructions):
        """Builds a list of call statements"""
        ret = []
        for instruction in instructions:
            if isinstance(instruction.operation, ForLoopOp):
                ret.append(self.build_for_loop(instruction))
                continue
            if isinstance(instruction.operation, WhileLoopOp):
                ret.append(self.build_while_loop(instruction))
                continue
            if isinstance(instruction.operation, IfElseOp):
                ret.append(self.build_if_statement(instruction))
                continue
            if isinstance(instruction.operation, SwitchCaseOp):
                ret.extend(self.build_switch_statement(instruction))
                continue
            if isinstance(instruction.operation, Gate):
                nodes = [self.build_gate_call(instruction)]
            elif isinstance(instruction.operation, Barrier):
                operands = [self._lookup_variable(operand) for operand in instruction.qubits]
                nodes = [ast.QuantumBarrier(operands)]
            elif isinstance(instruction.operation, Measure):
                measurement = ast.QuantumMeasurement([self._lookup_variable(operand) for operand in instruction.qubits])
                qubit = self._lookup_variable(instruction.clbits[0])
                nodes = [ast.QuantumMeasurementAssignment(qubit, measurement)]
            elif isinstance(instruction.operation, Reset):
                nodes = [ast.QuantumReset(self._lookup_variable(operand)) for operand in instruction.qubits]
            elif isinstance(instruction.operation, Delay):
                nodes = [self.build_delay(instruction)]
            elif isinstance(instruction.operation, BreakLoopOp):
                nodes = [ast.BreakStatement()]
            elif isinstance(instruction.operation, ContinueLoopOp):
                nodes = [ast.ContinueStatement()]
            else:
                nodes = [self.build_subroutine_call(instruction)]
            if instruction.operation.condition is None:
                ret.extend(nodes)
            else:
                body = ast.ProgramBlock(nodes)
                ret.append(ast.BranchingStatement(self.build_expression(_lift_condition(instruction.operation.condition)), body))
        return ret

    def build_if_statement(self, instruction: CircuitInstruction) -> ast.BranchingStatement:
        """Build an :obj:`.IfElseOp` into a :obj:`.ast.BranchingStatement`."""
        condition = self.build_expression(_lift_condition(instruction.operation.condition))
        true_circuit = instruction.operation.blocks[0]
        self.push_scope(true_circuit, instruction.qubits, instruction.clbits)
        true_body = self.build_program_block(true_circuit.data)
        self.pop_scope()
        if len(instruction.operation.blocks) == 1:
            return ast.BranchingStatement(condition, true_body, None)
        false_circuit = instruction.operation.blocks[1]
        self.push_scope(false_circuit, instruction.qubits, instruction.clbits)
        false_body = self.build_program_block(false_circuit.data)
        self.pop_scope()
        return ast.BranchingStatement(condition, true_body, false_body)

    def build_switch_statement(self, instruction: CircuitInstruction) -> Iterable[ast.Statement]:
        """Build a :obj:`.SwitchCaseOp` into a :class:`.ast.SwitchStatement`."""
        real_target = self.build_expression(expr.lift(instruction.operation.target))
        global_scope = self.global_scope()
        target = self._reserve_variable_name(ast.Identifier(self._unique_name('switch_dummy', global_scope)), global_scope)
        self._global_classical_declarations.append(ast.ClassicalDeclaration(ast.IntType(), target, None))
        if ExperimentalFeatures.SWITCH_CASE_V1 in self.experimental:

            def case(values, case_block):
                values = [ast.DefaultCase() if v is CASE_DEFAULT else self.build_integer(v) for v in values]
                self.push_scope(case_block, instruction.qubits, instruction.clbits)
                case_body = self.build_program_block(case_block.data)
                self.pop_scope()
                return (values, case_body)
            return [ast.AssignmentStatement(target, real_target), ast.SwitchStatementPreview(target, (case(values, block) for values, block in instruction.operation.cases_specifier()))]
        cases = []
        default = None
        for values, block in instruction.operation.cases_specifier():
            self.push_scope(block, instruction.qubits, instruction.clbits)
            case_body = self.build_program_block(block.data)
            self.pop_scope()
            if CASE_DEFAULT in values:
                default = case_body
                continue
            cases.append(([self.build_integer(value) for value in values], case_body))
        return [ast.AssignmentStatement(target, real_target), ast.SwitchStatement(target, cases, default=default)]

    def build_while_loop(self, instruction: CircuitInstruction) -> ast.WhileLoopStatement:
        """Build a :obj:`.WhileLoopOp` into a :obj:`.ast.WhileLoopStatement`."""
        condition = self.build_expression(_lift_condition(instruction.operation.condition))
        loop_circuit = instruction.operation.blocks[0]
        self.push_scope(loop_circuit, instruction.qubits, instruction.clbits)
        loop_body = self.build_program_block(loop_circuit.data)
        self.pop_scope()
        return ast.WhileLoopStatement(condition, loop_body)

    def build_for_loop(self, instruction: CircuitInstruction) -> ast.ForLoopStatement:
        """Build a :obj:`.ForLoopOp` into a :obj:`.ast.ForLoopStatement`."""
        indexset, loop_parameter, loop_circuit = instruction.operation.params
        self.push_scope(loop_circuit, instruction.qubits, instruction.clbits)
        scope = self.current_scope()
        if loop_parameter is None:
            loop_parameter_ast = self._reserve_variable_name(ast.Identifier('_'), scope)
        else:
            loop_parameter_ast = self._register_variable(loop_parameter, scope)
        if isinstance(indexset, range):
            indexset_ast = ast.Range(start=self.build_integer(indexset.start), end=self.build_integer(indexset.stop - 1), step=self.build_integer(indexset.step) if indexset.step != 1 else None)
        else:
            try:
                indexset_ast = ast.IndexSet([self.build_integer(value) for value in indexset])
            except QASM3ExporterError:
                raise QASM3ExporterError(f"The values in OpenQASM 3 'for' loops must all be integers, but received '{indexset}'.") from None
        body_ast = self.build_program_block(loop_circuit)
        self.pop_scope()
        return ast.ForLoopStatement(indexset_ast, loop_parameter_ast, body_ast)

    def build_expression(self, node: expr.Expr) -> ast.Expression:
        """Build an expression."""
        return node.accept(_ExprBuilder(self._lookup_variable))

    def build_delay(self, instruction: CircuitInstruction) -> ast.QuantumDelay:
        """Build a built-in delay statement."""
        if instruction.clbits:
            raise QASM3ExporterError(f'Found a delay instruction acting on classical bits: {instruction}')
        duration_value, unit = (instruction.operation.duration, instruction.operation.unit)
        if unit == 'ps':
            duration = ast.DurationLiteral(1000 * duration_value, ast.DurationUnit.NANOSECOND)
        else:
            unit_map = {'ns': ast.DurationUnit.NANOSECOND, 'us': ast.DurationUnit.MICROSECOND, 'ms': ast.DurationUnit.MILLISECOND, 's': ast.DurationUnit.SECOND, 'dt': ast.DurationUnit.SAMPLE}
            duration = ast.DurationLiteral(duration_value, unit_map[unit])
        return ast.QuantumDelay(duration, [self._lookup_variable(qubit) for qubit in instruction.qubits])

    def build_integer(self, value) -> ast.IntegerLiteral:
        """Build an integer literal, raising a :obj:`.QASM3ExporterError` if the input is not
        actually an
        integer."""
        if not isinstance(value, numbers.Integral):
            raise QASM3ExporterError(f"'{value}' is not an integer")
        return ast.IntegerLiteral(int(value))

    def build_program_block(self, instructions):
        """Builds a ProgramBlock"""
        return ast.ProgramBlock(self.build_quantum_instructions(instructions))

    def _rebind_scoped_parameters(self, expression):
        """If the input is a :class:`.ParameterExpression`, rebind any internal
        :class:`.Parameter`\\ s so that their names match their names in the scope.  Other inputs
        are returned unchanged."""
        if not isinstance(expression, ParameterExpression):
            return expression
        return expression.subs({param: Parameter(self._lookup_variable(param).string) for param in expression.parameters})

    def build_gate_call(self, instruction: CircuitInstruction):
        """Builds a QuantumGateCall"""
        if isinstance(instruction.operation, standard_gates.UGate):
            gate_name = ast.Identifier('U')
        else:
            gate_name = ast.Identifier(self.global_namespace[instruction.operation])
        qubits = [self._lookup_variable(qubit) for qubit in instruction.qubits]
        if self.disable_constants:
            parameters = [ast.StringifyAndPray(self._rebind_scoped_parameters(param)) for param in instruction.operation.params]
        else:
            parameters = [ast.StringifyAndPray(pi_check(self._rebind_scoped_parameters(param), output='qasm')) for param in instruction.operation.params]
        return ast.QuantumGateCall(gate_name, qubits, parameters=parameters)