from __future__ import annotations
import glob
import os
from typing import Iterable
from oslo_concurrency import processutils as putils
from oslo_log import log as logging
from os_brick.initiator import linuxscsi
class LinuxFibreChannel(linuxscsi.LinuxSCSI):
    FC_HOST_SYSFS_PATH = '/sys/class/fc_host'
    HBA_ATTRIBUTES = ('port_name', 'node_name', 'port_state')

    def _get_target_fc_transport_path(self, path, wwpn, lun):
        """Scan target in the fc_transport path

        Scan for target in the following path:
        * /sys/class/fc_transport/target<host>*

        :returns: List with [c, t, l] if the target path exists else
        empty list
        """
        cmd = 'grep -Gil "%(wwpns)s" %(path)s*/port_name' % {'wwpns': wwpn, 'path': path}
        out, _err = self._execute(cmd, shell=True)
        out_path = out.split('\n')[0]
        if out_path.startswith(path):
            return out_path.split('/')[4].split(':')[1:] + [lun]
        return []

    def _get_target_fc_remote_ports_path(self, path, wwpn, lun):
        """Scan target in the fc_remote_ports path

        Scan for target in the following path:
        * /sys/class/fc_remote_ports/rport-<host>*

        If the path exist, we fetch the target value from the
        scsi_target_id file.
        Example: /sys/class/fc_remote_ports/rport-6:0-1/scsi_target_id

        :returns: List with [c, t, l] if the target path exists else
        empty list
        """
        cmd = 'grep -Gil "%(wwpns)s" %(path)s*/port_name' % {'wwpns': wwpn, 'path': path}
        out, _err = self._execute(cmd, shell=True)
        target_path = os.path.dirname(out) + '/scsi_target_id'
        if target_path.startswith(path):
            try:
                scsi_target = '-1'
                with open(target_path) as scsi_target_file:
                    lines = scsi_target_file.read()
                    scsi_target = lines.split('\n')[0]
            except OSError:
                pass
            if scsi_target != '-1':
                channel = target_path.split(':')[1].split('-')[0]
                return [channel, scsi_target, lun]
        return []

    def _get_hba_channel_scsi_target_lun(self, hba, conn_props):
        """Get HBA channels, SCSI targets, LUNs to FC targets for given HBA.

        Given an HBA and the connection properties we look for the HBA channels
        and SCSI targets for each of the FC targets that this HBA has been
        granted permission to connect.

        For drivers that don't return an initiator to target map we try to find
        the info for all the target ports.

        For drivers that return an initiator_target_map we use the
        initiator_target_lun_map entry that was generated by the FC connector
        based on the contents of the connection information data to know which
        target ports to look for.

        We scan for targets in the following two paths:
        * /sys/class/fc_transport/target<host>*
        * /sys/class/fc_remote_ports/rport-<host>*

        We search for targets in the fc_transport path first and if not
        found, we search in the fc_remote_ports path

        :returns: 2-Tuple with the first entry being a list of [c, t, l]
        entries where the target port was found, and the second entry of the
        tuple being a set of luns for ports that were not found.
        """
        targets = conn_props['targets']
        if conn_props.get('initiator_target_map') is not None:
            targets = conn_props['initiator_target_lun_map'].get(hba['port_name'], targets)
        host_device = hba['host_device']
        if host_device and len(host_device) > 4:
            host_device = host_device[4:]
        path = '/sys/class/fc_transport/target%s:' % host_device
        rpath = '/sys/class/fc_remote_ports/rport-%s:' % host_device
        ctls = []
        luns_not_found = set()
        for wwpn, lun in targets:
            try:
                ctl = self._get_target_fc_transport_path(path, wwpn, lun) or self._get_target_fc_remote_ports_path(rpath, wwpn, lun)
                if ctl:
                    ctls.append(ctl)
            except Exception as exc:
                LOG.debug('Could not get HBA channel and SCSI target ID, path: %(path)s*, reason: %(reason)s', {'path': path, 'reason': exc})
                luns_not_found.add(lun)
        return (ctls, luns_not_found)

    def rescan_hosts(self, hbas: Iterable, connection_properties: dict) -> None:
        LOG.debug('Rescanning HBAs %(hbas)s with connection properties %(conn_props)s', {'hbas': hbas, 'conn_props': connection_properties})
        ports = connection_properties.get('initiator_target_lun_map')
        if ports:
            hbas = [hba for hba in hbas if hba['port_name'] in ports]
            LOG.debug('Using initiator target map to exclude HBAs: %s', hbas)
        broad_scan = connection_properties.get('enable_wildcard_scan', True)
        if not broad_scan:
            LOG.debug('Connection info disallows broad SCSI scanning')
        process = []
        skipped = []
        get_ctls = self._get_hba_channel_scsi_target_lun
        for hba in hbas:
            ctls, luns_wildcards = get_ctls(hba, connection_properties)
            if ctls:
                process.append((hba, ctls))
            elif not broad_scan:
                LOG.debug('Skipping HBA %s, nothing to scan, target port not connected to initiator', hba['node_name'])
            elif not process:
                skipped.append((hba, [('-', '-', lun) for lun in luns_wildcards]))
        process = process or skipped
        addressing_mode = connection_properties.get('addressing_mode')
        for hba, ctls in process:
            for hba_channel, target_id, target_lun in ctls:
                target_lun = self.lun_for_addressing(target_lun, addressing_mode)
                LOG.debug('Scanning %(host)s (wwnn: %(wwnn)s, c: %(channel)s, t: %(target)s, l: %(lun)s)', {'host': hba['host_device'], 'wwnn': hba['node_name'], 'channel': hba_channel, 'target': target_id, 'lun': target_lun})
                self.echo_scsi_command('/sys/class/scsi_host/%s/scan' % hba['host_device'], '%(c)s %(t)s %(l)s' % {'c': hba_channel, 't': target_id, 'l': target_lun})

    @classmethod
    def get_fc_hbas(cls) -> list[dict[str, str]]:
        """Get the Fibre Channel HBA information from sysfs."""
        hbas = []
        for hostpath in glob.glob(f'{cls.FC_HOST_SYSFS_PATH}/*'):
            try:
                hba = {'ClassDevice': os.path.basename(hostpath), 'ClassDevicepath': os.path.realpath(hostpath)}
                for attribute in cls.HBA_ATTRIBUTES:
                    with open(os.path.join(hostpath, attribute), 'rt') as f:
                        hba[attribute] = f.read().strip()
                hbas.append(hba)
            except Exception as exc:
                LOG.warning('Could not read attributes for %(hp)s: %(exc)s', {'hp': hostpath, 'exc': exc})
        return hbas

    def get_fc_hbas_info(self) -> list[dict[str, str]]:
        """Get Fibre Channel WWNs and device paths from the system, if any."""
        hbas = self.get_fc_hbas()
        hbas_info = []
        for hba in hbas:
            wwpn = hba['port_name'].replace('0x', '')
            wwnn = hba['node_name'].replace('0x', '')
            device_path = hba['ClassDevicepath']
            device = hba['ClassDevice']
            hbas_info.append({'port_name': wwpn, 'node_name': wwnn, 'host_device': device, 'device_path': device_path})
        return hbas_info

    def get_fc_wwpns(self) -> list[str]:
        """Get Fibre Channel WWPNs from the system, if any."""
        hbas = self.get_fc_hbas()
        wwpns = []
        for hba in hbas:
            if hba['port_state'] == 'Online':
                wwpn = hba['port_name'].replace('0x', '')
                wwpns.append(wwpn)
        return wwpns

    def get_fc_wwnns(self) -> list[str]:
        """Get Fibre Channel WWNNs from the system, if any."""
        hbas = self.get_fc_hbas()
        wwnns = []
        for hba in hbas:
            if hba['port_state'] == 'Online':
                wwnn = hba['node_name'].replace('0x', '')
                wwnns.append(wwnn)
        return wwnns