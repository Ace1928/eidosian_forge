from __future__ import annotations
import functools
import inspect
import logging as py_logging
import os
import time
from typing import Any, Callable, Optional, Type, Union   # noqa: H301
import uuid as uuid_lib
from oslo_concurrency import processutils
from oslo_log import log as logging
from oslo_utils import strutils
from os_brick import executor
from os_brick.i18n import _
from os_brick.privileged import nvmeof as priv_nvme
from os_brick.privileged import rootwrap as priv_rootwrap
import tenacity  # noqa
def connect_volume_prepare_result(func: Callable[[Any, dict], dict]) -> Callable[[Any, dict], dict]:
    """Decorator to prepare the result of connect_volume for encrypted volumes.

    WARNING: This decorator must be **before** any connect_volume locking
             because it may call disconnect_volume.

    Encryptor drivers expect a symlink that they "own", so that they can modify
    it as they want.

    The current flow is like this:

    - connect_volume connector call
    - libvirt config is generated by Nova using returned path
    - connect_volume encryptor call  => Replaces the original path

    For encrypted volumes the decorator modifies the "path" value for the
    returned dictionary.

    Unencrypted volumes will be left unchanged.

    There are special connectors that return a file descriptor instead of a
    path depending on the parameters.  In those cases the result will also be
    left untouched.

    If a connector relies on the path that has been used they can use the
    connect_volume_undo_prepare_result decorator to get the value changed back
    the original path.
    """

    @functools.wraps(func)
    def change_encrypted(self, connection_properties):
        res = func(self, connection_properties)
        device_path = convert_str(res['path'])
        if connection_properties.get('encrypted') and isinstance(device_path, str):
            symlink = _symlink_name_from_device_path(device_path)
            try:
                priv_rootwrap.link_root(os.path.realpath(device_path), symlink, force=True)
                res['path'] = symlink
            except Exception as exc:
                LOG.debug('Failed to create symlink, cleaning connection: %s', exc)
                self.disconnect_volume(res, force=True, ignore_errors=True)
                raise
        return res
    return change_encrypted