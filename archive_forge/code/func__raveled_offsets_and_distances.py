import numpy as np
from scipy import ndimage as ndi
def _raveled_offsets_and_distances(image_shape, *, footprint=None, connectivity=1, center=None, spacing=None, order='C'):
    """Compute offsets to neighboring pixels in raveled coordinate space.

    This function also returns the corresponding distances from the center
    pixel given a spacing (assumed to be 1 along each axis by default).

    Parameters
    ----------
    image_shape : tuple of int
        The shape of the image for which the offsets are being computed.
    footprint : array of bool
        The footprint of the neighborhood, expressed as an n-dimensional array
        of 1s and 0s. If provided, the connectivity argument is ignored.
    connectivity : {1, ..., ndim}
        The square connectivity of the neighborhood: the number of orthogonal
        steps allowed to consider a pixel a neighbor. See
        `scipy.ndimage.generate_binary_structure`. Ignored if footprint is
        provided.
    center : tuple of int
        Tuple of indices to the center of the footprint. If not provided, it
        is assumed to be the center of the footprint, either provided or
        generated by the connectivity argument.
    spacing : tuple of float
        The spacing between pixels/voxels along each axis.
    order : 'C' or 'F'
        The ordering of the array, either C or Fortran ordering.

    Returns
    -------
    raveled_offsets : ndarray
        Linear offsets to a samples neighbors in the raveled image, sorted by
        their distance from the center.
    distances : ndarray
        The pixel distances corresponding to each offset.

    Notes
    -----
    This function will return values even if `image_shape` contains a dimension
    length that is smaller than `footprint`.

    Examples
    --------
    >>> off, d = _raveled_offsets_and_distances(
    ...         (4, 5), footprint=np.ones((4, 3)), center=(1, 1)
    ...         )
    >>> off
    array([-5, -1,  1,  5, -6, -4,  4,  6, 10,  9, 11])
    >>> d[0]
    1.0
    >>> d[-1]  # distance from (1, 1) to (3, 2)
    2.236...
    """
    ndim = len(image_shape)
    if footprint is None:
        footprint = ndi.generate_binary_structure(rank=ndim, connectivity=connectivity)
    if center is None:
        center = tuple((s // 2 for s in footprint.shape))
    if not footprint.ndim == ndim == len(center):
        raise ValueError('number of dimensions in image shape, footprint and itscenter index does not match')
    offsets = np.stack([idx - c for idx, c in zip(np.nonzero(footprint), center)], axis=-1)
    if order == 'F':
        offsets = offsets[:, ::-1]
        image_shape = image_shape[::-1]
    elif order != 'C':
        raise ValueError("order must be 'C' or 'F'")
    ravel_factors = image_shape[1:] + (1,)
    ravel_factors = np.cumprod(ravel_factors[::-1])[::-1]
    raveled_offsets = (offsets * ravel_factors).sum(axis=1)
    if spacing is None:
        spacing = np.ones(ndim)
    weighted_offsets = offsets * spacing
    distances = np.sqrt(np.sum(weighted_offsets ** 2, axis=1))
    sorted_raveled_offsets = raveled_offsets[np.argsort(distances, kind='stable')]
    sorted_distances = np.sort(distances, kind='stable')
    if any((x < y for x, y in zip(image_shape, footprint.shape))):
        _, indices = np.unique(sorted_raveled_offsets, return_index=True)
        indices = np.sort(indices, kind='stable')
        sorted_raveled_offsets = sorted_raveled_offsets[indices]
        sorted_distances = sorted_distances[indices]
    sorted_raveled_offsets = sorted_raveled_offsets[1:]
    sorted_distances = sorted_distances[1:]
    return (sorted_raveled_offsets, sorted_distances)