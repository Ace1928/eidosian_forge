from __future__ import absolute_import, division, print_function
import collections
import functools
import sys
import unittest2 as unittest
import funcsigs as inspect
class TestSignatureObject(unittest.TestCase):

    @staticmethod
    def signature(func):
        sig = inspect.signature(func)
        return (tuple(((param.name, Ellipsis if param.default is param.empty else param.default, Ellipsis if param.annotation is param.empty else param.annotation, str(param.kind).lower()) for param in sig.parameters.values())), Ellipsis if sig.return_annotation is sig.empty else sig.return_annotation)
    if sys.version_info[0] > 2:
        exec("\ndef test_signature_object(self):\n    S = inspect.Signature\n    P = inspect.Parameter\n\n    self.assertEqual(str(S()), '()')\n\n    def test(po, pk, *args, ko, **kwargs):\n        pass\n    sig = inspect.signature(test)\n    po = sig.parameters['po'].replace(kind=P.POSITIONAL_ONLY)\n    pk = sig.parameters['pk']\n    args = sig.parameters['args']\n    ko = sig.parameters['ko']\n    kwargs = sig.parameters['kwargs']\n\n    S((po, pk, args, ko, kwargs))\n\n    with self.assertRaisesRegex(ValueError, 'wrong parameter order'):\n        S((pk, po, args, ko, kwargs))\n\n    with self.assertRaisesRegex(ValueError, 'wrong parameter order'):\n        S((po, args, pk, ko, kwargs))\n\n    with self.assertRaisesRegex(ValueError, 'wrong parameter order'):\n        S((args, po, pk, ko, kwargs))\n\n    with self.assertRaisesRegex(ValueError, 'wrong parameter order'):\n        S((po, pk, args, kwargs, ko))\n\n    kwargs2 = kwargs.replace(name='args')\n    with self.assertRaisesRegex(ValueError, 'duplicate parameter name'):\n        S((po, pk, args, kwargs2, ko))\n")

    def test_signature_immutability(self):

        def test(a):
            pass
        sig = inspect.signature(test)
        with self.assertRaises(AttributeError):
            sig.foo = 'bar'
        if sys.version_info[:2] < (3, 3):
            return
        with self.assertRaises(TypeError):
            sig.parameters['a'] = None

    def test_signature_on_noarg(self):

        def test():
            pass
        self.assertEqual(self.signature(test), ((), Ellipsis))
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_wargs(self):\n    def test(a, b:\'foo\') -> 123:\n        pass\n    self.assertEqual(self.signature(test),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', Ellipsis, \'foo\', "positional_or_keyword")),\n                      123))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_wkwonly(self):\n    def test(*, a:float, b:str) -> int:\n        pass\n    self.assertEqual(self.signature(test),\n                     (((\'a\', Ellipsis, float, "keyword_only"),\n                       (\'b\', Ellipsis, str, "keyword_only")),\n                       int))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_complex_args(self):\n    def test(a, b:\'foo\'=10, *args:\'bar\', spam:\'baz\', ham=123, **kwargs:int):\n        pass\n    self.assertEqual(self.signature(test),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', 10, \'foo\', "positional_or_keyword"),\n                       (\'args\', Ellipsis, \'bar\', "var_positional"),\n                       (\'spam\', Ellipsis, \'baz\', "keyword_only"),\n                       (\'ham\', 123, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, int, "var_keyword")),\n                      Ellipsis))\n')

    def test_signature_on_builtin_function(self):
        with self.assertRaisesRegex(ValueError, 'not supported by signature'):
            inspect.signature(type)
        with self.assertRaisesRegex(ValueError, 'not supported by signature'):
            inspect.signature(type.__call__)
            if hasattr(sys, 'pypy_version_info'):
                raise ValueError('not supported by signature')
        with self.assertRaisesRegex(ValueError, 'not supported by signature'):
            inspect.signature(min.__call__)
            if hasattr(sys, 'pypy_version_info'):
                raise ValueError('not supported by signature')
        with self.assertRaisesRegex(ValueError, 'no signature found for builtin function'):
            inspect.signature(min)

    def test_signature_on_non_function(self):
        with self.assertRaisesRegex(TypeError, 'is not a callable object'):
            inspect.signature(42)
        with self.assertRaisesRegex(TypeError, 'is not a Python function'):
            inspect.Signature.from_function(42)
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_method(self):\n    class Test:\n        def foo(self, arg1, arg2=1) -> int:\n            pass\n\n    meth = Test().foo\n\n    self.assertEqual(self.signature(meth),\n                     (((\'arg1\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'arg2\', 1, Ellipsis, "positional_or_keyword")),\n                      int))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_classmethod(self):\n    class Test:\n        @classmethod\n        def foo(cls, arg1, *, arg2=1):\n            pass\n\n    meth = Test().foo\n    self.assertEqual(self.signature(meth),\n                     (((\'arg1\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'arg2\', 1, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    meth = Test.foo\n    self.assertEqual(self.signature(meth),\n                     (((\'arg1\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'arg2\', 1, Ellipsis, "keyword_only")),\n                      Ellipsis))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_staticmethod(self):\n    class Test:\n        @staticmethod\n        def foo(cls, *, arg):\n            pass\n\n    meth = Test().foo\n    self.assertEqual(self.signature(meth),\n                     (((\'cls\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'arg\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    meth = Test.foo\n    self.assertEqual(self.signature(meth),\n                     (((\'cls\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'arg\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_partial(self):\n    from functools import partial\n\n    def test():\n        pass\n\n    self.assertEqual(self.signature(partial(test)), ((), Ellipsis))\n\n    with self.assertRaisesRegex(ValueError, "has incorrect arguments"):\n        inspect.signature(partial(test, 1))\n\n    with self.assertRaisesRegex(ValueError, "has incorrect arguments"):\n        inspect.signature(partial(test, a=1))\n\n    def test(a, b, *, c, d):\n        pass\n\n    self.assertEqual(self.signature(partial(test)),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'c\', Ellipsis, Ellipsis, "keyword_only"),\n                       (\'d\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, 1)),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'c\', Ellipsis, Ellipsis, "keyword_only"),\n                       (\'d\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, 1, c=2)),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'c\', 2, Ellipsis, "keyword_only"),\n                       (\'d\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, b=1, c=2)),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', 1, Ellipsis, "positional_or_keyword"),\n                       (\'c\', 2, Ellipsis, "keyword_only"),\n                       (\'d\', Ellipsis, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, 0, b=1, c=2)),\n                     (((\'b\', 1, Ellipsis, "positional_or_keyword"),\n                       (\'c\', 2, Ellipsis, "keyword_only"),\n                       (\'d\', Ellipsis, Ellipsis, "keyword_only"),),\n                      Ellipsis))\n\n    def test(a, *args, b, **kwargs):\n        pass\n\n    self.assertEqual(self.signature(partial(test, 1)),\n                     (((\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', Ellipsis, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, 1, 2, 3)),\n                     (((\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', Ellipsis, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n\n    self.assertEqual(self.signature(partial(test, 1, 2, 3, test=True)),\n                     (((\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', Ellipsis, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, 1, 2, 3, test=1, b=0)),\n                     (((\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', 0, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, b=0)),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', 0, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(partial(test, b=0, test=1)),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'args\', Ellipsis, Ellipsis, "var_positional"),\n                       (\'b\', 0, Ellipsis, "keyword_only"),\n                       (\'kwargs\', Ellipsis, Ellipsis, "var_keyword")),\n                      Ellipsis))\n\n    def test(a, b, c:int) -> 42:\n        pass\n\n    sig = test.__signature__ = inspect.signature(test)\n\n    self.assertEqual(self.signature(partial(partial(test, 1))),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'c\', Ellipsis, int, "positional_or_keyword")),\n                      42))\n\n    self.assertEqual(self.signature(partial(partial(test, 1), 2)),\n                     (((\'c\', Ellipsis, int, "positional_or_keyword"),),\n                      42))\n\n    psig = inspect.signature(partial(partial(test, 1), 2))\n\n    def foo(a):\n        return a\n    _foo = partial(partial(foo, a=10), a=20)\n    self.assertEqual(self.signature(_foo),\n                     (((\'a\', 20, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n    # check that we don\'t have any side-effects in signature(),\n    # and the partial object is still functioning\n    self.assertEqual(_foo(), 20)\n\n    def foo(a, b, c):\n        return a, b, c\n    _foo = partial(partial(foo, 1, b=20), b=30)\n    self.assertEqual(self.signature(_foo),\n                     (((\'b\', 30, Ellipsis, "positional_or_keyword"),\n                       (\'c\', Ellipsis, Ellipsis, "positional_or_keyword")),\n                      Ellipsis))\n    self.assertEqual(_foo(c=10), (1, 30, 10))\n    _foo = partial(_foo, 2) # now \'b\' has two values -\n                            # positional and keyword\n    with self.assertRaisesRegex(ValueError, "has incorrect arguments"):\n        inspect.signature(_foo)\n\n    def foo(a, b, c, *, d):\n        return a, b, c, d\n    _foo = partial(partial(foo, d=20, c=20), b=10, d=30)\n    self.assertEqual(self.signature(_foo),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', 10, Ellipsis, "positional_or_keyword"),\n                       (\'c\', 20, Ellipsis, "positional_or_keyword"),\n                       (\'d\', 30, Ellipsis, "keyword_only")),\n                      Ellipsis))\n    ba = inspect.signature(_foo).bind(a=200, b=11)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (200, 11, 20, 30))\n\n    def foo(a=1, b=2, c=3):\n        return a, b, c\n    _foo = partial(foo, a=10, c=13)\n    ba = inspect.signature(_foo).bind(11)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (11, 2, 13))\n    ba = inspect.signature(_foo).bind(11, 12)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (11, 12, 13))\n    ba = inspect.signature(_foo).bind(11, b=12)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (11, 12, 13))\n    ba = inspect.signature(_foo).bind(b=12)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (10, 12, 13))\n    _foo = partial(_foo, b=10)\n    ba = inspect.signature(_foo).bind(12, 14)\n    self.assertEqual(_foo(*ba.args, **ba.kwargs), (12, 14, 13))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_decorated(self):\n    import functools\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -> int:\n            return func(*args, **kwargs)\n        return wrapper\n\n    class Foo:\n        @decorator\n        def bar(self, a, b):\n            pass\n\n    self.assertEqual(self.signature(Foo.bar),\n                     (((\'self\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', Ellipsis, Ellipsis, "positional_or_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(Foo().bar),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', Ellipsis, Ellipsis, "positional_or_keyword")),\n                      Ellipsis))\n\n    # Test that we handle method wrappers correctly\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -> int:\n            return func(42, *args, **kwargs)\n        sig = inspect.signature(func)\n        new_params = tuple(sig.parameters.values())[1:]\n        wrapper.__signature__ = sig.replace(parameters=new_params)\n        return wrapper\n\n    class Foo:\n        @decorator\n        def __call__(self, a, b):\n            pass\n\n    self.assertEqual(self.signature(Foo.__call__),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'b\', Ellipsis, Ellipsis, "positional_or_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(Foo().__call__),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n')
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_on_class(self):\n    class C:\n        def __init__(self, a):\n            pass\n\n    self.assertEqual(self.signature(C),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n\n    class CM(type):\n        def __call__(cls, a):\n            pass\n    class C(metaclass=CM):\n        def __init__(self, b):\n            pass\n\n    self.assertEqual(self.signature(C),\n                     (((\'a\', Ellipsis, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n\n    class CM(type):\n        def __new__(mcls, name, bases, dct, *, foo=1):\n            return super().__new__(mcls, name, bases, dct)\n    class C(metaclass=CM):\n        def __init__(self, b):\n            pass\n\n    self.assertEqual(self.signature(C),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(CM),\n                     (((\'name\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'bases\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'dct\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'foo\', 1, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    class CMM(type):\n        def __new__(mcls, name, bases, dct, *, foo=1):\n            return super().__new__(mcls, name, bases, dct)\n        def __call__(cls, nm, bs, dt):\n            return type(nm, bs, dt)\n    class CM(type, metaclass=CMM):\n        def __new__(mcls, name, bases, dct, *, bar=2):\n            return super().__new__(mcls, name, bases, dct)\n    class C(metaclass=CM):\n        def __init__(self, b):\n            pass\n\n    self.assertEqual(self.signature(CMM),\n                     (((\'name\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'bases\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'dct\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'foo\', 1, Ellipsis, "keyword_only")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(CM),\n                     (((\'nm\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'bs\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'dt\', Ellipsis, Ellipsis, "positional_or_keyword")),\n                      Ellipsis))\n\n    self.assertEqual(self.signature(C),\n                     (((\'b\', Ellipsis, Ellipsis, "positional_or_keyword"),),\n                      Ellipsis))\n\n    class CM(type):\n        def __init__(cls, name, bases, dct, *, bar=2):\n            return super().__init__(name, bases, dct)\n    class C(metaclass=CM):\n        def __init__(self, b):\n            pass\n\n    self.assertEqual(self.signature(CM),\n                     (((\'name\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'bases\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'dct\', Ellipsis, Ellipsis, "positional_or_keyword"),\n                       (\'bar\', 2, Ellipsis, "keyword_only")),\n                      Ellipsis))\n')

    def test_signature_on_callable_objects(self):

        class Foo(object):

            def __call__(self, a):
                pass
        self.assertEqual(self.signature(Foo()), ((('a', Ellipsis, Ellipsis, 'positional_or_keyword'),), Ellipsis))

        class Spam(object):
            pass
        with self.assertRaisesRegex(TypeError, 'is not a callable object'):
            inspect.signature(Spam())

        class Bar(Spam, Foo):
            pass
        self.assertEqual(self.signature(Bar()), ((('a', Ellipsis, Ellipsis, 'positional_or_keyword'),), Ellipsis))

        class ToFail(object):
            __call__ = type
        with self.assertRaisesRegex(ValueError, 'not supported by signature'):
            inspect.signature(ToFail())
        if sys.version_info[0] < 3:
            return

        class Wrapped(object):
            pass
        Wrapped.__wrapped__ = lambda a: None
        self.assertEqual(self.signature(Wrapped), ((('a', Ellipsis, Ellipsis, 'positional_or_keyword'),), Ellipsis))

    def test_signature_on_lambdas(self):
        self.assertEqual(self.signature(lambda a=10: a), ((('a', 10, Ellipsis, 'positional_or_keyword'),), Ellipsis))
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_equality(self):\n    def foo(a, *, b:int) -> float: pass\n    self.assertNotEqual(inspect.signature(foo), 42)\n\n    def bar(a, *, b:int) -> float: pass\n    self.assertEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def bar(a, *, b:int) -> int: pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def bar(a, *, b:int): pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def bar(a, *, b:int=42) -> float: pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def bar(a, *, c) -> float: pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def bar(a, b:int) -> float: pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n    def spam(b:int, a) -> float: pass\n    self.assertNotEqual(inspect.signature(spam), inspect.signature(bar))\n\n    def foo(*, a, b, c): pass\n    def bar(*, c, b, a): pass\n    self.assertEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def foo(*, a=1, b, c): pass\n    def bar(*, c, b, a=1): pass\n    self.assertEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def foo(pos, *, a=1, b, c): pass\n    def bar(pos, *, c, b, a=1): pass\n    self.assertEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def foo(pos, *, a, b, c): pass\n    def bar(pos, *, c, b, a=1): pass\n    self.assertNotEqual(inspect.signature(foo), inspect.signature(bar))\n\n    def foo(pos, *args, a=42, b, c, **kwargs:int): pass\n    def bar(pos, *args, c, b, a=42, **kwargs:int): pass\n    self.assertEqual(inspect.signature(foo), inspect.signature(bar))\n')

    def test_signature_unhashable(self):

        def foo(a):
            pass
        sig = inspect.signature(foo)
        with self.assertRaisesRegex(TypeError, 'unhashable type'):
            hash(sig)
    if sys.version_info[0] > 2:
        exec("\ndef test_signature_str(self):\n    def foo(a:int=1, *, b, c=None, **kwargs) -> 42:\n        pass\n    self.assertEqual(str(inspect.signature(foo)),\n                     '(a:int=1, *, b, c=None, **kwargs) -> 42')\n\n    def foo(a:int=1, *args, b, c=None, **kwargs) -> 42:\n        pass\n    self.assertEqual(str(inspect.signature(foo)),\n                     '(a:int=1, *args, b, c=None, **kwargs) -> 42')\n\n    def foo():\n        pass\n    self.assertEqual(str(inspect.signature(foo)), '()')\n")
    if sys.version_info[0] > 2:
        exec("\ndef test_signature_str_positional_only(self):\n    P = inspect.Parameter\n\n    def test(a_po, *, b, **kwargs):\n        return a_po, kwargs\n\n    sig = inspect.signature(test)\n    new_params = list(sig.parameters.values())\n    new_params[0] = new_params[0].replace(kind=P.POSITIONAL_ONLY)\n    test.__signature__ = sig.replace(parameters=new_params)\n\n    self.assertEqual(str(inspect.signature(test)),\n                     '(<a_po>, *, b, **kwargs)')\n\n    sig = inspect.signature(test)\n    new_params = list(sig.parameters.values())\n    new_params[0] = new_params[0].replace(name=None)\n    test.__signature__ = sig.replace(parameters=new_params)\n    self.assertEqual(str(inspect.signature(test)),\n                     '(<0>, *, b, **kwargs)')\n")
    if sys.version_info[0] > 2:
        exec('\ndef test_signature_replace_anno(self):\n    def test() -> 42:\n        pass\n\n    sig = inspect.signature(test)\n    sig = sig.replace(return_annotation=None)\n    self.assertIs(sig.return_annotation, None)\n    sig = sig.replace(return_annotation=sig.empty)\n    self.assertIs(sig.return_annotation, sig.empty)\n    sig = sig.replace(return_annotation=42)\n    self.assertEqual(sig.return_annotation, 42)\n    self.assertEqual(sig, inspect.signature(test))\n')