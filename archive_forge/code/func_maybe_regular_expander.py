import itertools
import networkx as nx
@nx.utils.decorators.np_random_state('seed')
@nx._dispatchable(graphs=None, returns_graph=True)
def maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None):
    """Utility for creating a random regular expander.

    Returns a random $d$-regular graph on $n$ nodes which is an expander
    graph with very good probability.

    Parameters
    ----------
    n : int
      The number of nodes.
    d : int
      The degree of each node.
    create_using : Graph Instance or Constructor
      Indicator of type of graph to return.
      If a Graph-type instance, then clear and use it.
      If a constructor, call it to create an empty graph.
      Use the Graph constructor by default.
    max_tries : int. (default: 100)
      The number of allowed loops when generating each independent cycle
    seed : (default: None)
      Seed used to set random number generation state. See :ref`Randomness<randomness>`.

    Notes
    -----
    The nodes are numbered from $0$ to $n - 1$.

    The graph is generated by taking $d / 2$ random independent cycles.

    Joel Friedman proved that in this model the resulting
    graph is an expander with probability
    $1 - O(n^{-\\tau})$ where $\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1$. [1]_

    Examples
    --------
    >>> G = nx.maybe_regular_expander(n=200, d=6, seed=8020)

    Returns
    -------
    G : graph
        The constructed undirected graph.

    Raises
    ------
    NetworkXError
        If $d % 2 != 0$ as the degree must be even.
        If $n - 1$ is less than $ 2d $ as the graph is complete at most.
        If max_tries is reached

    See Also
    --------
    is_regular_expander
    random_regular_expander_graph

    References
    ----------
    .. [1] Joel Friedman,
       A Proof of Alonâ€™s Second Eigenvalue Conjecture and Related Problems, 2004
       https://arxiv.org/abs/cs/0405020

    """
    import numpy as np
    if n < 1:
        raise nx.NetworkXError('n must be a positive integer')
    if not d >= 2:
        raise nx.NetworkXError('d must be greater than or equal to 2')
    if not d % 2 == 0:
        raise nx.NetworkXError('d must be even')
    if not n - 1 >= d:
        raise nx.NetworkXError(f'Need n-1>= d to have room for {d // 2} independent cycles with {n} nodes')
    G = nx.empty_graph(n, create_using)
    if n < 2:
        return G
    cycles = []
    edges = set()
    for i in range(d // 2):
        iterations = max_tries
        while len(edges) != (i + 1) * n:
            iterations -= 1
            cycle = seed.permutation(n - 1).tolist()
            cycle.append(n - 1)
            new_edges = {(u, v) for u, v in nx.utils.pairwise(cycle, cyclic=True) if (u, v) not in edges and (v, u) not in edges}
            if len(new_edges) == n:
                cycles.append(cycle)
                edges.update(new_edges)
            if iterations == 0:
                raise nx.NetworkXError('Too many iterations in maybe_regular_expander')
    G.add_edges_from(edges)
    return G