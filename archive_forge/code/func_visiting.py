import numpy as np
from scipy.optimize import OptimizeResult
from scipy.optimize import minimize, Bounds
from scipy.special import gammaln
from scipy._lib._util import check_random_state
from scipy.optimize._constraints import new_bounds_to_old
def visiting(self, x, step, temperature):
    """ Based on the step in the strategy chain, new coordinates are
        generated by changing all components is the same time or only
        one of them, the new values are computed with visit_fn method
        """
    dim = x.size
    if step < dim:
        visits = self.visit_fn(temperature, dim)
        upper_sample, lower_sample = self.rand_gen.uniform(size=2)
        visits[visits > self.TAIL_LIMIT] = self.TAIL_LIMIT * upper_sample
        visits[visits < -self.TAIL_LIMIT] = -self.TAIL_LIMIT * lower_sample
        x_visit = visits + x
        a = x_visit - self.lower
        b = np.fmod(a, self.bound_range) + self.bound_range
        x_visit = np.fmod(b, self.bound_range) + self.lower
        x_visit[np.fabs(x_visit - self.lower) < self.MIN_VISIT_BOUND] += 1e-10
    else:
        x_visit = np.copy(x)
        visit = self.visit_fn(temperature, 1)[0]
        if visit > self.TAIL_LIMIT:
            visit = self.TAIL_LIMIT * self.rand_gen.uniform()
        elif visit < -self.TAIL_LIMIT:
            visit = -self.TAIL_LIMIT * self.rand_gen.uniform()
        index = step - dim
        x_visit[index] = visit + x[index]
        a = x_visit[index] - self.lower[index]
        b = np.fmod(a, self.bound_range[index]) + self.bound_range[index]
        x_visit[index] = np.fmod(b, self.bound_range[index]) + self.lower[index]
        if np.fabs(x_visit[index] - self.lower[index]) < self.MIN_VISIT_BOUND:
            x_visit[index] += self.MIN_VISIT_BOUND
    return x_visit