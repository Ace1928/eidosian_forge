from __future__ import annotations
import enum
from itertools import zip_longest
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union
from .visitors import anon_map
from .visitors import HasTraversalDispatch
from .visitors import HasTraverseInternals
from .visitors import InternalTraversal
from .visitors import prefix_anon_map
from .. import util
from ..inspection import inspect
from ..util import HasMemoized
from ..util.typing import Literal
from ..util.typing import Protocol
class HasCacheKey:
    """Mixin for objects which can produce a cache key.

    This class is usually in a hierarchy that starts with the
    :class:`.HasTraverseInternals` base, but this is optional.  Currently,
    the class should be able to work on its own without including
    :class:`.HasTraverseInternals`.

    .. seealso::

        :class:`.CacheKey`

        :ref:`sql_caching`

    """
    __slots__ = ()
    _cache_key_traversal: _CacheKeyTraversalType = NO_CACHE
    _is_has_cache_key = True
    _hierarchy_supports_caching = True
    'private attribute which may be set to False to prevent the\n    inherit_cache warning from being emitted for a hierarchy of subclasses.\n\n    Currently applies to the :class:`.ExecutableDDLElement` hierarchy which\n    does not implement caching.\n\n    '
    inherit_cache: Optional[bool] = None
    'Indicate if this :class:`.HasCacheKey` instance should make use of the\n    cache key generation scheme used by its immediate superclass.\n\n    The attribute defaults to ``None``, which indicates that a construct has\n    not yet taken into account whether or not its appropriate for it to\n    participate in caching; this is functionally equivalent to setting the\n    value to ``False``, except that a warning is also emitted.\n\n    This flag can be set to ``True`` on a particular class, if the SQL that\n    corresponds to the object does not change based on attributes which\n    are local to this class, and not its superclass.\n\n    .. seealso::\n\n        :ref:`compilerext_caching` - General guideslines for setting the\n        :attr:`.HasCacheKey.inherit_cache` attribute for third-party or user\n        defined SQL constructs.\n\n    '
    __slots__ = ()
    _generated_cache_key_traversal: Any

    @classmethod
    def _generate_cache_attrs(cls) -> Union[_CacheKeyTraversalDispatchType, Literal[CacheConst.NO_CACHE]]:
        """generate cache key dispatcher for a new class.

        This sets the _generated_cache_key_traversal attribute once called
        so should only be called once per class.

        """
        inherit_cache = cls.__dict__.get('inherit_cache', None)
        inherit = bool(inherit_cache)
        if inherit:
            _cache_key_traversal = getattr(cls, '_cache_key_traversal', None)
            if _cache_key_traversal is None:
                try:
                    assert issubclass(cls, HasTraverseInternals)
                    _cache_key_traversal = cls._traverse_internals
                except AttributeError:
                    cls._generated_cache_key_traversal = NO_CACHE
                    return NO_CACHE
            assert _cache_key_traversal is not NO_CACHE, f'class {cls} has _cache_key_traversal=NO_CACHE, which conflicts with inherit_cache=True'
            return _cache_key_traversal_visitor.generate_dispatch(cls, _cache_key_traversal, '_generated_cache_key_traversal')
        else:
            _cache_key_traversal = cls.__dict__.get('_cache_key_traversal', None)
            if _cache_key_traversal is None:
                _cache_key_traversal = cls.__dict__.get('_traverse_internals', None)
                if _cache_key_traversal is None:
                    cls._generated_cache_key_traversal = NO_CACHE
                    if inherit_cache is None and cls._hierarchy_supports_caching:
                        util.warn("Class %s will not make use of SQL compilation caching as it does not set the 'inherit_cache' attribute to ``True``.  This can have significant performance implications including some performance degradations in comparison to prior SQLAlchemy versions.  Set this attribute to True if this object can make use of the cache key generated by the superclass.  Alternatively, this attribute may be set to False which will disable this warning." % cls.__name__, code='cprf')
                    return NO_CACHE
            return _cache_key_traversal_visitor.generate_dispatch(cls, _cache_key_traversal, '_generated_cache_key_traversal')

    @util.preload_module('sqlalchemy.sql.elements')
    def _gen_cache_key(self, anon_map: anon_map, bindparams: List[BindParameter[Any]]) -> Optional[Tuple[Any, ...]]:
        """return an optional cache key.

        The cache key is a tuple which can contain any series of
        objects that are hashable and also identifies
        this object uniquely within the presence of a larger SQL expression
        or statement, for the purposes of caching the resulting query.

        The cache key should be based on the SQL compiled structure that would
        ultimately be produced.   That is, two structures that are composed in
        exactly the same way should produce the same cache key; any difference
        in the structures that would affect the SQL string or the type handlers
        should result in a different cache key.

        If a structure cannot produce a useful cache key, the NO_CACHE
        symbol should be added to the anon_map and the method should
        return None.

        """
        cls = self.__class__
        id_, found = anon_map.get_anon(self)
        if found:
            return (id_, cls)
        dispatcher: Union[Literal[CacheConst.NO_CACHE], _CacheKeyTraversalDispatchType]
        try:
            dispatcher = cls.__dict__['_generated_cache_key_traversal']
        except KeyError:
            dispatcher = cls._generate_cache_attrs()
        if dispatcher is NO_CACHE:
            anon_map[NO_CACHE] = True
            return None
        result: Tuple[Any, ...] = (id_, cls)
        for attrname, obj, meth in dispatcher(self, _cache_key_traversal_visitor):
            if obj is not None:
                if meth is STATIC_CACHE_KEY:
                    sck = obj._static_cache_key
                    if sck is NO_CACHE:
                        anon_map[NO_CACHE] = True
                        return None
                    result += (attrname, sck)
                elif meth is ANON_NAME:
                    elements = util.preloaded.sql_elements
                    if isinstance(obj, elements._anonymous_label):
                        obj = obj.apply_map(anon_map)
                    result += (attrname, obj)
                elif meth is CALL_GEN_CACHE_KEY:
                    result += (attrname, obj._gen_cache_key(anon_map, bindparams))
                elif obj:
                    if meth is CACHE_IN_PLACE:
                        result += (attrname, obj)
                    elif meth is PROPAGATE_ATTRS:
                        result += (attrname, obj['compile_state_plugin'], obj['plugin_subject']._gen_cache_key(anon_map, bindparams) if obj['plugin_subject'] else None)
                    elif meth is InternalTraversal.dp_annotations_key:
                        if self._gen_static_annotations_cache_key:
                            result += self._annotations_cache_key
                        else:
                            result += self._gen_annotations_cache_key(anon_map)
                    elif meth is InternalTraversal.dp_clauseelement_list or meth is InternalTraversal.dp_clauseelement_tuple or meth is InternalTraversal.dp_memoized_select_entities:
                        result += (attrname, tuple([elem._gen_cache_key(anon_map, bindparams) for elem in obj]))
                    else:
                        result += meth(attrname, obj, self, anon_map, bindparams)
        return result

    def _generate_cache_key(self) -> Optional[CacheKey]:
        """return a cache key.

        The cache key is a tuple which can contain any series of
        objects that are hashable and also identifies
        this object uniquely within the presence of a larger SQL expression
        or statement, for the purposes of caching the resulting query.

        The cache key should be based on the SQL compiled structure that would
        ultimately be produced.   That is, two structures that are composed in
        exactly the same way should produce the same cache key; any difference
        in the structures that would affect the SQL string or the type handlers
        should result in a different cache key.

        The cache key returned by this method is an instance of
        :class:`.CacheKey`, which consists of a tuple representing the
        cache key, as well as a list of :class:`.BindParameter` objects
        which are extracted from the expression.   While two expressions
        that produce identical cache key tuples will themselves generate
        identical SQL strings, the list of :class:`.BindParameter` objects
        indicates the bound values which may have different values in
        each one; these bound parameters must be consulted in order to
        execute the statement with the correct parameters.

        a :class:`_expression.ClauseElement` structure that does not implement
        a :meth:`._gen_cache_key` method and does not implement a
        :attr:`.traverse_internals` attribute will not be cacheable; when
        such an element is embedded into a larger structure, this method
        will return None, indicating no cache key is available.

        """
        bindparams: List[BindParameter[Any]] = []
        _anon_map = anon_map()
        key = self._gen_cache_key(_anon_map, bindparams)
        if NO_CACHE in _anon_map:
            return None
        else:
            assert key is not None
            return CacheKey(key, bindparams)

    @classmethod
    def _generate_cache_key_for_object(cls, obj: HasCacheKey) -> Optional[CacheKey]:
        bindparams: List[BindParameter[Any]] = []
        _anon_map = anon_map()
        key = obj._gen_cache_key(_anon_map, bindparams)
        if NO_CACHE in _anon_map:
            return None
        else:
            assert key is not None
            return CacheKey(key, bindparams)