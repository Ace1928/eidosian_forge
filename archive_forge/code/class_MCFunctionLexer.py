from pygments.lexer import RegexLexer, default, include, bygroups
from pygments.token import Comment, Keyword, Literal, Name, Number, Operator, \
class MCFunctionLexer(RegexLexer):
    """Lexer for the mcfunction scripting language used in Minecraft
    Modelled somewhat after the `GitHub mcfunction grammar <https://github.com/Arcensoth/language-mcfunction>`_.

    .. versionadded:: 2.12.0
    """
    name = 'MCFunction'
    url = 'https://minecraft.fandom.com/wiki/Commands'
    aliases = ['mcfunction', 'mcf']
    filenames = ['*.mcfunction']
    mimetypes = ['text/mcfunction']
    _block_comment_prefix = '[>!]'
    tokens = {'root': [include('names'), include('comments'), include('literals'), include('whitespace'), include('property'), include('operators'), include('selectors')], 'names': [('^(\\s*)([a-z_]+)', bygroups(Whitespace, Name.Builtin)), ('(?<=run)\\s+[a-z_]+', Name.Builtin), ('\\b[0-9a-fA-F]+(?:-[0-9a-fA-F]+){4}\\b', Name.Variable), include('resource-name'), ('[A-Za-z_][\\w.#%$]+', Keyword.Constant), ('[#%$][\\w.#%$]+', Name.Variable.Magic)], 'resource-name': [('#?[a-z_][a-z_.-]*:[a-z0-9_./-]+', Name.Function), ('#?[a-z0-9_\\.\\-]+\\/[a-z0-9_\\.\\-\\/]+', Name.Function)], 'whitespace': [('\\s+', Whitespace)], 'comments': [(f'^\\s*(#{_block_comment_prefix})', Comment.Multiline, ('comments.block', 'comments.block.emphasized')), ('#.*$', Comment.Single)], 'comments.block': [(f'^\\s*#{_block_comment_prefix}', Comment.Multiline, 'comments.block.emphasized'), ('^\\s*#', Comment.Multiline, 'comments.block.normal'), default('#pop')], 'comments.block.normal': [include('comments.block.special'), ('\\S+', Comment.Multiline), ('\\n', Text, '#pop'), include('whitespace')], 'comments.block.emphasized': [include('comments.block.special'), ('\\S+', String.Doc), ('\\n', Text, '#pop'), include('whitespace')], 'comments.block.special': [('@\\S+', Name.Decorator), include('resource-name'), ('[#%$][\\w.#%$]+', Name.Variable.Magic)], 'operators': [('[\\-~%^?!+*<>\\\\/|&=.]', Operator)], 'literals': [('\\.\\.', Literal), ('(true|false)', Keyword.Pseudo), ('[A-Za-z_]+', Name.Variable.Class), ('[0-7]b', Number.Byte), ('[+-]?\\d*\\.?\\d+([eE]?[+-]?\\d+)?[df]?\\b', Number.Float), ('[+-]?\\d+\\b', Number.Integer), ('"', String.Double, 'literals.string-double'), ("'", String.Single, 'literals.string-single')], 'literals.string-double': [('\\\\.', String.Escape), ('[^\\\\"\\n]+', String.Double), ('"', String.Double, '#pop')], 'literals.string-single': [('\\\\.', String.Escape), ("[^\\\\'\\n]+", String.Single), ("'", String.Single, '#pop')], 'selectors': [('@[a-z]', Name.Variable)], 'property': [('\\{', Punctuation, ('property.curly', 'property.key')), ('\\[', Punctuation, ('property.square', 'property.key'))], 'property.curly': [include('whitespace'), include('property'), ('\\}', Punctuation, '#pop')], 'property.square': [include('whitespace'), include('property'), ('\\]', Punctuation, '#pop'), (',', Punctuation)], 'property.key': [include('whitespace'), ('#?[a-z_][a-z_\\.\\-]*\\:[a-z0-9_\\.\\-/]+(?=\\s*\\=)', Name.Attribute, 'property.delimiter'), ('#?[a-z_][a-z0-9_\\.\\-/]+', Name.Attribute, 'property.delimiter'), ('[A-Za-z_\\-\\+]+', Name.Attribute, 'property.delimiter'), ('"', Name.Attribute, 'property.delimiter', 'literals.string-double'), ("'", Name.Attribute, 'property.delimiter', 'literals.string-single'), ('-?\\d+', Number.Integer, 'property.delimiter'), default('#pop')], 'property.key.string-double': [('\\\\.', String.Escape), ('[^\\\\"\\n]+', Name.Attribute), ('"', Name.Attribute, '#pop')], 'property.key.string-single': [('\\\\.', String.Escape), ("[^\\\\'\\n]+", Name.Attribute), ("'", Name.Attribute, '#pop')], 'property.delimiter': [include('whitespace'), ('[:=]!?', Punctuation, 'property.value'), (',', Punctuation), default('#pop')], 'property.value': [include('whitespace'), ('#?[a-z_][a-z_\\.\\-]*\\:[a-z0-9_\\.\\-/]+', Name.Tag), ('#?[a-z_][a-z0-9_\\.\\-/]+', Name.Tag), include('literals'), include('property'), default('#pop')]}