from __future__ import annotations
import collections
import fnmatch
import os
import re
import warnings
from collections import defaultdict
from typing import TYPE_CHECKING, Any
import numpy as np
from monty.io import zopen
from monty.json import MSONable
from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.bandstructure import LobsterBandStructureSymmLine
from pymatgen.electronic_structure.core import Orbital, Spin
from pymatgen.electronic_structure.dos import Dos, LobsterCompleteDos
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.io.vasp.outputs import Vasprun, VolumetricData
from pymatgen.util.due import Doi, due
class Cohpcar:
    """
    Class to read COHPCAR/COOPCAR/COBICAR files generated by LOBSTER.

    Attributes:
        cohp_data (dict[str, Dict[str, Any]]): A dictionary containing the COHP data of the form:
            {bond: {"COHP": {Spin.up: cohps, Spin.down:cohps},
                    "ICOHP": {Spin.up: icohps, Spin.down: icohps},
                    "length": bond length,
                    "sites": sites corresponding to the bond}
            Also contains an entry for the average, which does not have a "length" key.
        efermi (float): The Fermi energy in eV.
        energies (Sequence[float]): Sequence of energies in eV. Note that LOBSTER shifts the energies
            so that the Fermi energy is at zero.
        is_spin_polarized (bool): Boolean to indicate if the calculation is spin polarized.
        orb_cohp (dict[str, Dict[str, Dict[str, Any]]]): A dictionary containing the orbital-resolved COHPs of the form:
            orb_cohp[label] = {bond_data["orb_label"]: {
                "COHP": {Spin.up: cohps, Spin.down:cohps},
                "ICOHP": {Spin.up: icohps, Spin.down: icohps},
                "orbitals": orbitals,
                "length": bond lengths,
                "sites": sites corresponding to the bond},
            }
    """

    def __init__(self, are_coops: bool=False, are_cobis: bool=False, are_multi_center_cobis: bool=False, filename: str | None=None) -> None:
        """
        Args:
            are_coops: Determines if the file includes COOPs.
              Default is False for COHPs.
            are_cobis: Determines if the file is a list of COHPs or COBIs.
              Default is False for COHPs.
            are_multi_center_cobis: Determines if the file include multi-center COBIS.
                Default is False for two-center cobis.
            filename: Name of the COHPCAR file. If it is None, the default
              file name will be chosen, depending on the value of are_coops.
        """
        if are_coops and are_cobis or (are_coops and are_multi_center_cobis) or (are_cobis and are_multi_center_cobis):
            raise ValueError('You cannot have info about COOPs, COBIs and/or multi-center COBIS in the same file.')
        self.are_coops = are_coops
        self.are_cobis = are_cobis
        self.are_multi_center_cobis = are_multi_center_cobis
        if filename is None:
            if are_coops:
                filename = 'COOPCAR.lobster'
            elif are_cobis or are_multi_center_cobis:
                filename = 'COBICAR.lobster'
            else:
                filename = 'COHPCAR.lobster'
        with zopen(filename, mode='rt') as file:
            contents = file.read().split('\n')
        parameters = contents[1].split()
        num_bonds = int(parameters[0]) if self.are_multi_center_cobis else int(parameters[0]) - 1
        self.efermi = float(parameters[-1])
        self.is_spin_polarized = int(parameters[1]) == 2
        spins = [Spin.up, Spin.down] if int(parameters[1]) == 2 else [Spin.up]
        cohp_data: dict[str, dict[str, Any]] = {}
        if not self.are_multi_center_cobis:
            data = np.array([np.array(row.split(), dtype=float) for row in contents[num_bonds + 3:]]).transpose()
            self.energies = data[0]
            cohp_data = {'average': {'COHP': {spin: data[1 + 2 * s * (num_bonds + 1)] for s, spin in enumerate(spins)}, 'ICOHP': {spin: data[2 + 2 * s * (num_bonds + 1)] for s, spin in enumerate(spins)}}}
        else:
            data = np.array([np.array(row.split(), dtype=float) for row in contents[num_bonds + 3:]]).transpose()
            self.energies = data[0]
        orb_cohp: dict[str, Any] = {}
        very_old = False
        bond_num = 0
        bond_data = {}
        label = ''
        for bond in range(num_bonds):
            if not self.are_multi_center_cobis:
                bond_data = self._get_bond_data(contents[3 + bond])
                label = str(bond_num)
                orbs = bond_data['orbitals']
                cohp = {spin: data[2 * (bond + s * (num_bonds + 1)) + 3] for s, spin in enumerate(spins)}
                icohp = {spin: data[2 * (bond + s * (num_bonds + 1)) + 4] for s, spin in enumerate(spins)}
                if orbs is None:
                    bond_num = bond_num + 1
                    label = str(bond_num)
                    cohp_data[label] = {'COHP': cohp, 'ICOHP': icohp, 'length': bond_data['length'], 'sites': bond_data['sites'], 'cells': None}
                elif label in orb_cohp:
                    orb_cohp[label].update({bond_data['orb_label']: {'COHP': cohp, 'ICOHP': icohp, 'orbitals': orbs, 'length': bond_data['length'], 'sites': bond_data['sites'], 'cells': bond_data['cells']}})
                else:
                    if bond_num == 0:
                        very_old = True
                    if very_old:
                        bond_num += 1
                        label = str(bond_num)
                    orb_cohp[label] = {bond_data['orb_label']: {'COHP': cohp, 'ICOHP': icohp, 'orbitals': orbs, 'length': bond_data['length'], 'sites': bond_data['sites'], 'cells': bond_data['cells']}}
            else:
                bond_data = self._get_bond_data(contents[2 + bond], are_multi_center_cobis=self.are_multi_center_cobis)
                label = str(bond_num)
                orbs = bond_data['orbitals']
                cohp = {spin: data[2 * (bond + s * num_bonds) + 1] for s, spin in enumerate(spins)}
                icohp = {spin: data[2 * (bond + s * num_bonds) + 2] for s, spin in enumerate(spins)}
                if orbs is None:
                    bond_num = bond_num + 1
                    label = str(bond_num)
                    cohp_data[label] = {'COHP': cohp, 'ICOHP': icohp, 'length': bond_data['length'], 'sites': bond_data['sites'], 'cells': bond_data['cells']}
                elif label in orb_cohp:
                    orb_cohp[label].update({bond_data['orb_label']: {'COHP': cohp, 'ICOHP': icohp, 'orbitals': orbs, 'length': bond_data['length'], 'sites': bond_data['sites']}})
                else:
                    if bond_num == 0:
                        very_old = True
                    if very_old:
                        bond_num += 1
                        label = str(bond_num)
                    orb_cohp[label] = {bond_data['orb_label']: {'COHP': cohp, 'ICOHP': icohp, 'orbitals': orbs, 'length': bond_data['length'], 'sites': bond_data['sites']}}
        if very_old:
            for bond_str in orb_cohp:
                cohp_data[bond_str] = {'COHP': None, 'ICOHP': None, 'length': bond_data['length'], 'sites': bond_data['sites']}
        self.orb_res_cohp = orb_cohp or None
        self.cohp_data = cohp_data

    @staticmethod
    def _get_bond_data(line: str, are_multi_center_cobis: bool=False) -> dict:
        """
        Subroutine to extract bond label, site indices, and length from
        a LOBSTER header line. The site indices are zero-based, so they
        can be easily used with a Structure object.

        Example header line: No.4:Fe1->Fe9(2.4524893531900283)
        Example header line for orbital-resolved COHP:
            No.1:Fe1[3p_x]->Fe2[3d_x^2-y^2](2.456180552772262)

        Args:
            line: line in the COHPCAR header describing the bond.
            are_multi_center_cobis: indicates multi-center COBIs

        Returns:
            Dict with the bond label, the bond length, a tuple of the site
            indices, a tuple containing the orbitals (if orbital-resolved),
            and a label for the orbitals (if orbital-resolved).
        """
        if not are_multi_center_cobis:
            line_new = line.rsplit('(', 1)
            length = float(line_new[-1][:-1])
            sites = line_new[0].replace('->', ':').split(':')[1:3]
            site_indices = tuple((int(re.split('\\D+', site)[1]) - 1 for site in sites))
            if '[' in sites[0]:
                orbs = [re.findall('\\[(.*)\\]', site)[0] for site in sites]
                orb_label, orbitals = get_orb_from_str(orbs)
            else:
                orbitals = None
                orb_label = None
            return {'length': length, 'sites': site_indices, 'cells': None, 'orbitals': orbitals, 'orb_label': orb_label}
        line_new = line.rsplit(sep='(', maxsplit=1)
        sites = line_new[0].replace('->', ':').split(':')[1:]
        site_indices = tuple((int(re.split('\\D+', site)[1]) - 1 for site in sites))
        cells = [[int(i) for i in re.split('\\[(.*?)\\]', site)[1].split(' ') if i != ''] for site in sites]
        if sites[0].count('[') > 1:
            orbs = [re.findall('\\]\\[(.*)\\]', site)[0] for site in sites]
            orb_label, orbitals = get_orb_from_str(orbs)
        else:
            orbitals = None
            orb_label = None
        return {'sites': site_indices, 'cells': cells, 'length': None, 'orbitals': orbitals, 'orb_label': orb_label}